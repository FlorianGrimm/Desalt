// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="ClassTranslator.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.Core.Translation
{
    using System.Collections.Generic;
    using System.Collections.Immutable;
    using System.Linq;
    using Desalt.Core.Utility;
    using Desalt.TypeScriptAst.Ast;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Factory = TypeScriptAst.Ast.TsAstFactory;

    /// <summary>
    /// Translates C# class declarations to TypeScript.
    /// </summary>
    internal static partial class ClassTranslator
    {
        //// ===========================================================================================================
        //// Methods
        //// ===========================================================================================================

        /// <summary>
        /// Called when the visitor visits a ClassDeclarationSyntax node.
        /// </summary>
        /// <returns>
        /// An <see cref="ITsImplementationModuleElement"/>, which is either an <see
        /// cref="ITsClassElement"/> or an <see cref="ITsExportImplementationElement"/>. If there is
        /// a static constructor, an additional function call ( <see cref="ITsCallExpression"/>) to
        /// the initializer is added immediately after the class declaration.
        /// </returns>
        public static IClassTranslation TranslateClassDeclaration(
            TranslationContext context,
            ClassDeclarationSyntax node)
        {
            ITsIdentifier className = context.TranslateDeclarationIdentifier(node);
            bool isAbstract = node.Modifiers.Any(SyntaxKind.AbstractKeyword);

            // Translate the type parameters if there are any.
            ITsTypeParameters? typeParameters = node.TypeParameterList == null
                ? null
                : FunctionTranslator.TranslateTypeParameterList(node.TypeParameterList);

            // Translate the class heritage (extends and implements).
            ITsTypeReference? extendsClause = null;
            var implementsTypes = new List<ITsTypeReference>();
            if (node.BaseList != null)
            {
                var baseList = TranslateBaseList(context, node.BaseList).ToImmutableArray();

                // Get the type symbols so we can tell which ones are interfaces.
                var typeSymbols = node.BaseList.Types
                    .Select(typeSyntax => context.GetExpectedTypeSymbol(typeSyntax.Type))
                    .ToImmutableArray();

                for (int i = 0; i < baseList.Length; i++)
                {
                    if (typeSymbols[i].IsInterfaceType())
                    {
                        implementsTypes.Add(baseList[i]);
                    }
                    else
                    {
                        if (extendsClause != null)
                        {
                            context.ReportInternalError(
                                "C# isn't supposed to support multiple inheritance! We already saw " +
                                $"'{extendsClause.EmitAsString()}' but we have another type " +
                                $"'{baseList[i].EmitAsString()}' that is claiming to be a base class.",
                                node.BaseList.Types[i].GetLocation());
                        }

                        extendsClause = baseList[i];
                    }
                }
            }

            ITsClassHeritage heritage = Factory.ClassHeritage(extendsClause, implementsTypes.ToArray());

            // Translate the body.
            var visitor = new Visitor(context);
            var classBody = node.Members.SelectMany(visitor.Visit).ToList();

            // Add any auto-generated class member variable declarations at the top of the class, for example when
            // adding auto-generated properties.
            classBody.InsertRange(0, visitor.AutoGeneratedClassVariableDeclarations);

            ITsClassDeclaration classDeclaration = Factory.ClassDeclaration(
                className,
                typeParameters,
                heritage,
                isAbstract,
                classBody);

            // If there's a static constructor, then we need to add a call to it right after the class declaration.
            ITsExpressionStatement? staticCtorInvocationStatement = null;
            if (classDeclaration.ClassBody.OfType<ITsMemberFunctionDeclaration>()
                .Any(method => method.FunctionName == Visitor.StaticCtorName))
            {
                ITsCallExpression staticCtorCall = Factory.Call(Factory.MemberDot(className, Visitor.StaticCtorName.Text))
                    .WithLeadingTrivia(Factory.SingleLineComment("Call the static constructor"));
                staticCtorInvocationStatement = Factory.ExpressionStatement(staticCtorCall);
            }

            // Add documentation comments.
            classDeclaration = context.AddDocumentationComment(classDeclaration, node);
            var result = new ClassTranslation(classDeclaration, staticCtorInvocationStatement);
            return result;
        }

        /// <summary>
        /// Called when the visitor visits a BaseListSyntax node.
        /// </summary>
        /// <returns>An enumerable of <see cref="ITsTypeReference"/>.</returns>
        private static IEnumerable<ITsTypeReference> TranslateBaseList(TranslationContext context, BaseListSyntax node)
        {
            return node.Types.Select(x => TranslateBaseType(context, x));
        }

        /// <summary>
        /// Called when the visitor visits a SimpleBaseTypeSyntax node.
        /// </summary>
        /// <returns>An <see cref="ITsTypeReference"/>.</returns>
        private static ITsTypeReference TranslateBaseType(TranslationContext context, BaseTypeSyntax node)
        {
            ITypeSymbol typeSymbol = context.GetExpectedTypeSymbol(node.Type);
            var translated = (ITsTypeReference)TypeTranslator.TranslateTypeSymbol(
                context,
                typeSymbol,
                node.Type.GetLocation);

            return translated;
        }

        //// ===========================================================================================================
        //// Classes
        //// ===========================================================================================================

        private sealed class ClassTranslation : IClassTranslation
        {
            public ClassTranslation(
                ITsClassDeclaration classDeclaration,
                ITsExpressionStatement? staticCtorInvocationStatement)
            {
                ClassDeclaration = classDeclaration;
                StaticCtorInvocationStatement = staticCtorInvocationStatement;
            }

            public ITsClassDeclaration ClassDeclaration { get; }
            public ITsExpressionStatement? StaticCtorInvocationStatement { get; }
        }
    }

    internal interface IClassTranslation
    {
        ITsClassDeclaration ClassDeclaration { get; }

        /// <summary>
        /// Gets the optional static constructor method invocation that should appear after the class declaration.
        /// </summary>
        ITsExpressionStatement? StaticCtorInvocationStatement { get; }
    }
}
