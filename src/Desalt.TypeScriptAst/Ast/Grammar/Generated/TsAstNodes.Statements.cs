// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Statements.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Statement
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all statements.
    /// </summary>
    public interface ITsStatement : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// BlockStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a block statement of the form '{ statements }'.
    /// </summary>
    public interface ITsBlockStatement : ITsStatement
    {
        ImmutableArray<ITsStatementListItem> Statements { get; }
    }

    /// <summary>
    /// Represents a block statement of the form '{ statements }'.
    /// </summary>
    internal partial class TsBlockStatement : TsAstNode, ITsBlockStatement
    {
        public TsBlockStatement(
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitBlockStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBlockStatement(emitter, this);
    }

    public static class BlockStatementExtensions
    {
        public static ITsBlockStatement WithStatements(this ITsBlockStatement node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsBlockStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BreakStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a break statement of the form, 'break [label]'.
    /// </summary>
    public interface ITsBreakStatement : ITsStatement
    {
        ITsIdentifier? Label { get; }
    }

    /// <summary>
    /// Represents a break statement of the form, 'break [label]'.
    /// </summary>
    internal partial class TsBreakStatement : TsAstNode, ITsBreakStatement
    {
        public TsBreakStatement(
            ITsIdentifier? label,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(label);
            Label = label;
        }

        public ITsIdentifier? Label { get; }

        partial void VerifyInputs(ITsIdentifier? label);
        public override void Accept(TsVisitor visitor) => visitor.VisitBreakStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBreakStatement(emitter, this);
    }

    public static class BreakStatementExtensions
    {
        public static ITsBreakStatement WithLabel(this ITsBreakStatement node, ITsIdentifier? value) =>
            node.Label == value ? node : new TsBreakStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ContinueStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a continue statement of the form, 'continue [label]'.
    /// </summary>
    public interface ITsContinueStatement : ITsStatement
    {
        ITsIdentifier? Label { get; }
    }

    /// <summary>
    /// Represents a continue statement of the form, 'continue [label]'.
    /// </summary>
    internal partial class TsContinueStatement : TsAstNode, ITsContinueStatement
    {
        public TsContinueStatement(
            ITsIdentifier? label,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(label);
            Label = label;
        }

        public ITsIdentifier? Label { get; }

        partial void VerifyInputs(ITsIdentifier? label);
        public override void Accept(TsVisitor visitor) => visitor.VisitContinueStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitContinueStatement(emitter, this);
    }

    public static class ContinueStatementExtensions
    {
        public static ITsContinueStatement WithLabel(this ITsContinueStatement node, ITsIdentifier? value) =>
            node.Label == value ? node : new TsContinueStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DebuggerStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'debugger' statement.
    /// </summary>
    public interface ITsDebuggerStatement : ITsStatement
    {
    }

    /// <summary>
    /// Represents a 'debugger' statement.
    /// </summary>
    internal partial class TsDebuggerStatement : TsAstNode, ITsDebuggerStatement
    {
        public TsDebuggerStatement(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitDebuggerStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDebuggerStatement(emitter, this);
    }

    //// ===============================================================================================================
    //// DoWhileStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a do/while statement.
    /// </summary>
    public interface ITsDoWhileStatement : ITsStatement
    {
        ITsStatement DoStatement { get; }
        ITsExpression WhileCondition { get; }
    }

    /// <summary>
    /// Represents a do/while statement.
    /// </summary>
    internal partial class TsDoWhileStatement : TsAstNode, ITsDoWhileStatement
    {
        public TsDoWhileStatement(
            ITsStatement doStatement,
            ITsExpression whileCondition,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(doStatement, whileCondition);
            DoStatement = doStatement;
            WhileCondition = whileCondition;
        }

        public ITsStatement DoStatement { get; }
        public ITsExpression WhileCondition { get; }

        partial void VerifyInputs(ITsStatement doStatement, ITsExpression whileCondition);
        public override void Accept(TsVisitor visitor) => visitor.VisitDoWhileStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDoWhileStatement(emitter, this);
    }

    public static class DoWhileStatementExtensions
    {
        public static ITsDoWhileStatement WithDoStatement(this ITsDoWhileStatement node, ITsStatement value) =>
            node.DoStatement == value ? node : new TsDoWhileStatement(value, node.WhileCondition, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsDoWhileStatement WithWhileCondition(this ITsDoWhileStatement node, ITsExpression value) =>
            node.WhileCondition == value ? node : new TsDoWhileStatement(node.DoStatement, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// EmptyStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an empty statement.
    /// </summary>
    public interface ITsEmptyStatement : ITsStatement
    {
    }

    /// <summary>
    /// Represents an empty statement.
    /// </summary>
    internal partial class TsEmptyStatement : TsAstNode, ITsEmptyStatement
    {
        public TsEmptyStatement(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitEmptyStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitEmptyStatement(emitter, this);
    }

    //// ===============================================================================================================
    //// ExpressionStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression in statement form.
    /// </summary>
    public interface ITsExpressionStatement : ITsStatement
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents an expression in statement form.
    /// </summary>
    internal partial class TsExpressionStatement : TsAstNode, ITsExpressionStatement
    {
        public TsExpressionStatement(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitExpressionStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitExpressionStatement(emitter, this);
    }

    public static class ExpressionStatementExtensions
    {
        public static ITsExpressionStatement WithExpression(this ITsExpressionStatement node, ITsExpression value) =>
            node.Expression == value ? node : new TsExpressionStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ForInStatement
    //// ===============================================================================================================

    public enum VariableDeclarationKind
    {
        Var,
        Let,
        Const,
    }

    /// <summary>
    /// Represents a for-in loop of the form 'for (const x: type in expression) statement'.
    /// </summary>
    public interface ITsForInStatement : ITsStatement
    {
        ITsExpression? Initializer { get; }
        VariableDeclarationKind? DeclarationKind { get; }
        ITsBindingIdentifierOrPattern? Declaration { get; }
        ITsExpression RightSide { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a for-in loop of the form 'for (const x: type in expression) statement'.
    /// </summary>
    internal partial class TsForInStatement : TsAstNode, ITsForInStatement
    {
        public TsForInStatement(
            ITsExpression? initializer,
            VariableDeclarationKind? declarationKind,
            ITsBindingIdentifierOrPattern? declaration,
            ITsExpression rightSide,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(initializer, declarationKind, declaration, rightSide, statement);
            Initializer = initializer;
            DeclarationKind = declarationKind;
            Declaration = declaration;
            RightSide = rightSide;
            Statement = statement;
        }

        public ITsExpression? Initializer { get; }
        public VariableDeclarationKind? DeclarationKind { get; }
        public ITsBindingIdentifierOrPattern? Declaration { get; }
        public ITsExpression RightSide { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression? initializer, VariableDeclarationKind? declarationKind, ITsBindingIdentifierOrPattern? declaration, ITsExpression rightSide, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitForInStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitForInStatement(emitter, this);
    }

    public static class ForInStatementExtensions
    {
        public static ITsForInStatement WithInitializer(this ITsForInStatement node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsForInStatement(value, node.DeclarationKind, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithDeclarationKind(this ITsForInStatement node, VariableDeclarationKind? value) =>
            node.DeclarationKind == value ? node : new TsForInStatement(node.Initializer, value, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithDeclaration(this ITsForInStatement node, ITsBindingIdentifierOrPattern? value) =>
            node.Declaration == value ? node : new TsForInStatement(node.Initializer, node.DeclarationKind, value, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithRightSide(this ITsForInStatement node, ITsExpression value) =>
            node.RightSide == value ? node : new TsForInStatement(node.Initializer, node.DeclarationKind, node.Declaration, value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithStatement(this ITsForInStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsForInStatement(node.Initializer, node.DeclarationKind, node.Declaration, node.RightSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ForOfStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a for-of loop of the form 'for (const x: type of expression) statement'.
    /// </summary>
    public interface ITsForOfStatement : ITsStatement
    {
        ITsExpression? Initializer { get; }
        VariableDeclarationKind? DeclarationKind { get; }
        ITsBindingIdentifierOrPattern? Declaration { get; }
        ITsExpression RightSide { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a for-of loop of the form 'for (const x: type of expression) statement'.
    /// </summary>
    internal partial class TsForOfStatement : TsAstNode, ITsForOfStatement
    {
        public TsForOfStatement(
            ITsExpression? initializer,
            VariableDeclarationKind? declarationKind,
            ITsBindingIdentifierOrPattern? declaration,
            ITsExpression rightSide,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(initializer, declarationKind, declaration, rightSide, statement);
            Initializer = initializer;
            DeclarationKind = declarationKind;
            Declaration = declaration;
            RightSide = rightSide;
            Statement = statement;
        }

        public ITsExpression? Initializer { get; }
        public VariableDeclarationKind? DeclarationKind { get; }
        public ITsBindingIdentifierOrPattern? Declaration { get; }
        public ITsExpression RightSide { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression? initializer, VariableDeclarationKind? declarationKind, ITsBindingIdentifierOrPattern? declaration, ITsExpression rightSide, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitForOfStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitForOfStatement(emitter, this);
    }

    public static class ForOfStatementExtensions
    {
        public static ITsForOfStatement WithInitializer(this ITsForOfStatement node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsForOfStatement(value, node.DeclarationKind, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithDeclarationKind(this ITsForOfStatement node, VariableDeclarationKind? value) =>
            node.DeclarationKind == value ? node : new TsForOfStatement(node.Initializer, value, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithDeclaration(this ITsForOfStatement node, ITsBindingIdentifierOrPattern? value) =>
            node.Declaration == value ? node : new TsForOfStatement(node.Initializer, node.DeclarationKind, value, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithRightSide(this ITsForOfStatement node, ITsExpression value) =>
            node.RightSide == value ? node : new TsForOfStatement(node.Initializer, node.DeclarationKind, node.Declaration, value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithStatement(this ITsForOfStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsForOfStatement(node.Initializer, node.DeclarationKind, node.Declaration, node.RightSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ForStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'for' loop.
    /// </summary>
    public interface ITsForStatement : ITsStatement
    {
        ITsExpression? Initializer { get; }
        ImmutableArray<ITsVariableDeclaration>? InitializerWithVariableDeclarations { get; }
        ITsLexicalDeclaration? InitializerWithLexicalDeclaration { get; }
        ITsExpression? Condition { get; }
        ITsExpression? Incrementor { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a 'for' loop.
    /// </summary>
    internal partial class TsForStatement : TsAstNode, ITsForStatement
    {
        public TsForStatement(
            ITsExpression? initializer,
            ImmutableArray<ITsVariableDeclaration>? initializerWithVariableDeclarations,
            ITsLexicalDeclaration? initializerWithLexicalDeclaration,
            ITsExpression? condition,
            ITsExpression? incrementor,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(initializer, initializerWithVariableDeclarations, initializerWithLexicalDeclaration, condition, incrementor, statement);
            Initializer = initializer;
            InitializerWithVariableDeclarations = initializerWithVariableDeclarations;
            InitializerWithLexicalDeclaration = initializerWithLexicalDeclaration;
            Condition = condition;
            Incrementor = incrementor;
            Statement = statement;
        }

        public ITsExpression? Initializer { get; }
        public ImmutableArray<ITsVariableDeclaration>? InitializerWithVariableDeclarations { get; }
        public ITsLexicalDeclaration? InitializerWithLexicalDeclaration { get; }
        public ITsExpression? Condition { get; }
        public ITsExpression? Incrementor { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression? initializer, ImmutableArray<ITsVariableDeclaration>? initializerWithVariableDeclarations, ITsLexicalDeclaration? initializerWithLexicalDeclaration, ITsExpression? condition, ITsExpression? incrementor, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitForStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitForStatement(emitter, this);
    }

    public static class ForStatementExtensions
    {
        public static ITsForStatement WithInitializer(this ITsForStatement node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsForStatement(value, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, node.Condition, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithInitializerWithVariableDeclarations(this ITsForStatement node, ImmutableArray<ITsVariableDeclaration>? value) =>
            node.InitializerWithVariableDeclarations == value ? node : new TsForStatement(node.Initializer, value, node.InitializerWithLexicalDeclaration, node.Condition, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithInitializerWithLexicalDeclaration(this ITsForStatement node, ITsLexicalDeclaration? value) =>
            node.InitializerWithLexicalDeclaration == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, value, node.Condition, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithCondition(this ITsForStatement node, ITsExpression? value) =>
            node.Condition == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, value, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithIncrementor(this ITsForStatement node, ITsExpression? value) =>
            node.Incrementor == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, node.Condition, value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithStatement(this ITsForStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, node.Condition, node.Incrementor, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// IfStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an 'if' statement of the form 'if (expression) statement else statement'.
    /// </summary>
    public interface ITsIfStatement : ITsStatement
    {
        ITsExpression IfCondition { get; }
        ITsStatement IfStatement { get; }
        ITsStatement? ElseStatement { get; }
    }

    /// <summary>
    /// Represents an 'if' statement of the form 'if (expression) statement else statement'.
    /// </summary>
    internal partial class TsIfStatement : TsAstNode, ITsIfStatement
    {
        public TsIfStatement(
            ITsExpression ifCondition,
            ITsStatement ifStatement,
            ITsStatement? elseStatement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(ifCondition, ifStatement, elseStatement);
            IfCondition = ifCondition;
            IfStatement = ifStatement;
            ElseStatement = elseStatement;
        }

        public ITsExpression IfCondition { get; }
        public ITsStatement IfStatement { get; }
        public ITsStatement? ElseStatement { get; }

        partial void VerifyInputs(ITsExpression ifCondition, ITsStatement ifStatement, ITsStatement? elseStatement);
        public override void Accept(TsVisitor visitor) => visitor.VisitIfStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIfStatement(emitter, this);
    }

    public static class IfStatementExtensions
    {
        public static ITsIfStatement WithIfCondition(this ITsIfStatement node, ITsExpression value) =>
            node.IfCondition == value ? node : new TsIfStatement(value, node.IfStatement, node.ElseStatement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsIfStatement WithIfStatement(this ITsIfStatement node, ITsStatement value) =>
            node.IfStatement == value ? node : new TsIfStatement(node.IfCondition, value, node.ElseStatement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsIfStatement WithElseStatement(this ITsIfStatement node, ITsStatement? value) =>
            node.ElseStatement == value ? node : new TsIfStatement(node.IfCondition, node.IfStatement, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// LabeledStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a labeled statement.
    /// </summary>
    public interface ITsLabeledStatement : ITsStatement
    {
        ITsIdentifier Label { get; }
        ITsStatement? Statement { get; }
        ITsFunctionDeclaration? FunctionDeclaration { get; }
    }

    /// <summary>
    /// Represents a labeled statement.
    /// </summary>
    internal partial class TsLabeledStatement : TsAstNode, ITsLabeledStatement
    {
        public TsLabeledStatement(
            ITsIdentifier label,
            ITsStatement? statement,
            ITsFunctionDeclaration? functionDeclaration,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(label, statement, functionDeclaration);
            Label = label;
            Statement = statement;
            FunctionDeclaration = functionDeclaration;
        }

        public ITsIdentifier Label { get; }
        public ITsStatement? Statement { get; }
        public ITsFunctionDeclaration? FunctionDeclaration { get; }

        partial void VerifyInputs(ITsIdentifier label, ITsStatement? statement, ITsFunctionDeclaration? functionDeclaration);
        public override void Accept(TsVisitor visitor) => visitor.VisitLabeledStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitLabeledStatement(emitter, this);
    }

    public static class LabeledStatementExtensions
    {
        public static ITsLabeledStatement WithLabel(this ITsLabeledStatement node, ITsIdentifier value) =>
            node.Label == value ? node : new TsLabeledStatement(value, node.Statement, node.FunctionDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLabeledStatement WithStatement(this ITsLabeledStatement node, ITsStatement? value) =>
            node.Statement == value ? node : new TsLabeledStatement(node.Label, value, node.FunctionDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLabeledStatement WithFunctionDeclaration(this ITsLabeledStatement node, ITsFunctionDeclaration? value) =>
            node.FunctionDeclaration == value ? node : new TsLabeledStatement(node.Label, node.Statement, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ReturnStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'return' statement.
    /// </summary>
    public interface ITsReturnStatement : ITsStatement
    {
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a 'return' statement.
    /// </summary>
    internal partial class TsReturnStatement : TsAstNode, ITsReturnStatement
    {
        public TsReturnStatement(
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression? Expression { get; }

        partial void VerifyInputs(ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitReturnStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitReturnStatement(emitter, this);
    }

    public static class ReturnStatementExtensions
    {
        public static ITsReturnStatement WithExpression(this ITsReturnStatement node, ITsExpression? value) =>
            node.Expression == value ? node : new TsReturnStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SwitchStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a switch statement of the form 'switch (condition) { case x: statement; default: statement; }'.
    /// </summary>
    public interface ITsSwitchStatement : ITsStatement
    {
        ITsExpression Condition { get; }
        ImmutableArray<ITsCaseOrDefaultClause> Clauses { get; }
    }

    /// <summary>
    /// Represents a switch statement of the form 'switch (condition) { case x: statement; default: statement; }'.
    /// </summary>
    internal partial class TsSwitchStatement : TsAstNode, ITsSwitchStatement
    {
        public TsSwitchStatement(
            ITsExpression condition,
            ImmutableArray<ITsCaseOrDefaultClause> clauses,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(condition, clauses);
            Condition = condition;
            Clauses = clauses;
        }

        public ITsExpression Condition { get; }
        public ImmutableArray<ITsCaseOrDefaultClause> Clauses { get; }

        partial void VerifyInputs(ITsExpression condition, ImmutableArray<ITsCaseOrDefaultClause> clauses);
        public override void Accept(TsVisitor visitor) => visitor.VisitSwitchStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSwitchStatement(emitter, this);
    }

    public static class SwitchStatementExtensions
    {
        public static ITsSwitchStatement WithCondition(this ITsSwitchStatement node, ITsExpression value) =>
            node.Condition == value ? node : new TsSwitchStatement(value, node.Clauses, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSwitchStatement WithClauses(this ITsSwitchStatement node, ImmutableArray<ITsCaseOrDefaultClause> value) =>
            node.Clauses == value ? node : new TsSwitchStatement(node.Condition, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ThrowStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'throw' statement.
    /// </summary>
    public interface ITsThrowStatement : ITsStatement
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a 'throw' statement.
    /// </summary>
    internal partial class TsThrowStatement : TsAstNode, ITsThrowStatement
    {
        public TsThrowStatement(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitThrowStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitThrowStatement(emitter, this);
    }

    public static class ThrowStatementExtensions
    {
        public static ITsThrowStatement WithExpression(this ITsThrowStatement node, ITsExpression value) =>
            node.Expression == value ? node : new TsThrowStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TryStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a try/catch/finally statement.
    /// </summary>
    public interface ITsTryStatement : ITsStatement
    {
        ITsBlockStatement TryBlock { get; }
        ITsBindingIdentifierOrPattern? CatchParameter { get; }
        ITsBlockStatement? CatchBlock { get; }
        ITsBlockStatement? FinallyBlock { get; }
    }

    /// <summary>
    /// Represents a try/catch/finally statement.
    /// </summary>
    internal partial class TsTryStatement : TsAstNode, ITsTryStatement
    {
        public TsTryStatement(
            ITsBlockStatement tryBlock,
            ITsBindingIdentifierOrPattern? catchParameter,
            ITsBlockStatement? catchBlock,
            ITsBlockStatement? finallyBlock,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(tryBlock, catchParameter, catchBlock, finallyBlock);
            TryBlock = tryBlock;
            CatchParameter = catchParameter;
            CatchBlock = catchBlock;
            FinallyBlock = finallyBlock;
        }

        public ITsBlockStatement TryBlock { get; }
        public ITsBindingIdentifierOrPattern? CatchParameter { get; }
        public ITsBlockStatement? CatchBlock { get; }
        public ITsBlockStatement? FinallyBlock { get; }

        partial void VerifyInputs(ITsBlockStatement tryBlock, ITsBindingIdentifierOrPattern? catchParameter, ITsBlockStatement? catchBlock, ITsBlockStatement? finallyBlock);
        public override void Accept(TsVisitor visitor) => visitor.VisitTryStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTryStatement(emitter, this);
    }

    public static class TryStatementExtensions
    {
        public static ITsTryStatement WithTryBlock(this ITsTryStatement node, ITsBlockStatement value) =>
            node.TryBlock == value ? node : new TsTryStatement(value, node.CatchParameter, node.CatchBlock, node.FinallyBlock, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTryStatement WithCatchParameter(this ITsTryStatement node, ITsBindingIdentifierOrPattern? value) =>
            node.CatchParameter == value ? node : new TsTryStatement(node.TryBlock, value, node.CatchBlock, node.FinallyBlock, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTryStatement WithCatchBlock(this ITsTryStatement node, ITsBlockStatement? value) =>
            node.CatchBlock == value ? node : new TsTryStatement(node.TryBlock, node.CatchParameter, value, node.FinallyBlock, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTryStatement WithFinallyBlock(this ITsTryStatement node, ITsBlockStatement? value) =>
            node.FinallyBlock == value ? node : new TsTryStatement(node.TryBlock, node.CatchParameter, node.CatchBlock, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// VariableStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a variable declaration statement of the form 'var x = y;'.
    /// </summary>
    public interface ITsVariableStatement : ITsStatement
    {
        ImmutableArray<ITsVariableDeclaration> Declarations { get; }
    }

    /// <summary>
    /// Represents a variable declaration statement of the form 'var x = y;'.
    /// </summary>
    internal partial class TsVariableStatement : TsAstNode, ITsVariableStatement
    {
        public TsVariableStatement(
            ImmutableArray<ITsVariableDeclaration> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(declarations);
            Declarations = declarations;
        }

        public ImmutableArray<ITsVariableDeclaration> Declarations { get; }

        partial void VerifyInputs(ImmutableArray<ITsVariableDeclaration> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitVariableStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitVariableStatement(emitter, this);
    }

    public static class VariableStatementExtensions
    {
        public static ITsVariableStatement WithDeclarations(this ITsVariableStatement node, ImmutableArray<ITsVariableDeclaration> value) =>
            node.Declarations == value ? node : new TsVariableStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// WhileStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a while loop.
    /// </summary>
    public interface ITsWhileStatement : ITsStatement
    {
        ITsExpression WhileCondition { get; }
        ITsStatement WhileStatement { get; }
    }

    /// <summary>
    /// Represents a while loop.
    /// </summary>
    internal partial class TsWhileStatement : TsAstNode, ITsWhileStatement
    {
        public TsWhileStatement(
            ITsExpression whileCondition,
            ITsStatement whileStatement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(whileCondition, whileStatement);
            WhileCondition = whileCondition;
            WhileStatement = whileStatement;
        }

        public ITsExpression WhileCondition { get; }
        public ITsStatement WhileStatement { get; }

        partial void VerifyInputs(ITsExpression whileCondition, ITsStatement whileStatement);
        public override void Accept(TsVisitor visitor) => visitor.VisitWhileStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitWhileStatement(emitter, this);
    }

    public static class WhileStatementExtensions
    {
        public static ITsWhileStatement WithWhileCondition(this ITsWhileStatement node, ITsExpression value) =>
            node.WhileCondition == value ? node : new TsWhileStatement(value, node.WhileStatement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsWhileStatement WithWhileStatement(this ITsWhileStatement node, ITsStatement value) =>
            node.WhileStatement == value ? node : new TsWhileStatement(node.WhileCondition, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// WithStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'with' statement of the form, 'with (expression) statement'.
    /// </summary>
    public interface ITsWithStatement : ITsStatement
    {
        ITsExpression Expression { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a 'with' statement of the form, 'with (expression) statement'.
    /// </summary>
    internal partial class TsWithStatement : TsAstNode, ITsWithStatement
    {
        public TsWithStatement(
            ITsExpression expression,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, statement);
            Expression = expression;
            Statement = statement;
        }

        public ITsExpression Expression { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression expression, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitWithStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitWithStatement(emitter, this);
    }

    public static class WithStatementExtensions
    {
        public static ITsWithStatement WithExpression(this ITsWithStatement node, ITsExpression value) =>
            node.Expression == value ? node : new TsWithStatement(value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsWithStatement WithStatement(this ITsWithStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsWithStatement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
