// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Types.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
// TypeScript Grammar, version 1.8 (Jan 2016)
// ==========================================
// See https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md
// 
// The TypeScript grammar is a superset of the grammar defined in the ECMAScript 2015 Language
// Specification (specifically, the ECMA-262 Standard, 6th Edition) and this appendix lists only
// productions that are new or modified from the ECMAScript grammar.
// 
// See http://www.ecma-international.org/ecma-262/6.0/ for the ES2015 grammar.
// 
// Many of these interface names and shapes are taken from the TypeScript source code at:
// https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts.
// 
// There is also an Antlr grammar defined here:
// https://raw.githubusercontent.com/antlr/grammars-v4/master/typescript/TypeScriptParser.g4
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Type
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all types.
    /// </summary>
    public interface ITsType : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// TypeMember
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all type members.
    /// </summary>
    public interface ITsTypeMember : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ArrayType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript array type.
    /// </summary>
    public interface ITsArrayType : ITsType
    {
        ITsType Type { get; }
    }

    /// <summary>
    /// Represents a TypeScript array type.
    /// </summary>
    internal partial class TsArrayType : TsAstNode, ITsArrayType
    {
        public TsArrayType(
            ITsType type,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(type);
            Type = type;
        }

        public ITsType Type { get; }

        partial void VerifyInputs(ITsType type);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsArrayType(Type, leadingTrivia, trailingTrivia);
    }

    public static class ArrayTypeExtensions
    {
        public static ITsArrayType WithType(this ITsArrayType node, ITsType value) =>
            node.Type == value ? node : new TsArrayType(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CallSignature
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call signature of the form '&gt;T&lt;(parameter: type): type'.
    /// </summary>
    public interface ITsCallSignature : ITsTypeMember
    {
        ITsTypeParameters? TypeParameters { get; }
        ITsParameterList? Parameters { get; }
        ITsType? ReturnType { get; }
    }

    /// <summary>
    /// Represents a call signature of the form '&gt;T&lt;(parameter: type): type'.
    /// </summary>
    internal partial class TsCallSignature : TsAstNode, ITsCallSignature
    {
        public TsCallSignature(
            ITsTypeParameters? typeParameters,
            ITsParameterList? parameters,
            ITsType? returnType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeParameters, parameters, returnType);
            TypeParameters = typeParameters;
            Parameters = parameters;
            ReturnType = returnType;
        }

        public ITsTypeParameters? TypeParameters { get; }
        public ITsParameterList? Parameters { get; }
        public ITsType? ReturnType { get; }

        partial void VerifyInputs(ITsTypeParameters? typeParameters, ITsParameterList? parameters, ITsType? returnType);
        public override void Accept(TsVisitor visitor) => visitor.VisitCallSignature(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCallSignature(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsCallSignature(TypeParameters, Parameters, ReturnType, leadingTrivia, trailingTrivia);
    }

    public static class CallSignatureExtensions
    {
        public static ITsCallSignature WithTypeParameters(this ITsCallSignature node, ITsTypeParameters? value) =>
            node.TypeParameters == value ? node : new TsCallSignature(value, node.Parameters, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCallSignature WithParameters(this ITsCallSignature node, ITsParameterList? value) =>
            node.Parameters == value ? node : new TsCallSignature(node.TypeParameters, value, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCallSignature WithReturnType(this ITsCallSignature node, ITsType? value) =>
            node.ReturnType == value ? node : new TsCallSignature(node.TypeParameters, node.Parameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ConstructorType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript constructor type.
    /// </summary>
    public interface ITsConstructorType : ITsType
    {
        ITsTypeParameters? TypeParameters { get; }
        ITsParameterList? Parameters { get; }
        ITsType ReturnType { get; }
    }

    /// <summary>
    /// Represents a TypeScript constructor type.
    /// </summary>
    internal partial class TsConstructorType : TsAstNode, ITsConstructorType
    {
        public TsConstructorType(
            ITsTypeParameters? typeParameters,
            ITsParameterList? parameters,
            ITsType returnType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeParameters, parameters, returnType);
            TypeParameters = typeParameters;
            Parameters = parameters;
            ReturnType = returnType;
        }

        public ITsTypeParameters? TypeParameters { get; }
        public ITsParameterList? Parameters { get; }
        public ITsType ReturnType { get; }

        partial void VerifyInputs(ITsTypeParameters? typeParameters, ITsParameterList? parameters, ITsType returnType);
        public override void Accept(TsVisitor visitor) => visitor.VisitConstructorType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitConstructorType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsConstructorType(TypeParameters, Parameters, ReturnType, leadingTrivia, trailingTrivia);
    }

    public static class ConstructorTypeExtensions
    {
        public static ITsConstructorType WithTypeParameters(this ITsConstructorType node, ITsTypeParameters? value) =>
            node.TypeParameters == value ? node : new TsConstructorType(value, node.Parameters, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConstructorType WithParameters(this ITsConstructorType node, ITsParameterList? value) =>
            node.Parameters == value ? node : new TsConstructorType(node.TypeParameters, value, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConstructorType WithReturnType(this ITsConstructorType node, ITsType value) =>
            node.ReturnType == value ? node : new TsConstructorType(node.TypeParameters, node.Parameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ConstructSignature
    //// ===============================================================================================================

    /// <summary>
    /// Represents a constructor method signature of the form 'new &lt;T&gt;(parameter: type): type'.
    /// </summary>
    public interface ITsConstructSignature : ITsTypeMember
    {
        ITsTypeParameters? TypeParameters { get; }
        ITsParameterList? Parameters { get; }
        ITsType? ReturnType { get; }
    }

    /// <summary>
    /// Represents a constructor method signature of the form 'new &lt;T&gt;(parameter: type): type'.
    /// </summary>
    internal partial class TsConstructSignature : TsAstNode, ITsConstructSignature
    {
        public TsConstructSignature(
            ITsTypeParameters? typeParameters,
            ITsParameterList? parameters,
            ITsType? returnType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeParameters, parameters, returnType);
            TypeParameters = typeParameters;
            Parameters = parameters;
            ReturnType = returnType;
        }

        public ITsTypeParameters? TypeParameters { get; }
        public ITsParameterList? Parameters { get; }
        public ITsType? ReturnType { get; }

        partial void VerifyInputs(ITsTypeParameters? typeParameters, ITsParameterList? parameters, ITsType? returnType);
        public override void Accept(TsVisitor visitor) => visitor.VisitConstructSignature(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitConstructSignature(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsConstructSignature(TypeParameters, Parameters, ReturnType, leadingTrivia, trailingTrivia);
    }

    public static class ConstructSignatureExtensions
    {
        public static ITsConstructSignature WithTypeParameters(this ITsConstructSignature node, ITsTypeParameters? value) =>
            node.TypeParameters == value ? node : new TsConstructSignature(value, node.Parameters, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConstructSignature WithParameters(this ITsConstructSignature node, ITsParameterList? value) =>
            node.Parameters == value ? node : new TsConstructSignature(node.TypeParameters, value, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConstructSignature WithReturnType(this ITsConstructSignature node, ITsType? value) =>
            node.ReturnType == value ? node : new TsConstructSignature(node.TypeParameters, node.Parameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// FunctionType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript function type.
    /// </summary>
    public interface ITsFunctionType : ITsType
    {
        ITsTypeParameters? TypeParameters { get; }
        ITsParameterList? Parameters { get; }
        ITsType ReturnType { get; }
    }

    /// <summary>
    /// Represents a TypeScript function type.
    /// </summary>
    internal partial class TsFunctionType : TsAstNode, ITsFunctionType
    {
        public TsFunctionType(
            ITsTypeParameters? typeParameters,
            ITsParameterList? parameters,
            ITsType returnType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeParameters, parameters, returnType);
            TypeParameters = typeParameters;
            Parameters = parameters;
            ReturnType = returnType;
        }

        public ITsTypeParameters? TypeParameters { get; }
        public ITsParameterList? Parameters { get; }
        public ITsType ReturnType { get; }

        partial void VerifyInputs(ITsTypeParameters? typeParameters, ITsParameterList? parameters, ITsType returnType);
        public override void Accept(TsVisitor visitor) => visitor.VisitFunctionType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitFunctionType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsFunctionType(TypeParameters, Parameters, ReturnType, leadingTrivia, trailingTrivia);
    }

    public static class FunctionTypeExtensions
    {
        public static ITsFunctionType WithTypeParameters(this ITsFunctionType node, ITsTypeParameters? value) =>
            node.TypeParameters == value ? node : new TsFunctionType(value, node.Parameters, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsFunctionType WithParameters(this ITsFunctionType node, ITsParameterList? value) =>
            node.Parameters == value ? node : new TsFunctionType(node.TypeParameters, value, node.ReturnType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsFunctionType WithReturnType(this ITsFunctionType node, ITsType value) =>
            node.ReturnType == value ? node : new TsFunctionType(node.TypeParameters, node.Parameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// IntersectionType
    //// ===============================================================================================================

    /// <summary>
    /// Represents an intersection type of the form 'type1 &amp; type2'.
    /// </summary>
    public interface ITsIntersectionType : ITsType
    {
        ImmutableArray<ITsType> Types { get; }
    }

    /// <summary>
    /// Represents an intersection type of the form 'type1 &amp; type2'.
    /// </summary>
    internal partial class TsIntersectionType : TsAstNode, ITsIntersectionType
    {
        public TsIntersectionType(
            ImmutableArray<ITsType> types,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(types);
            Types = types;
        }

        public ImmutableArray<ITsType> Types { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> types);
        public override void Accept(TsVisitor visitor) => visitor.VisitIntersectionType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIntersectionType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsIntersectionType(Types, leadingTrivia, trailingTrivia);
    }

    public static class IntersectionTypeExtensions
    {
        public static ITsIntersectionType WithTypes(this ITsIntersectionType node, ImmutableArray<ITsType> value) =>
            node.Types == value ? node : new TsIntersectionType(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MethodSignature
    //// ===============================================================================================================

    /// <summary>
    /// Represents a method signature, which is a shorthand for declaring a property of a function type.
    /// </summary>
    public interface ITsMethodSignature : ITsTypeMember
    {
        ITsPropertyName PropertyName { get; }
        bool IsOptional { get; }
        ITsCallSignature CallSignature { get; }
    }

    /// <summary>
    /// Represents a method signature, which is a shorthand for declaring a property of a function type.
    /// </summary>
    internal partial class TsMethodSignature : TsAstNode, ITsMethodSignature
    {
        public TsMethodSignature(
            ITsPropertyName propertyName,
            bool isOptional,
            ITsCallSignature callSignature,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, isOptional, callSignature);
            PropertyName = propertyName;
            IsOptional = isOptional;
            CallSignature = callSignature;
        }

        public ITsPropertyName PropertyName { get; }
        public bool IsOptional { get; }
        public ITsCallSignature CallSignature { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, bool isOptional, ITsCallSignature callSignature);
        public override void Accept(TsVisitor visitor) => visitor.VisitMethodSignature(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMethodSignature(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsMethodSignature(PropertyName, IsOptional, CallSignature, leadingTrivia, trailingTrivia);
    }

    public static class MethodSignatureExtensions
    {
        public static ITsMethodSignature WithPropertyName(this ITsMethodSignature node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsMethodSignature(value, node.IsOptional, node.CallSignature, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMethodSignature WithIsOptional(this ITsMethodSignature node, bool value) =>
            node.IsOptional == value ? node : new TsMethodSignature(node.PropertyName, value, node.CallSignature, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMethodSignature WithCallSignature(this ITsMethodSignature node, ITsCallSignature value) =>
            node.CallSignature == value ? node : new TsMethodSignature(node.PropertyName, node.IsOptional, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ObjectType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript object type.
    /// </summary>
    public interface ITsObjectType : ITsType
    {
        ImmutableArray<ITsTypeMember> TypeMembers { get; }
        /// <summary>
        /// Determines whether the object should be emitted on a single line. This technically should not be part of the interface, but it's easier with the current infrastructure
        /// </summary>
        bool ForceSingleLine { get; }
    }

    /// <summary>
    /// Represents a TypeScript object type.
    /// </summary>
    internal partial class TsObjectType : TsAstNode, ITsObjectType
    {
        public TsObjectType(
            ImmutableArray<ITsTypeMember> typeMembers,
            bool forceSingleLine,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeMembers, forceSingleLine);
            TypeMembers = typeMembers;
            ForceSingleLine = forceSingleLine;
        }

        public ImmutableArray<ITsTypeMember> TypeMembers { get; }
        /// <summary>
        /// Determines whether the object should be emitted on a single line. This technically should not be part of the interface, but it's easier with the current infrastructure
        /// </summary>
        public bool ForceSingleLine { get; }

        partial void VerifyInputs(ImmutableArray<ITsTypeMember> typeMembers, bool forceSingleLine);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsObjectType(TypeMembers, ForceSingleLine, leadingTrivia, trailingTrivia);
    }

    public static class ObjectTypeExtensions
    {
        public static ITsObjectType WithTypeMembers(this ITsObjectType node, ImmutableArray<ITsTypeMember> value) =>
            node.TypeMembers == value ? node : new TsObjectType(value, node.ForceSingleLine, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsObjectType WithForceSingleLine(this ITsObjectType node, bool value) =>
            node.ForceSingleLine == value ? node : new TsObjectType(node.TypeMembers, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ParenthesizedType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a parenthesized type, of the form '(Type)'.
    /// </summary>
    public interface ITsParenthesizedType : ITsType
    {
        ITsType Type { get; }
    }

    /// <summary>
    /// Represents a parenthesized type, of the form '(Type)'.
    /// </summary>
    internal partial class TsParenthesizedType : TsAstNode, ITsParenthesizedType
    {
        public TsParenthesizedType(
            ITsType type,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(type);
            Type = type;
        }

        public ITsType Type { get; }

        partial void VerifyInputs(ITsType type);
        public override void Accept(TsVisitor visitor) => visitor.VisitParenthesizedType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitParenthesizedType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsParenthesizedType(Type, leadingTrivia, trailingTrivia);
    }

    public static class ParenthesizedTypeExtensions
    {
        public static ITsParenthesizedType WithType(this ITsParenthesizedType node, ITsType value) =>
            node.Type == value ? node : new TsParenthesizedType(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PredefinedType
    //// ===============================================================================================================

    public enum TsPredefinedKind
    {
        Any,
        Number,
        Boolean,
        String,
        Symbol,
        Void,
        Null,
        Undefined,
    }

    /// <summary>
    /// Represents one of the predefined types: any, number, boolean, string, symbol, void.
    /// </summary>
    public interface ITsPredefinedType : ITsType
    {
        TsPredefinedKind Kind { get; }
    }

    /// <summary>
    /// Represents one of the predefined types: any, number, boolean, string, symbol, void.
    /// </summary>
    internal partial class TsPredefinedType : TsAstNode, ITsPredefinedType
    {
        public TsPredefinedType(
            TsPredefinedKind kind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(kind);
            Kind = kind;
        }

        public TsPredefinedKind Kind { get; }

        partial void VerifyInputs(TsPredefinedKind kind);
        public override void Accept(TsVisitor visitor) => visitor.VisitPredefinedType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPredefinedType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsPredefinedType(Kind, leadingTrivia, trailingTrivia);
    }

    public static class PredefinedTypeExtensions
    {
        public static ITsPredefinedType WithKind(this ITsPredefinedType node, TsPredefinedKind value) =>
            node.Kind == value ? node : new TsPredefinedType(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertySignature
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property signature.
    /// </summary>
    public interface ITsPropertySignature : ITsTypeMember
    {
        ITsPropertyName PropertyName { get; }
        bool IsReadOnly { get; }
        bool IsOptional { get; }
        ITsType? PropertyType { get; }
    }

    /// <summary>
    /// Represents a property signature.
    /// </summary>
    internal partial class TsPropertySignature : TsAstNode, ITsPropertySignature
    {
        public TsPropertySignature(
            ITsPropertyName propertyName,
            bool isReadOnly,
            bool isOptional,
            ITsType? propertyType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, isReadOnly, isOptional, propertyType);
            PropertyName = propertyName;
            IsReadOnly = isReadOnly;
            IsOptional = isOptional;
            PropertyType = propertyType;
        }

        public ITsPropertyName PropertyName { get; }
        public bool IsReadOnly { get; }
        public bool IsOptional { get; }
        public ITsType? PropertyType { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, bool isReadOnly, bool isOptional, ITsType? propertyType);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertySignature(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertySignature(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsPropertySignature(PropertyName, IsReadOnly, IsOptional, PropertyType, leadingTrivia, trailingTrivia);
    }

    public static class PropertySignatureExtensions
    {
        public static ITsPropertySignature WithPropertyName(this ITsPropertySignature node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertySignature(value, node.IsReadOnly, node.IsOptional, node.PropertyType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertySignature WithIsReadOnly(this ITsPropertySignature node, bool value) =>
            node.IsReadOnly == value ? node : new TsPropertySignature(node.PropertyName, value, node.IsOptional, node.PropertyType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertySignature WithIsOptional(this ITsPropertySignature node, bool value) =>
            node.IsOptional == value ? node : new TsPropertySignature(node.PropertyName, node.IsReadOnly, value, node.PropertyType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertySignature WithPropertyType(this ITsPropertySignature node, ITsType? value) =>
            node.PropertyType == value ? node : new TsPropertySignature(node.PropertyName, node.IsReadOnly, node.IsOptional, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ThisType
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'this' type.
    /// </summary>
    public interface ITsThisType : ITsType
    {
    }

    /// <summary>
    /// Represents the 'this' type.
    /// </summary>
    internal partial class TsThisType : TsAstNode, ITsThisType
    {
        public TsThisType(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitThisType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitThisType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsThisType(leadingTrivia, trailingTrivia);
    }

    //// ===============================================================================================================
    //// TupleType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript tuple type.
    /// </summary>
    public interface ITsTupleType : ITsType
    {
        ImmutableArray<ITsType> ElementTypes { get; }
    }

    /// <summary>
    /// Represents a TypeScript tuple type.
    /// </summary>
    internal partial class TsTupleType : TsAstNode, ITsTupleType
    {
        public TsTupleType(
            ImmutableArray<ITsType> elementTypes,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elementTypes);
            ElementTypes = elementTypes;
        }

        public ImmutableArray<ITsType> ElementTypes { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> elementTypes);
        public override void Accept(TsVisitor visitor) => visitor.VisitTupleType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTupleType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsTupleType(ElementTypes, leadingTrivia, trailingTrivia);
    }

    public static class TupleTypeExtensions
    {
        public static ITsTupleType WithElementTypes(this ITsTupleType node, ImmutableArray<ITsType> value) =>
            node.ElementTypes == value ? node : new TsTupleType(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeQuery
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'typeof' query.
    /// </summary>
    public interface ITsTypeQuery : ITsType
    {
        ITsTypeName Query { get; }
    }

    /// <summary>
    /// Represents a 'typeof' query.
    /// </summary>
    internal partial class TsTypeQuery : TsAstNode, ITsTypeQuery
    {
        public TsTypeQuery(
            ITsTypeName query,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(query);
            Query = query;
        }

        public ITsTypeName Query { get; }

        partial void VerifyInputs(ITsTypeName query);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeQuery(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeQuery(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsTypeQuery(Query, leadingTrivia, trailingTrivia);
    }

    public static class TypeQueryExtensions
    {
        public static ITsTypeQuery WithQuery(this ITsTypeQuery node, ITsTypeName value) =>
            node.Query == value ? node : new TsTypeQuery(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeReference
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript type reference.
    /// </summary>
    public interface ITsTypeReference : ITsType
    {
        ITsTypeName TypeName { get; }
        ImmutableArray<ITsType> TypeArguments { get; }
    }

    /// <summary>
    /// Represents a TypeScript type reference.
    /// </summary>
    internal partial class TsTypeReference : TsAstNode, ITsTypeReference
    {
        public TsTypeReference(
            ITsTypeName typeName,
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeName, typeArguments);
            TypeName = typeName;
            TypeArguments = typeArguments;
        }

        public ITsTypeName TypeName { get; }
        public ImmutableArray<ITsType> TypeArguments { get; }

        partial void VerifyInputs(ITsTypeName typeName, ImmutableArray<ITsType> typeArguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeReference(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeReference(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsTypeReference(TypeName, TypeArguments, leadingTrivia, trailingTrivia);
    }

    public static class TypeReferenceExtensions
    {
        public static ITsTypeReference WithTypeName(this ITsTypeReference node, ITsTypeName value) =>
            node.TypeName == value ? node : new TsTypeReference(value, node.TypeArguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTypeReference WithTypeArguments(this ITsTypeReference node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsTypeReference(node.TypeName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// UnionType
    //// ===============================================================================================================

    /// <summary>
    /// Represents a union type of the form 'type1 | type2'.
    /// </summary>
    public interface ITsUnionType : ITsType
    {
        ImmutableArray<ITsType> Types { get; }
    }

    /// <summary>
    /// Represents a union type of the form 'type1 | type2'.
    /// </summary>
    internal partial class TsUnionType : TsAstNode, ITsUnionType
    {
        public TsUnionType(
            ImmutableArray<ITsType> types,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(types);
            Types = types;
        }

        public ImmutableArray<ITsType> Types { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> types);
        public override void Accept(TsVisitor visitor) => visitor.VisitUnionType(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitUnionType(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsUnionType(Types, leadingTrivia, trailingTrivia);
    }

    public static class UnionTypeExtensions
    {
        public static ITsUnionType WithTypes(this ITsUnionType node, ImmutableArray<ITsType> value) =>
            node.Types == value ? node : new TsUnionType(value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
