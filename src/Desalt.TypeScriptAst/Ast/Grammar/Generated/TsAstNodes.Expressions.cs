// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Expressions.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Expression
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all expressions.
    /// </summary>
    public interface ITsExpression : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ArrayLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array literal of the form '[element...]'.
    /// </summary>
    public interface ITsArrayLiteral : ITsExpression
    {
        ImmutableArray<ITsArrayElement?> Elements { get; }
    }

    /// <summary>
    /// Represents an array literal of the form '[element...]'.
    /// </summary>
    internal partial class TsArrayLiteral : TsAstNode, ITsArrayLiteral
    {
        public TsArrayLiteral(
            ImmutableArray<ITsArrayElement?> elements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements);
            Elements = elements;
        }

        public ImmutableArray<ITsArrayElement?> Elements { get; }

        partial void VerifyInputs(ImmutableArray<ITsArrayElement?> elements);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayLiteral(emitter, this);
    }

    public static class ArrayLiteralExtensions
    {
        public static ITsArrayLiteral WithElements(this ITsArrayLiteral node, ImmutableArray<ITsArrayElement?> value) =>
            node.Elements == value ? node : new TsArrayLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrowFunction
    //// ===============================================================================================================

    /// <summary>
    /// Represents an arrow function expression of the form '() => body'.
    /// </summary>
    public interface ITsArrowFunction : ITsExpression
    {
        ITsIdentifier? SingleParameterName { get; }
        ITsCallSignature? CallSignature { get; }
        ITsExpression? BodyExpression { get; }
        ImmutableArray<ITsStatementListItem> Body { get; }
    }

    /// <summary>
    /// Represents an arrow function expression of the form '() => body'.
    /// </summary>
    internal partial class TsArrowFunction : TsAstNode, ITsArrowFunction
    {
        public TsArrowFunction(
            ITsIdentifier? singleParameterName,
            ITsCallSignature? callSignature,
            ITsExpression? bodyExpression,
            ImmutableArray<ITsStatementListItem> body,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(singleParameterName, callSignature, bodyExpression, body);
            SingleParameterName = singleParameterName;
            CallSignature = callSignature;
            BodyExpression = bodyExpression;
            Body = body;
        }

        public ITsIdentifier? SingleParameterName { get; }
        public ITsCallSignature? CallSignature { get; }
        public ITsExpression? BodyExpression { get; }
        public ImmutableArray<ITsStatementListItem> Body { get; }

        partial void VerifyInputs(ITsIdentifier? singleParameterName, ITsCallSignature? callSignature, ITsExpression? bodyExpression, ImmutableArray<ITsStatementListItem> body);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrowFunction(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrowFunction(emitter, this);
    }

    public static class ArrowFunctionExtensions
    {
        public static ITsArrowFunction WithSingleParameterName(this ITsArrowFunction node, ITsIdentifier? value) =>
            node.SingleParameterName == value ? node : new TsArrowFunction(value, node.CallSignature, node.BodyExpression, node.Body, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrowFunction WithCallSignature(this ITsArrowFunction node, ITsCallSignature? value) =>
            node.CallSignature == value ? node : new TsArrowFunction(node.SingleParameterName, value, node.BodyExpression, node.Body, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrowFunction WithBodyExpression(this ITsArrowFunction node, ITsExpression? value) =>
            node.BodyExpression == value ? node : new TsArrowFunction(node.SingleParameterName, node.CallSignature, value, node.Body, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrowFunction WithBody(this ITsArrowFunction node, ImmutableArray<ITsStatementListItem> value) =>
            node.Body == value ? node : new TsArrowFunction(node.SingleParameterName, node.CallSignature, node.BodyExpression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// AssignmentExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an assignment of the form 'left == right'.
    /// </summary>
    public interface ITsAssignmentExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        TsAssignmentOperator Operator { get; }
        ITsExpression RightSide { get; }
    }

    /// <summary>
    /// Represents an assignment of the form 'left == right'.
    /// </summary>
    internal partial class TsAssignmentExpression : TsAstNode, ITsAssignmentExpression
    {
        public TsAssignmentExpression(
            ITsExpression leftSide,
            TsAssignmentOperator @operator,
            ITsExpression rightSide,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, @operator, rightSide);
            LeftSide = leftSide;
            Operator = @operator;
            RightSide = rightSide;
        }

        public ITsExpression LeftSide { get; }
        public TsAssignmentOperator Operator { get; }
        public ITsExpression RightSide { get; }

        partial void VerifyInputs(ITsExpression leftSide, TsAssignmentOperator @operator, ITsExpression rightSide);
        public override void Accept(TsVisitor visitor) => visitor.VisitAssignmentExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitAssignmentExpression(emitter, this);
    }

    public static class AssignmentExpressionExtensions
    {
        public static ITsAssignmentExpression WithLeftSide(this ITsAssignmentExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsAssignmentExpression(value, node.Operator, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAssignmentExpression WithOperator(this ITsAssignmentExpression node, TsAssignmentOperator value) =>
            node.Operator == value ? node : new TsAssignmentExpression(node.LeftSide, value, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAssignmentExpression WithRightSide(this ITsAssignmentExpression node, ITsExpression value) =>
            node.RightSide == value ? node : new TsAssignmentExpression(node.LeftSide, node.Operator, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BinaryExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a binary expression.
    /// </summary>
    public interface ITsBinaryExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        TsBinaryOperator Operator { get; }
        ITsExpression RightSide { get; }
    }

    /// <summary>
    /// Represents a binary expression.
    /// </summary>
    internal partial class TsBinaryExpression : TsAstNode, ITsBinaryExpression
    {
        public TsBinaryExpression(
            ITsExpression leftSide,
            TsBinaryOperator @operator,
            ITsExpression rightSide,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, @operator, rightSide);
            LeftSide = leftSide;
            Operator = @operator;
            RightSide = rightSide;
        }

        public ITsExpression LeftSide { get; }
        public TsBinaryOperator Operator { get; }
        public ITsExpression RightSide { get; }

        partial void VerifyInputs(ITsExpression leftSide, TsBinaryOperator @operator, ITsExpression rightSide);
        public override void Accept(TsVisitor visitor) => visitor.VisitBinaryExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBinaryExpression(emitter, this);
    }

    public static class BinaryExpressionExtensions
    {
        public static ITsBinaryExpression WithLeftSide(this ITsBinaryExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsBinaryExpression(value, node.Operator, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBinaryExpression WithOperator(this ITsBinaryExpression node, TsBinaryOperator value) =>
            node.Operator == value ? node : new TsBinaryExpression(node.LeftSide, value, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBinaryExpression WithRightSide(this ITsBinaryExpression node, ITsExpression value) =>
            node.RightSide == value ? node : new TsBinaryExpression(node.LeftSide, node.Operator, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BooleanLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a boolean literal expression (either 'true' or 'false').
    /// </summary>
    public interface ITsBooleanLiteral : ITsExpression
    {
        bool Value { get; }
    }

    /// <summary>
    /// Represents a boolean literal expression (either 'true' or 'false').
    /// </summary>
    internal partial class TsBooleanLiteral : TsAstNode, ITsBooleanLiteral
    {
        public TsBooleanLiteral(
            bool value,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value);
            Value = value;
        }

        public bool Value { get; }

        partial void VerifyInputs(bool value);
        public override void Accept(TsVisitor visitor) => visitor.VisitBooleanLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBooleanLiteral(emitter, this);
    }

    public static class BooleanLiteralExtensions
    {
        public static ITsBooleanLiteral WithValue(this ITsBooleanLiteral node, bool value) =>
            node.Value == value ? node : new TsBooleanLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'expression(arguments)'.
    /// </summary>
    public interface ITsCallExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'expression(arguments)'.
    /// </summary>
    internal partial class TsCallExpression : TsAstNode, ITsCallExpression
    {
        public TsCallExpression(
            ITsExpression leftSide,
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, argumentList);
            LeftSide = leftSide;
            ArgumentList = argumentList;
        }

        public ITsExpression LeftSide { get; }
        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCallExpression(emitter, this);
    }

    public static class CallExpressionExtensions
    {
        public static ITsCallExpression WithLeftSide(this ITsCallExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsCallExpression(value, node.ArgumentList, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCallExpression WithArgumentList(this ITsCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsCallExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CastExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a unary cast expression of the form, '&lt;Type&gt;expression'.
    /// </summary>
    public interface ITsCastExpression : ITsExpression
    {
        ITsType CastType { get; }
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a unary cast expression of the form, '&lt;Type&gt;expression'.
    /// </summary>
    internal partial class TsCastExpression : TsAstNode, ITsCastExpression
    {
        public TsCastExpression(
            ITsType castType,
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(castType, expression);
            CastType = castType;
            Expression = expression;
        }

        public ITsType CastType { get; }
        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsType castType, ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitCastExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCastExpression(emitter, this);
    }

    public static class CastExpressionExtensions
    {
        public static ITsCastExpression WithCastType(this ITsCastExpression node, ITsType value) =>
            node.CastType == value ? node : new TsCastExpression(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCastExpression WithExpression(this ITsCastExpression node, ITsExpression value) =>
            node.Expression == value ? node : new TsCastExpression(node.CastType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ClassExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a class declaration acting as an expression.
    /// </summary>
    public interface ITsClassExpression : ITsExpression
    {
        ITsIdentifier? ClassName { get; }
        ITsClassHeritage? Heritage { get; }
        ImmutableArray<ITsClassElement> ClassBody { get; }
    }

    /// <summary>
    /// Represents a class declaration acting as an expression.
    /// </summary>
    internal partial class TsClassExpression : TsAstNode, ITsClassExpression
    {
        public TsClassExpression(
            ITsIdentifier? className,
            ITsClassHeritage? heritage,
            ImmutableArray<ITsClassElement> classBody,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(className, heritage, classBody);
            ClassName = className;
            Heritage = heritage;
            ClassBody = classBody;
        }

        public ITsIdentifier? ClassName { get; }
        public ITsClassHeritage? Heritage { get; }
        public ImmutableArray<ITsClassElement> ClassBody { get; }

        partial void VerifyInputs(ITsIdentifier? className, ITsClassHeritage? heritage, ImmutableArray<ITsClassElement> classBody);
        public override void Accept(TsVisitor visitor) => visitor.VisitClassExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitClassExpression(emitter, this);
    }

    public static class ClassExpressionExtensions
    {
        public static ITsClassExpression WithClassName(this ITsClassExpression node, ITsIdentifier? value) =>
            node.ClassName == value ? node : new TsClassExpression(value, node.Heritage, node.ClassBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsClassExpression WithHeritage(this ITsClassExpression node, ITsClassHeritage? value) =>
            node.Heritage == value ? node : new TsClassExpression(node.ClassName, value, node.ClassBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsClassExpression WithClassBody(this ITsClassExpression node, ImmutableArray<ITsClassElement> value) =>
            node.ClassBody == value ? node : new TsClassExpression(node.ClassName, node.Heritage, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CommaExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression list separated by commas. Useful in for loops for the initializer or incrementor, for example.
    /// </summary>
    public interface ITsCommaExpression : ITsExpression
    {
        ImmutableArray<ITsExpression> Expressions { get; }
    }

    /// <summary>
    /// Represents an expression list separated by commas. Useful in for loops for the initializer or incrementor, for example.
    /// </summary>
    internal partial class TsCommaExpression : TsAstNode, ITsCommaExpression
    {
        public TsCommaExpression(
            ImmutableArray<ITsExpression> expressions,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expressions);
            Expressions = expressions;
        }

        public ImmutableArray<ITsExpression> Expressions { get; }

        partial void VerifyInputs(ImmutableArray<ITsExpression> expressions);
        public override void Accept(TsVisitor visitor) => visitor.VisitCommaExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCommaExpression(emitter, this);
    }

    public static class CommaExpressionExtensions
    {
        public static ITsCommaExpression WithExpressions(this ITsCommaExpression node, ImmutableArray<ITsExpression> value) =>
            node.Expressions == value ? node : new TsCommaExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ConditionalExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a conditional expression of the form 'x ? y : z'.
    /// </summary>
    public interface ITsConditionalExpression : ITsExpression
    {
        ITsExpression Condition { get; }
        ITsExpression WhenTrue { get; }
        ITsExpression WhenFalse { get; }
    }

    /// <summary>
    /// Represents a conditional expression of the form 'x ? y : z'.
    /// </summary>
    internal partial class TsConditionalExpression : TsAstNode, ITsConditionalExpression
    {
        public TsConditionalExpression(
            ITsExpression condition,
            ITsExpression whenTrue,
            ITsExpression whenFalse,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(condition, whenTrue, whenFalse);
            Condition = condition;
            WhenTrue = whenTrue;
            WhenFalse = whenFalse;
        }

        public ITsExpression Condition { get; }
        public ITsExpression WhenTrue { get; }
        public ITsExpression WhenFalse { get; }

        partial void VerifyInputs(ITsExpression condition, ITsExpression whenTrue, ITsExpression whenFalse);
        public override void Accept(TsVisitor visitor) => visitor.VisitConditionalExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitConditionalExpression(emitter, this);
    }

    public static class ConditionalExpressionExtensions
    {
        public static ITsConditionalExpression WithCondition(this ITsConditionalExpression node, ITsExpression value) =>
            node.Condition == value ? node : new TsConditionalExpression(value, node.WhenTrue, node.WhenFalse, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConditionalExpression WithWhenTrue(this ITsConditionalExpression node, ITsExpression value) =>
            node.WhenTrue == value ? node : new TsConditionalExpression(node.Condition, value, node.WhenFalse, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConditionalExpression WithWhenFalse(this ITsConditionalExpression node, ITsExpression value) =>
            node.WhenFalse == value ? node : new TsConditionalExpression(node.Condition, node.WhenTrue, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MemberBracketExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'expression[expression]'.
    /// </summary>
    public interface ITsMemberBracketExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsExpression BracketContents { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'expression[expression]'.
    /// </summary>
    internal partial class TsMemberBracketExpression : TsAstNode, ITsMemberBracketExpression
    {
        public TsMemberBracketExpression(
            ITsExpression leftSide,
            ITsExpression bracketContents,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, bracketContents);
            LeftSide = leftSide;
            BracketContents = bracketContents;
        }

        public ITsExpression LeftSide { get; }
        public ITsExpression BracketContents { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsExpression bracketContents);
        public override void Accept(TsVisitor visitor) => visitor.VisitMemberBracketExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberBracketExpression(emitter, this);
    }

    public static class MemberBracketExpressionExtensions
    {
        public static ITsMemberBracketExpression WithLeftSide(this ITsMemberBracketExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsMemberBracketExpression(value, node.BracketContents, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMemberBracketExpression WithBracketContents(this ITsMemberBracketExpression node, ITsExpression value) =>
            node.BracketContents == value ? node : new TsMemberBracketExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MemberDotExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'expression.name'.
    /// </summary>
    public interface ITsMemberDotExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        string DotName { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'expression.name'.
    /// </summary>
    internal partial class TsMemberDotExpression : TsAstNode, ITsMemberDotExpression
    {
        public TsMemberDotExpression(
            ITsExpression leftSide,
            string dotName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, dotName);
            LeftSide = leftSide;
            DotName = dotName;
        }

        public ITsExpression LeftSide { get; }
        public string DotName { get; }

        partial void VerifyInputs(ITsExpression leftSide, string dotName);
        public override void Accept(TsVisitor visitor) => visitor.VisitMemberDotExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberDotExpression(emitter, this);
    }

    public static class MemberDotExpressionExtensions
    {
        public static ITsMemberDotExpression WithLeftSide(this ITsMemberDotExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsMemberDotExpression(value, node.DotName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMemberDotExpression WithDotName(this ITsMemberDotExpression node, string value) =>
            node.DotName == value ? node : new TsMemberDotExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NewCallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'new expression(arguments)'.
    /// </summary>
    public interface ITsNewCallExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'new expression(arguments)'.
    /// </summary>
    internal partial class TsNewCallExpression : TsAstNode, ITsNewCallExpression
    {
        public TsNewCallExpression(
            ITsExpression leftSide,
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, argumentList);
            LeftSide = leftSide;
            ArgumentList = argumentList;
        }

        public ITsExpression LeftSide { get; }
        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitNewCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNewCallExpression(emitter, this);
    }

    public static class NewCallExpressionExtensions
    {
        public static ITsNewCallExpression WithLeftSide(this ITsNewCallExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsNewCallExpression(value, node.ArgumentList, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsNewCallExpression WithArgumentList(this ITsNewCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsNewCallExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NewTargetExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression of the form 'new.target'.
    /// </summary>
    public interface ITsNewTargetExpression : ITsExpression
    {
    }

    /// <summary>
    /// Represents an expression of the form 'new.target'.
    /// </summary>
    internal partial class TsNewTargetExpression : TsAstNode, ITsNewTargetExpression
    {
        public TsNewTargetExpression(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitNewTargetExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNewTargetExpression(emitter, this);
    }

    //// ===============================================================================================================
    //// NullLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'null' literal expression.
    /// </summary>
    public interface ITsNullLiteral : ITsExpression
    {
    }

    /// <summary>
    /// Represents the 'null' literal expression.
    /// </summary>
    internal partial class TsNullLiteral : TsAstNode, ITsNullLiteral
    {
        public TsNullLiteral(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitNullLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNullLiteral(emitter, this);
    }

    //// ===============================================================================================================
    //// NumericLiteral
    //// ===============================================================================================================

    public enum TsNumericLiteralKind
    {
        Decimal,
        BinaryInteger,
        OctalInteger,
        HexInteger,
    }

    /// <summary>
    /// Represents an expression containing a numeric literal value.
    /// </summary>
    public interface ITsNumericLiteral : ITsExpression, ITsLiteralPropertyName
    {
        double Value { get; }
        TsNumericLiteralKind Kind { get; }
    }

    /// <summary>
    /// Represents an expression containing a numeric literal value.
    /// </summary>
    internal partial class TsNumericLiteral : TsAstNode, ITsNumericLiteral
    {
        public TsNumericLiteral(
            double value,
            TsNumericLiteralKind kind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value, kind);
            Value = value;
            Kind = kind;
        }

        public double Value { get; }
        public TsNumericLiteralKind Kind { get; }

        partial void VerifyInputs(double value, TsNumericLiteralKind kind);
        public override void Accept(TsVisitor visitor) => visitor.VisitNumericLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNumericLiteral(emitter, this);
    }

    public static class NumericLiteralExtensions
    {
        public static ITsNumericLiteral WithValue(this ITsNumericLiteral node, double value) =>
            node.Value == value ? node : new TsNumericLiteral(value, node.Kind, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsNumericLiteral WithKind(this ITsNumericLiteral node, TsNumericLiteralKind value) =>
            node.Kind == value ? node : new TsNumericLiteral(node.Value, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ObjectLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents on object literal of the form '{ PropertyDefinition... }'.
    /// </summary>
    public interface ITsObjectLiteral : ITsExpression
    {
        ImmutableArray<ITsPropertyDefinition> PropertyDefinitions { get; }
    }

    /// <summary>
    /// Represents on object literal of the form '{ PropertyDefinition... }'.
    /// </summary>
    internal partial class TsObjectLiteral : TsAstNode, ITsObjectLiteral
    {
        public TsObjectLiteral(
            ImmutableArray<ITsPropertyDefinition> propertyDefinitions,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyDefinitions);
            PropertyDefinitions = propertyDefinitions;
        }

        public ImmutableArray<ITsPropertyDefinition> PropertyDefinitions { get; }

        partial void VerifyInputs(ImmutableArray<ITsPropertyDefinition> propertyDefinitions);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectLiteral(emitter, this);
    }

    public static class ObjectLiteralExtensions
    {
        public static ITsObjectLiteral WithPropertyDefinitions(this ITsObjectLiteral node, ImmutableArray<ITsPropertyDefinition> value) =>
            node.PropertyDefinitions == value ? node : new TsObjectLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ParenthesizedExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a parenthesized expression, of the form '(expression)'.
    /// </summary>
    public interface ITsParenthesizedExpression : ITsExpression
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a parenthesized expression, of the form '(expression)'.
    /// </summary>
    internal partial class TsParenthesizedExpression : TsAstNode, ITsParenthesizedExpression
    {
        public TsParenthesizedExpression(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitParenthesizedExpression(emitter, this);
    }

    public static class ParenthesizedExpressionExtensions
    {
        public static ITsParenthesizedExpression WithExpression(this ITsParenthesizedExpression node, ITsExpression value) =>
            node.Expression == value ? node : new TsParenthesizedExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyDefinition
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property definition within an object literal.
    /// </summary>
    public interface ITsPropertyDefinition : ITsExpression
    {
    }

    //// ===============================================================================================================
    //// RegularExpressionLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a regular expression literal of the form '/body/flags'.
    /// </summary>
    public interface ITsRegularExpressionLiteral : ITsExpression
    {
        string Body { get; }
        string? Flags { get; }
    }

    /// <summary>
    /// Represents a regular expression literal of the form '/body/flags'.
    /// </summary>
    internal partial class TsRegularExpressionLiteral : TsAstNode, ITsRegularExpressionLiteral
    {
        public TsRegularExpressionLiteral(
            string body,
            string? flags,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(body, flags);
            Body = body;
            Flags = flags;
        }

        public string Body { get; }
        public string? Flags { get; }

        partial void VerifyInputs(string body, string? flags);
        public override void Accept(TsVisitor visitor) => visitor.VisitRegularExpressionLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitRegularExpressionLiteral(emitter, this);
    }

    public static class RegularExpressionLiteralExtensions
    {
        public static ITsRegularExpressionLiteral WithBody(this ITsRegularExpressionLiteral node, string value) =>
            node.Body == value ? node : new TsRegularExpressionLiteral(value, node.Flags, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsRegularExpressionLiteral WithFlags(this ITsRegularExpressionLiteral node, string? value) =>
            node.Flags == value ? node : new TsRegularExpressionLiteral(node.Body, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StringLiteral
    //// ===============================================================================================================

    public enum StringLiteralQuoteKind
    {
        DoubleQuote,
        SingleQuote,
    }

    /// <summary>
    /// Represents a string literal of the form 'string' or "string".
    /// </summary>
    public interface ITsStringLiteral : ITsExpression, ITsLiteralPropertyName
    {
        string Value { get; }
        StringLiteralQuoteKind QuoteKind { get; }
    }

    /// <summary>
    /// Represents a string literal of the form 'string' or "string".
    /// </summary>
    internal partial class TsStringLiteral : TsAstNode, ITsStringLiteral
    {
        public TsStringLiteral(
            string value,
            StringLiteralQuoteKind quoteKind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value, quoteKind);
            Value = value;
            QuoteKind = quoteKind;
        }

        public string Value { get; }
        public StringLiteralQuoteKind QuoteKind { get; }

        partial void VerifyInputs(string value, StringLiteralQuoteKind quoteKind);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringLiteral(emitter, this);
    }

    public static class StringLiteralExtensions
    {
        public static ITsStringLiteral WithValue(this ITsStringLiteral node, string value) =>
            node.Value == value ? node : new TsStringLiteral(value, node.QuoteKind, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringLiteral WithQuoteKind(this ITsStringLiteral node, StringLiteralQuoteKind value) =>
            node.QuoteKind == value ? node : new TsStringLiteral(node.Value, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperBracketExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'super[expression]'.
    /// </summary>
    public interface ITsSuperBracketExpression : ITsExpression
    {
        ITsExpression BracketContents { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'super[expression]'.
    /// </summary>
    internal partial class TsSuperBracketExpression : TsAstNode, ITsSuperBracketExpression
    {
        public TsSuperBracketExpression(
            ITsExpression bracketContents,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bracketContents);
            BracketContents = bracketContents;
        }

        public ITsExpression BracketContents { get; }

        partial void VerifyInputs(ITsExpression bracketContents);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperBracketExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperBracketExpression(emitter, this);
    }

    public static class SuperBracketExpressionExtensions
    {
        public static ITsSuperBracketExpression WithBracketContents(this ITsSuperBracketExpression node, ITsExpression value) =>
            node.BracketContents == value ? node : new TsSuperBracketExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperCallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'super(arguments)'.
    /// </summary>
    public interface ITsSuperCallExpression : ITsExpression
    {
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'super(arguments)'.
    /// </summary>
    internal partial class TsSuperCallExpression : TsAstNode, ITsSuperCallExpression
    {
        public TsSuperCallExpression(
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(argumentList);
            ArgumentList = argumentList;
        }

        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperCallExpression(emitter, this);
    }

    public static class SuperCallExpressionExtensions
    {
        public static ITsSuperCallExpression WithArgumentList(this ITsSuperCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsSuperCallExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperDotExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'super.name'.
    /// </summary>
    public interface ITsSuperDotExpression : ITsExpression
    {
        string DotName { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'super.name'.
    /// </summary>
    internal partial class TsSuperDotExpression : TsAstNode, ITsSuperDotExpression
    {
        public TsSuperDotExpression(
            string dotName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(dotName);
            DotName = dotName;
        }

        public string DotName { get; }

        partial void VerifyInputs(string dotName);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperDotExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperDotExpression(emitter, this);
    }

    public static class SuperDotExpressionExtensions
    {
        public static ITsSuperDotExpression WithDotName(this ITsSuperDotExpression node, string value) =>
            node.DotName == value ? node : new TsSuperDotExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplateLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a template string literal.
    /// </summary>
    public interface ITsTemplateLiteral : ITsExpression
    {
        ImmutableArray<ITsTemplatePart> Parts { get; }
    }

    /// <summary>
    /// Represents a template string literal.
    /// </summary>
    internal partial class TsTemplateLiteral : TsAstNode, ITsTemplateLiteral
    {
        public TsTemplateLiteral(
            ImmutableArray<ITsTemplatePart> parts,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parts);
            Parts = parts;
        }

        public ImmutableArray<ITsTemplatePart> Parts { get; }

        partial void VerifyInputs(ImmutableArray<ITsTemplatePart> parts);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplateLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplateLiteral(emitter, this);
    }

    public static class TemplateLiteralExtensions
    {
        public static ITsTemplateLiteral WithParts(this ITsTemplateLiteral node, ImmutableArray<ITsTemplatePart> value) =>
            node.Parts == value ? node : new TsTemplateLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// This
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'this' expression.
    /// </summary>
    public interface ITsThis : ITsExpression
    {
    }

    /// <summary>
    /// Represents the 'this' expression.
    /// </summary>
    internal partial class TsThis : TsAstNode, ITsThis
    {
        public TsThis(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitThis(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitThis(emitter, this);
    }

    //// ===============================================================================================================
    //// TypeName
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for valid TypeScript type names.
    /// </summary>
    public interface ITsTypeName : ITsExpression
    {
    }

    //// ===============================================================================================================
    //// UnaryExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a unary expression.
    /// </summary>
    public interface ITsUnaryExpression : ITsExpression
    {
        ITsExpression Operand { get; }
        TsUnaryOperator Operator { get; }
    }

    /// <summary>
    /// Represents a unary expression.
    /// </summary>
    internal partial class TsUnaryExpression : TsAstNode, ITsUnaryExpression
    {
        public TsUnaryExpression(
            ITsExpression operand,
            TsUnaryOperator @operator,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(operand, @operator);
            Operand = operand;
            Operator = @operator;
        }

        public ITsExpression Operand { get; }
        public TsUnaryOperator Operator { get; }

        partial void VerifyInputs(ITsExpression operand, TsUnaryOperator @operator);
        public override void Accept(TsVisitor visitor) => visitor.VisitUnaryExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitUnaryExpression(emitter, this);
    }

    public static class UnaryExpressionExtensions
    {
        public static ITsUnaryExpression WithOperand(this ITsUnaryExpression node, ITsExpression value) =>
            node.Operand == value ? node : new TsUnaryExpression(value, node.Operator, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsUnaryExpression WithOperator(this ITsUnaryExpression node, TsUnaryOperator value) =>
            node.Operator == value ? node : new TsUnaryExpression(node.Operand, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
