
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Others.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Argument
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    public interface ITsArgument : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadArgument { get; }
    }

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    internal partial class TsArgument : TsAstNode, ITsArgument
    {
        public TsArgument(
            ITsExpression expression,
            bool isSpreadArgument,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadArgument);
            Expression = expression;
            IsSpreadArgument = isSpreadArgument;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadArgument { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadArgument);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgument(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgument(emitter, this);
    }

    public static class ArgumentExtensions
    {
        public static ITsArgument WithExpression(this ITsArgument node, ITsExpression value) =>
            node.Expression == value ? node : new TsArgument(value, node.IsSpreadArgument, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgument WithIsSpreadArgument(this ITsArgument node, bool value) =>
            node.IsSpreadArgument == value ? node : new TsArgument(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArgumentList
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    public interface ITsArgumentList : ITsAstNode
    {
        ImmutableArray<ITsType> TypeArguments { get; }
        ImmutableArray<ITsArgument> Arguments { get; }
    }

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    internal partial class TsArgumentList : TsAstNode, ITsArgumentList
    {
        public TsArgumentList(
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsArgument> arguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeArguments, arguments);
            TypeArguments = typeArguments;
            Arguments = arguments;
        }

        public ImmutableArray<ITsType> TypeArguments { get; }
        public ImmutableArray<ITsArgument> Arguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> typeArguments, ImmutableArray<ITsArgument> arguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgumentList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgumentList(emitter, this);
    }

    public static class ArgumentListExtensions
    {
        public static ITsArgumentList WithTypeArguments(this ITsArgumentList node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsArgumentList(value, node.Arguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgumentList WithArguments(this ITsArgumentList node, ImmutableArray<ITsArgument> value) =>
            node.Arguments == value ? node : new TsArgumentList(node.TypeArguments, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    public interface ITsArrayBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingElement?> Elements { get; }
        ITsIdentifier? RestElement { get; }
    }

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    internal partial class TsArrayBindingPattern : TsAstNode, ITsArrayBindingPattern
    {
        public TsArrayBindingPattern(
            ImmutableArray<ITsBindingElement?> elements,
            ITsIdentifier? restElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements, restElement);
            Elements = elements;
            RestElement = restElement;
        }

        public ImmutableArray<ITsBindingElement?> Elements { get; }
        public ITsIdentifier? RestElement { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingElement?> elements, ITsIdentifier? restElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayBindingPattern(emitter, this);
    }

    public static class ArrayBindingPatternExtensions
    {
        public static ITsArrayBindingPattern WithElements(this ITsArrayBindingPattern node, ImmutableArray<ITsBindingElement?> value) =>
            node.Elements == value ? node : new TsArrayBindingPattern(value, node.RestElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayBindingPattern WithRestElement(this ITsArrayBindingPattern node, ITsIdentifier? value) =>
            node.RestElement == value ? node : new TsArrayBindingPattern(node.Elements, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    public interface ITsArrayElement : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadElement { get; }
    }

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    internal partial class TsArrayElement : TsAstNode, ITsArrayElement
    {
        public TsArrayElement(
            ITsExpression expression,
            bool isSpreadElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadElement);
            Expression = expression;
            IsSpreadElement = isSpreadElement;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadElement { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayElement(emitter, this);
    }

    public static class ArrayElementExtensions
    {
        public static ITsArrayElement WithExpression(this ITsArrayElement node, ITsExpression value) =>
            node.Expression == value ? node : new TsArrayElement(value, node.IsSpreadElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayElement WithIsSpreadElement(this ITsArrayElement node, bool value) =>
            node.IsSpreadElement == value ? node : new TsArrayElement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingElement
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for binding elements in object and array bindings.
    /// </summary>
    public interface ITsBindingElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for a binding pattern.
    /// </summary>
    public interface ITsBindingPattern : ITsBindingIdentifierOrPattern
    {
    }

    //// ===============================================================================================================
    //// BindingProperty
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for properties that are bound in array or object initializers.
    /// </summary>
    public interface ITsBindingProperty : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// CaseClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    public interface ITsCaseClause : ITsCaseOrDefaultClause
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    internal partial class TsCaseClause : TsAstNode, ITsCaseClause
    {
        public TsCaseClause(
            ITsExpression expression,
            ImmutableArray<ITsStatementListItem>? statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, statements);
            Expression = expression;
            Statements = statements;
        }

        public ITsExpression Expression { get; }
        public ImmutableArray<ITsStatementListItem>? Statements { get; }

        partial void VerifyInputs(ITsExpression expression, ImmutableArray<ITsStatementListItem>? statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitCaseClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCaseClause(emitter, this);
    }

    public static class CaseClauseExtensions
    {
        public static ITsCaseClause WithExpression(this ITsCaseClause node, ITsExpression value) =>
            node.Expression == value ? node : new TsCaseClause(value, node.Statements, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCaseClause WithStatements(this ITsCaseClause node, ImmutableArray<ITsStatementListItem>? value) =>
            node.Statements == value ? node : new TsCaseClause(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CaseOrDefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents either a 'case' or 'default' clause within a 'switch' statement.
    /// </summary>
    public interface ITsCaseOrDefaultClause : ITsAstNode
    {
        ImmutableArray<ITsStatementListItem>? Statements { get; }
    }

    //// ===============================================================================================================
    //// ComputedPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    public interface ITsComputedPropertyName : ITsPropertyName
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    internal partial class TsComputedPropertyName : TsAstNode, ITsComputedPropertyName
    {
        public TsComputedPropertyName(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitComputedPropertyName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitComputedPropertyName(emitter, this);
    }

    public static class ComputedPropertyNameExtensions
    {
        public static ITsComputedPropertyName WithExpression(this ITsComputedPropertyName node, ITsExpression value) =>
            node.Expression == value ? node : new TsComputedPropertyName(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CoverInitializedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    public interface ITsCoverInitializedName : ITsPropertyDefinition
    {
        ITsIdentifier Identifier { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    internal partial class TsCoverInitializedName : TsAstNode, ITsCoverInitializedName
    {
        public TsCoverInitializedName(
            ITsIdentifier identifier,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(identifier, initializer);
            Identifier = identifier;
            Initializer = initializer;
        }

        public ITsIdentifier Identifier { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsIdentifier identifier, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitCoverInitializedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCoverInitializedName(emitter, this);
    }

    public static class CoverInitializedNameExtensions
    {
        public static ITsCoverInitializedName WithIdentifier(this ITsCoverInitializedName node, ITsIdentifier value) =>
            node.Identifier == value ? node : new TsCoverInitializedName(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCoverInitializedName WithInitializer(this ITsCoverInitializedName node, ITsExpression value) =>
            node.Initializer == value ? node : new TsCoverInitializedName(node.Identifier, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    public interface ITsDefaultClause : ITsCaseOrDefaultClause
    {
    }

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    internal partial class TsDefaultClause : TsAstNode, ITsDefaultClause
    {
        public TsDefaultClause(
            ImmutableArray<ITsStatementListItem>? statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem>? Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem>? statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitDefaultClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDefaultClause(emitter, this);
    }

    public static class DefaultClauseExtensions
    {
        public static ITsDefaultClause WithStatements(this ITsDefaultClause node, ImmutableArray<ITsStatementListItem>? value) =>
            node.Statements == value ? node : new TsDefaultClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// FromClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    public interface ITsFromClause : ITsAstNode
    {
        ITsStringLiteral Module { get; }
    }

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    internal partial class TsFromClause : TsAstNode, ITsFromClause
    {
        public TsFromClause(
            ITsStringLiteral module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(module);
            Module = module;
        }

        public ITsStringLiteral Module { get; }

        partial void VerifyInputs(ITsStringLiteral module);
        public override void Accept(TsVisitor visitor) => visitor.VisitFromClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitFromClause(emitter, this);
    }

    public static class FromClauseExtensions
    {
        public static ITsFromClause WithModule(this ITsFromClause node, ITsStringLiteral value) =>
            node.Module == value ? node : new TsFromClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Identifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    public interface ITsIdentifier : ITsTypeName, ITsPropertyDefinition, ITsLiteralPropertyName, ITsBindingIdentifierOrPattern
    {
        string Text { get; }
    }

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    internal partial class TsIdentifier : TsAstNode, ITsIdentifier
    {
        public TsIdentifier(
            string text,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(text);
            Text = text;
        }

        public string Text { get; }

        partial void VerifyInputs(string text);
        public override void Accept(TsVisitor visitor) => visitor.VisitIdentifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIdentifier(emitter, this);
    }

    public static class IdentifierExtensions
    {
        public static ITsIdentifier WithText(this ITsIdentifier node, string value) =>
            node.Text == value ? node : new TsIdentifier(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    public interface ITsImportClause : ITsAstNode
    {
        ITsIdentifier? DefaultBinding { get; }
        ITsIdentifier? NamespaceBinding { get; }
        ImmutableArray<ITsImportSpecifier>? NamedImports { get; }
    }

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    internal partial class TsImportClause : TsAstNode, ITsImportClause
    {
        public TsImportClause(
            ITsIdentifier? defaultBinding,
            ITsIdentifier? namespaceBinding,
            ImmutableArray<ITsImportSpecifier>? namedImports,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(defaultBinding, namespaceBinding, namedImports);
            DefaultBinding = defaultBinding;
            NamespaceBinding = namespaceBinding;
            NamedImports = namedImports;
        }

        public ITsIdentifier? DefaultBinding { get; }
        public ITsIdentifier? NamespaceBinding { get; }
        public ImmutableArray<ITsImportSpecifier>? NamedImports { get; }

        partial void VerifyInputs(ITsIdentifier? defaultBinding, ITsIdentifier? namespaceBinding, ImmutableArray<ITsImportSpecifier>? namedImports);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportClause(emitter, this);
    }

    public static class ImportClauseExtensions
    {
        public static ITsImportClause WithDefaultBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.DefaultBinding == value ? node : new TsImportClause(value, node.NamespaceBinding, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamespaceBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.NamespaceBinding == value ? node : new TsImportClause(node.DefaultBinding, value, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamedImports(this ITsImportClause node, ImmutableArray<ITsImportSpecifier>? value) =>
            node.NamedImports == value ? node : new TsImportClause(node.DefaultBinding, node.NamespaceBinding, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    public interface ITsImportDeclaration : ITsImplementationModuleElement
    {
        ITsImportClause? ImportClause { get; }
        ITsFromClause? FromClause { get; }
        ITsStringLiteral? Module { get; }
    }

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    internal partial class TsImportDeclaration : TsAstNode, ITsImportDeclaration
    {
        public TsImportDeclaration(
            ITsImportClause? importClause,
            ITsFromClause? fromClause,
            ITsStringLiteral? module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(importClause, fromClause, module);
            ImportClause = importClause;
            FromClause = fromClause;
            Module = module;
        }

        public ITsImportClause? ImportClause { get; }
        public ITsFromClause? FromClause { get; }
        public ITsStringLiteral? Module { get; }

        partial void VerifyInputs(ITsImportClause? importClause, ITsFromClause? fromClause, ITsStringLiteral? module);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportDeclaration(emitter, this);
    }

    public static class ImportDeclarationExtensions
    {
        public static ITsImportDeclaration WithImportClause(this ITsImportDeclaration node, ITsImportClause? value) =>
            node.ImportClause == value ? node : new TsImportDeclaration(value, node.FromClause, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithFromClause(this ITsImportDeclaration node, ITsFromClause? value) =>
            node.FromClause == value ? node : new TsImportDeclaration(node.ImportClause, value, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithModule(this ITsImportDeclaration node, ITsStringLiteral? value) =>
            node.Module == value ? node : new TsImportDeclaration(node.ImportClause, node.FromClause, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportSpecifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    public interface ITsImportSpecifier : ITsAstNode
    {
        ITsIdentifier Name { get; }
        ITsIdentifier? AsName { get; }
    }

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    internal partial class TsImportSpecifier : TsAstNode, ITsImportSpecifier
    {
        public TsImportSpecifier(
            ITsIdentifier name,
            ITsIdentifier? asName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, asName);
            Name = name;
            AsName = asName;
        }

        public ITsIdentifier Name { get; }
        public ITsIdentifier? AsName { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsIdentifier? asName);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportSpecifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportSpecifier(emitter, this);
    }

    public static class ImportSpecifierExtensions
    {
        public static ITsImportSpecifier WithName(this ITsImportSpecifier node, ITsIdentifier value) =>
            node.Name == value ? node : new TsImportSpecifier(value, node.AsName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportSpecifier WithAsName(this ITsImportSpecifier node, ITsIdentifier? value) =>
            node.AsName == value ? node : new TsImportSpecifier(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// LiteralPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name within an object literal, which can be an identifier, string literal, or a numeric literal.
    /// </summary>
    public interface ITsLiteralPropertyName : ITsPropertyName
    {
    }

    //// ===============================================================================================================
    //// ObjectBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    public interface ITsObjectBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingProperty> Properties { get; }
    }

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    internal partial class TsObjectBindingPattern : TsAstNode, ITsObjectBindingPattern
    {
        public TsObjectBindingPattern(
            ImmutableArray<ITsBindingProperty> properties,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(properties);
            Properties = properties;
        }

        public ImmutableArray<ITsBindingProperty> Properties { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingProperty> properties);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectBindingPattern(emitter, this);
    }

    public static class ObjectBindingPatternExtensions
    {
        public static ITsObjectBindingPattern WithProperties(this ITsObjectBindingPattern node, ImmutableArray<ITsBindingProperty> value) =>
            node.Properties == value ? node : new TsObjectBindingPattern(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PatternBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    public interface ITsPatternBinding : ITsBindingElement
    {
        ITsBindingPattern BindingPattern { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    internal partial class TsPatternBinding : TsAstNode, ITsPatternBinding
    {
        public TsPatternBinding(
            ITsBindingPattern bindingPattern,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bindingPattern, initializer);
            BindingPattern = bindingPattern;
            Initializer = initializer;
        }

        public ITsBindingPattern BindingPattern { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsBindingPattern bindingPattern, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPatternBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPatternBinding(emitter, this);
    }

    public static class PatternBindingExtensions
    {
        public static ITsPatternBinding WithBindingPattern(this ITsPatternBinding node, ITsBindingPattern value) =>
            node.BindingPattern == value ? node : new TsPatternBinding(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPatternBinding WithInitializer(this ITsPatternBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsPatternBinding(node.BindingPattern, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyAssignment
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    public interface ITsPropertyAssignment : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    internal partial class TsPropertyAssignment : TsAstNode, ITsPropertyAssignment
    {
        public TsPropertyAssignment(
            ITsPropertyName propertyName,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, initializer);
            PropertyName = propertyName;
            Initializer = initializer;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyAssignment(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyAssignment(emitter, this);
    }

    public static class PropertyAssignmentExtensions
    {
        public static ITsPropertyAssignment WithPropertyName(this ITsPropertyAssignment node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyAssignment(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyAssignment WithInitializer(this ITsPropertyAssignment node, ITsExpression value) =>
            node.Initializer == value ? node : new TsPropertyAssignment(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single property name within an object literal.
    /// </summary>
    public interface ITsPropertyName : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// PropertyNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    public interface ITsPropertyNameBinding : ITsBindingProperty
    {
        ITsPropertyName PropertyName { get; }
        ITsBindingElement BindingElement { get; }
    }

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    internal partial class TsPropertyNameBinding : TsAstNode, ITsPropertyNameBinding
    {
        public TsPropertyNameBinding(
            ITsPropertyName propertyName,
            ITsBindingElement bindingElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, bindingElement);
            PropertyName = propertyName;
            BindingElement = bindingElement;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsBindingElement BindingElement { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsBindingElement bindingElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyNameBinding(emitter, this);
    }

    public static class PropertyNameBindingExtensions
    {
        public static ITsPropertyNameBinding WithPropertyName(this ITsPropertyNameBinding node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyNameBinding(value, node.BindingElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyNameBinding WithBindingElement(this ITsPropertyNameBinding node, ITsBindingElement value) =>
            node.BindingElement == value ? node : new TsPropertyNameBinding(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SingleNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    public interface ITsSingleNameBinding : ITsBindingProperty, ITsBindingElement
    {
        ITsIdentifier Name { get; }
        ITsExpression? DefaultValue { get; }
    }

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    internal partial class TsSingleNameBinding : TsAstNode, ITsSingleNameBinding
    {
        public TsSingleNameBinding(
            ITsIdentifier name,
            ITsExpression? defaultValue,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, defaultValue);
            Name = name;
            DefaultValue = defaultValue;
        }

        public ITsIdentifier Name { get; }
        public ITsExpression? DefaultValue { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsExpression? defaultValue);
        public override void Accept(TsVisitor visitor) => visitor.VisitSingleNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSingleNameBinding(emitter, this);
    }

    public static class SingleNameBindingExtensions
    {
        public static ITsSingleNameBinding WithName(this ITsSingleNameBinding node, ITsIdentifier value) =>
            node.Name == value ? node : new TsSingleNameBinding(value, node.DefaultValue, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSingleNameBinding WithDefaultValue(this ITsSingleNameBinding node, ITsExpression? value) =>
            node.DefaultValue == value ? node : new TsSingleNameBinding(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StatementListItem
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for items that can be part of a statement list.
    /// </summary>
    public interface ITsStatementListItem : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// TemplatePart
    //// ===============================================================================================================

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    public interface ITsTemplatePart : ITsAstNode
    {
        string Template { get; }
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    internal partial class TsTemplatePart : TsAstNode, ITsTemplatePart
    {
        public TsTemplatePart(
            string template,
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(template, expression);
            Template = template;
            Expression = expression;
        }

        public string Template { get; }
        public ITsExpression? Expression { get; }

        partial void VerifyInputs(string template, ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplatePart(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplatePart(emitter, this);
    }

    public static class TemplatePartExtensions
    {
        public static ITsTemplatePart WithTemplate(this ITsTemplatePart node, string value) =>
            node.Template == value ? node : new TsTemplatePart(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTemplatePart WithExpression(this ITsTemplatePart node, ITsExpression? value) =>
            node.Expression == value ? node : new TsTemplatePart(node.Template, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
