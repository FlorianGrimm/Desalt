
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Others.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------------------
// TypeScript Grammar, version 1.8 (Jan 2016)
// ==========================================
// See https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md
// 
// The TypeScript grammar is a superset of the grammar defined in the ECMAScript 2015 Language
// Specification (specifically, the ECMA-262 Standard, 6th Edition) and this appendix lists only
// productions that are new or modified from the ECMAScript grammar.
// 
// See http://www.ecma-international.org/ecma-262/6.0/ for the ES2015 grammar.
// 
// Many of these interface names and shapes are taken from the TypeScript source code at:
// https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts.
// 
// There is also an Antlr grammar defined here:
// https://raw.githubusercontent.com/antlr/grammars-v4/master/typescript/TypeScriptParser.g4
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// AmbientBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents an ambient variable binding of the form 'name: type'.
    /// </summary>
    public interface ITsAmbientBinding : ITsAstNode
    {
        ITsIdentifier VariableName { get; }
        ITsType? VariableType { get; }
    }

    /// <summary>
    /// Represents an ambient variable binding of the form 'name: type'.
    /// </summary>
    internal partial class TsAmbientBinding : TsAstNode, ITsAmbientBinding
    {
        public TsAmbientBinding(
            ITsIdentifier variableName,
            ITsType? variableType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(variableName, variableType);
            VariableName = variableName;
            VariableType = variableType;
        }

        public ITsIdentifier VariableName { get; }
        public ITsType? VariableType { get; }

        partial void VerifyInputs(ITsIdentifier variableName, ITsType? variableType);
        public override void Accept(TsVisitor visitor) => visitor.VisitAmbientBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitAmbientBinding(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsAmbientBinding(VariableName, VariableType, leadingTrivia, trailingTrivia);
    }

    public static class AmbientBindingExtensions
    {
        public static ITsAmbientBinding WithVariableName(this ITsAmbientBinding node, ITsIdentifier value) =>
            node.VariableName == value ? node : new TsAmbientBinding(value, node.VariableType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAmbientBinding WithVariableType(this ITsAmbientBinding node, ITsType? value) =>
            node.VariableType == value ? node : new TsAmbientBinding(node.VariableName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// AmbientDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents an ambient declaration of the form 'declare element'.
    /// </summary>
    public interface ITsAmbientDeclaration : ITsImplementationElement
    {
        ITsAmbientDeclarationElement Declaration { get; }
    }

    /// <summary>
    /// Represents an ambient declaration of the form 'declare element'.
    /// </summary>
    internal partial class TsAmbientDeclaration : TsAstNode, ITsAmbientDeclaration
    {
        public TsAmbientDeclaration(
            ITsAmbientDeclarationElement declaration,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(declaration);
            Declaration = declaration;
        }

        public ITsAmbientDeclarationElement Declaration { get; }

        partial void VerifyInputs(ITsAmbientDeclarationElement declaration);
        public override void Accept(TsVisitor visitor) => visitor.VisitAmbientDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitAmbientDeclaration(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsAmbientDeclaration(Declaration, leadingTrivia, trailingTrivia);
    }

    public static class AmbientDeclarationExtensions
    {
        public static ITsAmbientDeclaration WithDeclaration(this ITsAmbientDeclaration node, ITsAmbientDeclarationElement value) =>
            node.Declaration == value ? node : new TsAmbientDeclaration(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// AmbientNamespaceElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an ambient namespace declaration.
    /// </summary>
    public interface ITsAmbientNamespaceElement : ITsAstNode
    {
        bool HasExportKeyword { get; }
        ITsAmbientDeclarationElement? Declaration { get; }
        ITsInterfaceDeclaration? InterfaceDeclaration { get; }
        ITsImportAliasDeclaration? ImportAliasDeclaration { get; }
    }

    /// <summary>
    /// Represents an element in an ambient namespace declaration.
    /// </summary>
    internal partial class TsAmbientNamespaceElement : TsAstNode, ITsAmbientNamespaceElement
    {
        public TsAmbientNamespaceElement(
            bool hasExportKeyword,
            ITsAmbientDeclarationElement? declaration,
            ITsInterfaceDeclaration? interfaceDeclaration,
            ITsImportAliasDeclaration? importAliasDeclaration,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(hasExportKeyword, declaration, interfaceDeclaration, importAliasDeclaration);
            HasExportKeyword = hasExportKeyword;
            Declaration = declaration;
            InterfaceDeclaration = interfaceDeclaration;
            ImportAliasDeclaration = importAliasDeclaration;
        }

        public bool HasExportKeyword { get; }
        public ITsAmbientDeclarationElement? Declaration { get; }
        public ITsInterfaceDeclaration? InterfaceDeclaration { get; }
        public ITsImportAliasDeclaration? ImportAliasDeclaration { get; }

        partial void VerifyInputs(bool hasExportKeyword, ITsAmbientDeclarationElement? declaration, ITsInterfaceDeclaration? interfaceDeclaration, ITsImportAliasDeclaration? importAliasDeclaration);
        public override void Accept(TsVisitor visitor) => visitor.VisitAmbientNamespaceElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitAmbientNamespaceElement(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsAmbientNamespaceElement(HasExportKeyword, Declaration, InterfaceDeclaration, ImportAliasDeclaration, leadingTrivia, trailingTrivia);
    }

    public static class AmbientNamespaceElementExtensions
    {
        public static ITsAmbientNamespaceElement WithHasExportKeyword(this ITsAmbientNamespaceElement node, bool value) =>
            node.HasExportKeyword == value ? node : new TsAmbientNamespaceElement(value, node.Declaration, node.InterfaceDeclaration, node.ImportAliasDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAmbientNamespaceElement WithDeclaration(this ITsAmbientNamespaceElement node, ITsAmbientDeclarationElement? value) =>
            node.Declaration == value ? node : new TsAmbientNamespaceElement(node.HasExportKeyword, value, node.InterfaceDeclaration, node.ImportAliasDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAmbientNamespaceElement WithInterfaceDeclaration(this ITsAmbientNamespaceElement node, ITsInterfaceDeclaration? value) =>
            node.InterfaceDeclaration == value ? node : new TsAmbientNamespaceElement(node.HasExportKeyword, node.Declaration, value, node.ImportAliasDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAmbientNamespaceElement WithImportAliasDeclaration(this ITsAmbientNamespaceElement node, ITsImportAliasDeclaration? value) =>
            node.ImportAliasDeclaration == value ? node : new TsAmbientNamespaceElement(node.HasExportKeyword, node.Declaration, node.InterfaceDeclaration, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Argument
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    public interface ITsArgument : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadArgument { get; }
    }

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    internal partial class TsArgument : TsAstNode, ITsArgument
    {
        public TsArgument(
            ITsExpression expression,
            bool isSpreadArgument,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadArgument);
            Expression = expression;
            IsSpreadArgument = isSpreadArgument;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadArgument { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadArgument);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgument(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgument(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsArgument(Expression, IsSpreadArgument, leadingTrivia, trailingTrivia);
    }

    public static class ArgumentExtensions
    {
        public static ITsArgument WithExpression(this ITsArgument node, ITsExpression value) =>
            node.Expression == value ? node : new TsArgument(value, node.IsSpreadArgument, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgument WithIsSpreadArgument(this ITsArgument node, bool value) =>
            node.IsSpreadArgument == value ? node : new TsArgument(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArgumentList
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    public interface ITsArgumentList : ITsAstNode
    {
        ImmutableArray<ITsType> TypeArguments { get; }
        ImmutableArray<ITsArgument> Arguments { get; }
    }

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    internal partial class TsArgumentList : TsAstNode, ITsArgumentList
    {
        public TsArgumentList(
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsArgument> arguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeArguments, arguments);
            TypeArguments = typeArguments;
            Arguments = arguments;
        }

        public ImmutableArray<ITsType> TypeArguments { get; }
        public ImmutableArray<ITsArgument> Arguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> typeArguments, ImmutableArray<ITsArgument> arguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgumentList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgumentList(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsArgumentList(TypeArguments, Arguments, leadingTrivia, trailingTrivia);
    }

    public static class ArgumentListExtensions
    {
        public static ITsArgumentList WithTypeArguments(this ITsArgumentList node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsArgumentList(value, node.Arguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgumentList WithArguments(this ITsArgumentList node, ImmutableArray<ITsArgument> value) =>
            node.Arguments == value ? node : new TsArgumentList(node.TypeArguments, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    public interface ITsArrayBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingElement?> Elements { get; }
        ITsIdentifier? RestElement { get; }
    }

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    internal partial class TsArrayBindingPattern : TsAstNode, ITsArrayBindingPattern
    {
        public TsArrayBindingPattern(
            ImmutableArray<ITsBindingElement?> elements,
            ITsIdentifier? restElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements, restElement);
            Elements = elements;
            RestElement = restElement;
        }

        public ImmutableArray<ITsBindingElement?> Elements { get; }
        public ITsIdentifier? RestElement { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingElement?> elements, ITsIdentifier? restElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayBindingPattern(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsArrayBindingPattern(Elements, RestElement, leadingTrivia, trailingTrivia);
    }

    public static class ArrayBindingPatternExtensions
    {
        public static ITsArrayBindingPattern WithElements(this ITsArrayBindingPattern node, ImmutableArray<ITsBindingElement?> value) =>
            node.Elements == value ? node : new TsArrayBindingPattern(value, node.RestElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayBindingPattern WithRestElement(this ITsArrayBindingPattern node, ITsIdentifier? value) =>
            node.RestElement == value ? node : new TsArrayBindingPattern(node.Elements, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    public interface ITsArrayElement : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadElement { get; }
    }

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    internal partial class TsArrayElement : TsAstNode, ITsArrayElement
    {
        public TsArrayElement(
            ITsExpression expression,
            bool isSpreadElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadElement);
            Expression = expression;
            IsSpreadElement = isSpreadElement;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadElement { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayElement(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsArrayElement(Expression, IsSpreadElement, leadingTrivia, trailingTrivia);
    }

    public static class ArrayElementExtensions
    {
        public static ITsArrayElement WithExpression(this ITsArrayElement node, ITsExpression value) =>
            node.Expression == value ? node : new TsArrayElement(value, node.IsSpreadElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayElement WithIsSpreadElement(this ITsArrayElement node, bool value) =>
            node.IsSpreadElement == value ? node : new TsArrayElement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingElement
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for binding elements in object and array bindings.
    /// </summary>
    public interface ITsBindingElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BindingIdentifierOrPattern
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for a binding identifier or pattern.
    /// </summary>
    public interface ITsBindingIdentifierOrPattern : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for a binding pattern.
    /// </summary>
    public interface ITsBindingPattern : ITsBindingIdentifierOrPattern
    {
    }

    //// ===============================================================================================================
    //// BindingProperty
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for properties that are bound in array or object initializers.
    /// </summary>
    public interface ITsBindingProperty : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BoundOptionalParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a bound optional parameter in a parameter list for a function.
    /// </summary>
    public interface ITsBoundOptionalParameter : ITsOptionalParameter
    {
        TsAccessibilityModifier? Modifier { get; }
        ITsBindingIdentifierOrPattern ParameterName { get; }
        ITsType? ParameterType { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a bound optional parameter in a parameter list for a function.
    /// </summary>
    internal partial class TsBoundOptionalParameter : TsAstNode, ITsBoundOptionalParameter
    {
        public TsBoundOptionalParameter(
            TsAccessibilityModifier? modifier,
            ITsBindingIdentifierOrPattern parameterName,
            ITsType? parameterType,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(modifier, parameterName, parameterType, initializer);
            Modifier = modifier;
            ParameterName = parameterName;
            ParameterType = parameterType;
            Initializer = initializer;
        }

        public TsAccessibilityModifier? Modifier { get; }
        public ITsBindingIdentifierOrPattern ParameterName { get; }
        public ITsType? ParameterType { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(TsAccessibilityModifier? modifier, ITsBindingIdentifierOrPattern parameterName, ITsType? parameterType, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitBoundOptionalParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBoundOptionalParameter(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsBoundOptionalParameter(Modifier, ParameterName, ParameterType, Initializer, leadingTrivia, trailingTrivia);
    }

    public static class BoundOptionalParameterExtensions
    {
        public static ITsBoundOptionalParameter WithModifier(this ITsBoundOptionalParameter node, TsAccessibilityModifier? value) =>
            node.Modifier == value ? node : new TsBoundOptionalParameter(value, node.ParameterName, node.ParameterType, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundOptionalParameter WithParameterName(this ITsBoundOptionalParameter node, ITsBindingIdentifierOrPattern value) =>
            node.ParameterName == value ? node : new TsBoundOptionalParameter(node.Modifier, value, node.ParameterType, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundOptionalParameter WithParameterType(this ITsBoundOptionalParameter node, ITsType? value) =>
            node.ParameterType == value ? node : new TsBoundOptionalParameter(node.Modifier, node.ParameterName, value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundOptionalParameter WithInitializer(this ITsBoundOptionalParameter node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsBoundOptionalParameter(node.Modifier, node.ParameterName, node.ParameterType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BoundRequiredParameter
    //// ===============================================================================================================

    public enum TsAccessibilityModifier
    {
        Public,
        Private,
        Protected,
    }

    /// <summary>
    /// Represents a bound required parameter in a parameter list for a function.
    /// </summary>
    public interface ITsBoundRequiredParameter : ITsRequiredParameter
    {
        TsAccessibilityModifier? Modifier { get; }
        ITsBindingIdentifierOrPattern ParameterName { get; }
        ITsType? ParameterType { get; }
    }

    /// <summary>
    /// Represents a bound required parameter in a parameter list for a function.
    /// </summary>
    internal partial class TsBoundRequiredParameter : TsAstNode, ITsBoundRequiredParameter
    {
        public TsBoundRequiredParameter(
            TsAccessibilityModifier? modifier,
            ITsBindingIdentifierOrPattern parameterName,
            ITsType? parameterType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(modifier, parameterName, parameterType);
            Modifier = modifier;
            ParameterName = parameterName;
            ParameterType = parameterType;
        }

        public TsAccessibilityModifier? Modifier { get; }
        public ITsBindingIdentifierOrPattern ParameterName { get; }
        public ITsType? ParameterType { get; }

        partial void VerifyInputs(TsAccessibilityModifier? modifier, ITsBindingIdentifierOrPattern parameterName, ITsType? parameterType);
        public override void Accept(TsVisitor visitor) => visitor.VisitBoundRequiredParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBoundRequiredParameter(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsBoundRequiredParameter(Modifier, ParameterName, ParameterType, leadingTrivia, trailingTrivia);
    }

    public static class BoundRequiredParameterExtensions
    {
        public static ITsBoundRequiredParameter WithModifier(this ITsBoundRequiredParameter node, TsAccessibilityModifier? value) =>
            node.Modifier == value ? node : new TsBoundRequiredParameter(value, node.ParameterName, node.ParameterType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundRequiredParameter WithParameterName(this ITsBoundRequiredParameter node, ITsBindingIdentifierOrPattern value) =>
            node.ParameterName == value ? node : new TsBoundRequiredParameter(node.Modifier, value, node.ParameterType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundRequiredParameter WithParameterType(this ITsBoundRequiredParameter node, ITsType? value) =>
            node.ParameterType == value ? node : new TsBoundRequiredParameter(node.Modifier, node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CaseClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    public interface ITsCaseClause : ITsCaseOrDefaultClause
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    internal partial class TsCaseClause : TsAstNode, ITsCaseClause
    {
        public TsCaseClause(
            ITsExpression expression,
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, statements);
            Expression = expression;
            Statements = statements;
        }

        public ITsExpression Expression { get; }
        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ITsExpression expression, ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitCaseClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCaseClause(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsCaseClause(Expression, Statements, leadingTrivia, trailingTrivia);
    }

    public static class CaseClauseExtensions
    {
        public static ITsCaseClause WithExpression(this ITsCaseClause node, ITsExpression value) =>
            node.Expression == value ? node : new TsCaseClause(value, node.Statements, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCaseClause WithStatements(this ITsCaseClause node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsCaseClause(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CaseOrDefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents either a 'case' or 'default' clause within a 'switch' statement.
    /// </summary>
    public interface ITsCaseOrDefaultClause : ITsAstNode
    {
        ImmutableArray<ITsStatementListItem> Statements { get; }
    }

    //// ===============================================================================================================
    //// ClassHeritage
    //// ===============================================================================================================

    /// <summary>
    /// Represents a class heritage of the form ' extends type implements type, type'.
    /// </summary>
    public interface ITsClassHeritage : ITsAstNode
    {
        ITsTypeReference? ExtendsClause { get; }
        ImmutableArray<ITsTypeReference> ImplementsClause { get; }
    }

    /// <summary>
    /// Represents a class heritage of the form ' extends type implements type, type'.
    /// </summary>
    internal partial class TsClassHeritage : TsAstNode, ITsClassHeritage
    {
        public TsClassHeritage(
            ITsTypeReference? extendsClause,
            ImmutableArray<ITsTypeReference> implementsClause,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(extendsClause, implementsClause);
            ExtendsClause = extendsClause;
            ImplementsClause = implementsClause;
        }

        public ITsTypeReference? ExtendsClause { get; }
        public ImmutableArray<ITsTypeReference> ImplementsClause { get; }

        partial void VerifyInputs(ITsTypeReference? extendsClause, ImmutableArray<ITsTypeReference> implementsClause);
        public override void Accept(TsVisitor visitor) => visitor.VisitClassHeritage(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitClassHeritage(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsClassHeritage(ExtendsClause, ImplementsClause, leadingTrivia, trailingTrivia);
    }

    public static class ClassHeritageExtensions
    {
        public static ITsClassHeritage WithExtendsClause(this ITsClassHeritage node, ITsTypeReference? value) =>
            node.ExtendsClause == value ? node : new TsClassHeritage(value, node.ImplementsClause, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsClassHeritage WithImplementsClause(this ITsClassHeritage node, ImmutableArray<ITsTypeReference> value) =>
            node.ImplementsClause == value ? node : new TsClassHeritage(node.ExtendsClause, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ComputedPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    public interface ITsComputedPropertyName : ITsPropertyName
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    internal partial class TsComputedPropertyName : TsAstNode, ITsComputedPropertyName
    {
        public TsComputedPropertyName(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitComputedPropertyName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitComputedPropertyName(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsComputedPropertyName(Expression, leadingTrivia, trailingTrivia);
    }

    public static class ComputedPropertyNameExtensions
    {
        public static ITsComputedPropertyName WithExpression(this ITsComputedPropertyName node, ITsExpression value) =>
            node.Expression == value ? node : new TsComputedPropertyName(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CoverInitializedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    public interface ITsCoverInitializedName : ITsPropertyDefinition
    {
        ITsIdentifier Identifier { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    internal partial class TsCoverInitializedName : TsAstNode, ITsCoverInitializedName
    {
        public TsCoverInitializedName(
            ITsIdentifier identifier,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(identifier, initializer);
            Identifier = identifier;
            Initializer = initializer;
        }

        public ITsIdentifier Identifier { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsIdentifier identifier, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitCoverInitializedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCoverInitializedName(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsCoverInitializedName(Identifier, Initializer, leadingTrivia, trailingTrivia);
    }

    public static class CoverInitializedNameExtensions
    {
        public static ITsCoverInitializedName WithIdentifier(this ITsCoverInitializedName node, ITsIdentifier value) =>
            node.Identifier == value ? node : new TsCoverInitializedName(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCoverInitializedName WithInitializer(this ITsCoverInitializedName node, ITsExpression value) =>
            node.Initializer == value ? node : new TsCoverInitializedName(node.Identifier, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    public interface ITsDefaultClause : ITsCaseOrDefaultClause
    {
    }

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    internal partial class TsDefaultClause : TsAstNode, ITsDefaultClause
    {
        public TsDefaultClause(
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitDefaultClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDefaultClause(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsDefaultClause(Statements, leadingTrivia, trailingTrivia);
    }

    public static class DefaultClauseExtensions
    {
        public static ITsDefaultClause WithStatements(this ITsDefaultClause node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsDefaultClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DestructuringLexicalBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a destructuring lexical binding of the form '{x, y}: type = foo' or '[x, y]:type = foo'.
    /// </summary>
    public interface ITsDestructuringLexicalBinding : ITsLexicalBinding
    {
        ITsBindingPattern BindingPattern { get; }
        ITsType? VariableType { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a destructuring lexical binding of the form '{x, y}: type = foo' or '[x, y]:type = foo'.
    /// </summary>
    internal partial class TsDestructuringLexicalBinding : TsAstNode, ITsDestructuringLexicalBinding
    {
        public TsDestructuringLexicalBinding(
            ITsBindingPattern bindingPattern,
            ITsType? variableType,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bindingPattern, variableType, initializer);
            BindingPattern = bindingPattern;
            VariableType = variableType;
            Initializer = initializer;
        }

        public ITsBindingPattern BindingPattern { get; }
        public ITsType? VariableType { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsBindingPattern bindingPattern, ITsType? variableType, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitDestructuringLexicalBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDestructuringLexicalBinding(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsDestructuringLexicalBinding(BindingPattern, VariableType, Initializer, leadingTrivia, trailingTrivia);
    }

    public static class DestructuringLexicalBindingExtensions
    {
        public static ITsDestructuringLexicalBinding WithBindingPattern(this ITsDestructuringLexicalBinding node, ITsBindingPattern value) =>
            node.BindingPattern == value ? node : new TsDestructuringLexicalBinding(value, node.VariableType, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsDestructuringLexicalBinding WithVariableType(this ITsDestructuringLexicalBinding node, ITsType? value) =>
            node.VariableType == value ? node : new TsDestructuringLexicalBinding(node.BindingPattern, value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsDestructuringLexicalBinding WithInitializer(this ITsDestructuringLexicalBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsDestructuringLexicalBinding(node.BindingPattern, node.VariableType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// EnumMember
    //// ===============================================================================================================

    /// <summary>
    /// Represents an enum member of the form, 'name = value'.
    /// </summary>
    public interface ITsEnumMember : ITsAstNode
    {
        ITsPropertyName Name { get; }
        ITsExpression? Value { get; }
    }

    /// <summary>
    /// Represents an enum member of the form, 'name = value'.
    /// </summary>
    internal partial class TsEnumMember : TsAstNode, ITsEnumMember
    {
        public TsEnumMember(
            ITsPropertyName name,
            ITsExpression? value,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, value);
            Name = name;
            Value = value;
        }

        public ITsPropertyName Name { get; }
        public ITsExpression? Value { get; }

        partial void VerifyInputs(ITsPropertyName name, ITsExpression? value);
        public override void Accept(TsVisitor visitor) => visitor.VisitEnumMember(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitEnumMember(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsEnumMember(Name, Value, leadingTrivia, trailingTrivia);
    }

    public static class EnumMemberExtensions
    {
        public static ITsEnumMember WithName(this ITsEnumMember node, ITsPropertyName value) =>
            node.Name == value ? node : new TsEnumMember(value, node.Value, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsEnumMember WithValue(this ITsEnumMember node, ITsExpression? value) =>
            node.Value == value ? node : new TsEnumMember(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ExportImplementationElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an exported element in a module file.
    /// </summary>
    public interface ITsExportImplementationElement : ITsImplementationModuleElement
    {
        ITsImplementationElement ExportedElement { get; }
    }

    /// <summary>
    /// Represents an exported element in a module file.
    /// </summary>
    internal partial class TsExportImplementationElement : TsAstNode, ITsExportImplementationElement
    {
        public TsExportImplementationElement(
            ITsImplementationElement exportedElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(exportedElement);
            ExportedElement = exportedElement;
        }

        public ITsImplementationElement ExportedElement { get; }

        partial void VerifyInputs(ITsImplementationElement exportedElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitExportImplementationElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitExportImplementationElement(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsExportImplementationElement(ExportedElement, leadingTrivia, trailingTrivia);
    }

    public static class ExportImplementationElementExtensions
    {
        public static ITsExportImplementationElement WithExportedElement(this ITsExportImplementationElement node, ITsImplementationElement value) =>
            node.ExportedElement == value ? node : new TsExportImplementationElement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// FromClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    public interface ITsFromClause : ITsAstNode
    {
        ITsStringLiteral Module { get; }
    }

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    internal partial class TsFromClause : TsAstNode, ITsFromClause
    {
        public TsFromClause(
            ITsStringLiteral module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(module);
            Module = module;
        }

        public ITsStringLiteral Module { get; }

        partial void VerifyInputs(ITsStringLiteral module);
        public override void Accept(TsVisitor visitor) => visitor.VisitFromClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitFromClause(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsFromClause(Module, leadingTrivia, trailingTrivia);
    }

    public static class FromClauseExtensions
    {
        public static ITsFromClause WithModule(this ITsFromClause node, ITsStringLiteral value) =>
            node.Module == value ? node : new TsFromClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// GenericTypeName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a qualified name with type arguments. For example, 'ns.type.method&lt;T1, T2&gt;'.
    /// </summary>
    public interface ITsGenericTypeName : ITsQualifiedName
    {
        ImmutableArray<ITsType> TypeArguments { get; }
    }

    /// <summary>
    /// Represents a qualified name with type arguments. For example, 'ns.type.method&lt;T1, T2&gt;'.
    /// </summary>
    internal partial class TsGenericTypeName : TsAstNode, ITsGenericTypeName
    {
        public TsGenericTypeName(
            ImmutableArray<ITsIdentifier> left,
            ITsIdentifier right,
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(left, right, typeArguments);
            Left = left;
            Right = right;
            TypeArguments = typeArguments;
        }

        public ImmutableArray<ITsIdentifier> Left { get; }
        public ITsIdentifier Right { get; }
        public ImmutableArray<ITsType> TypeArguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsIdentifier> left, ITsIdentifier right, ImmutableArray<ITsType> typeArguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitGenericTypeName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitGenericTypeName(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsGenericTypeName(Left, Right, TypeArguments, leadingTrivia, trailingTrivia);
    }

    public static class GenericTypeNameExtensions
    {
        public static ITsGenericTypeName WithLeft(this ITsGenericTypeName node, ImmutableArray<ITsIdentifier> value) =>
            node.Left == value ? node : new TsGenericTypeName(value, node.Right, node.TypeArguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsGenericTypeName WithRight(this ITsGenericTypeName node, ITsIdentifier value) =>
            node.Right == value ? node : new TsGenericTypeName(node.Left, value, node.TypeArguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsGenericTypeName WithTypeArguments(this ITsGenericTypeName node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsGenericTypeName(node.Left, node.Right, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// GetAccessor
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property get accessor of the form 'get name (): type { body }'.
    /// </summary>
    public interface ITsGetAccessor : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsType? PropertyType { get; }
        ImmutableArray<ITsStatementListItem> FunctionBody { get; }
    }

    /// <summary>
    /// Represents a property get accessor of the form 'get name (): type { body }'.
    /// </summary>
    internal partial class TsGetAccessor : TsAstNode, ITsGetAccessor
    {
        public TsGetAccessor(
            ITsPropertyName propertyName,
            ITsType? propertyType,
            ImmutableArray<ITsStatementListItem> functionBody,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, propertyType, functionBody);
            PropertyName = propertyName;
            PropertyType = propertyType;
            FunctionBody = functionBody;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsType? PropertyType { get; }
        public ImmutableArray<ITsStatementListItem> FunctionBody { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsType? propertyType, ImmutableArray<ITsStatementListItem> functionBody);
        public override void Accept(TsVisitor visitor) => visitor.VisitGetAccessor(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitGetAccessor(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsGetAccessor(PropertyName, PropertyType, FunctionBody, leadingTrivia, trailingTrivia);
    }

    public static class GetAccessorExtensions
    {
        public static ITsGetAccessor WithPropertyName(this ITsGetAccessor node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsGetAccessor(value, node.PropertyType, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsGetAccessor WithPropertyType(this ITsGetAccessor node, ITsType? value) =>
            node.PropertyType == value ? node : new TsGetAccessor(node.PropertyName, value, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsGetAccessor WithFunctionBody(this ITsGetAccessor node, ImmutableArray<ITsStatementListItem> value) =>
            node.FunctionBody == value ? node : new TsGetAccessor(node.PropertyName, node.PropertyType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Identifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    public interface ITsIdentifier : ITsTypeName, ITsPropertyDefinition, ITsLiteralPropertyName, ITsBindingIdentifierOrPattern
    {
        string Text { get; }
    }

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    internal partial class TsIdentifier : TsAstNode, ITsIdentifier
    {
        public TsIdentifier(
            string text,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(text);
            Text = text;
        }

        public string Text { get; }

        partial void VerifyInputs(string text);
        public override void Accept(TsVisitor visitor) => visitor.VisitIdentifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIdentifier(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsIdentifier(Text, leadingTrivia, trailingTrivia);
    }

    public static class IdentifierExtensions
    {
        public static ITsIdentifier WithText(this ITsIdentifier node, string value) =>
            node.Text == value ? node : new TsIdentifier(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    public interface IMemberAccessOmittedIdentifier : ITsAstNode, ITsExpression
    {
    }

    /// <summary>
    /// Represents a context where a C# identifier is to be omitted from TypeScript member access (dot) expressions.
    /// </summary>
    internal partial class MemberAccessOmittedIdentifier : TsAstNode, IMemberAccessOmittedIdentifier
    {
        public MemberAccessOmittedIdentifier(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
        }

        public override void Accept(TsVisitor visitor) => visitor.VisitMemberAccessOmittedIdentifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberAccessOmittedIdentifier(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new MemberAccessOmittedIdentifier(leadingTrivia, trailingTrivia);
    }

    //// ===============================================================================================================
    //// ImplementationElement
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all elements that can be a top-level entity within a <see cref="ITsImplementationScript" /> or <see cref="ITsImplementationModule" />.
    /// </summary>
    public interface ITsImplementationElement : ITsImplementationScriptElement, ITsImplementationModuleElement
    {
    }

    //// ===============================================================================================================
    //// ImplementationModule
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript implementation source file (extension '.ts'), containing exported statements and declarations.
    /// </summary>
    public interface ITsImplementationModule : ITsImplementationSourceFile
    {
        ImmutableArray<ITsImplementationModuleElement> Elements { get; }
    }

    /// <summary>
    /// Represents a TypeScript implementation source file (extension '.ts'), containing exported statements and declarations.
    /// </summary>
    internal partial class TsImplementationModule : TsAstNode, ITsImplementationModule
    {
        public TsImplementationModule(
            ImmutableArray<ITsImplementationModuleElement> elements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements);
            Elements = elements;
        }

        public ImmutableArray<ITsImplementationModuleElement> Elements { get; }

        partial void VerifyInputs(ImmutableArray<ITsImplementationModuleElement> elements);
        public override void Accept(TsVisitor visitor) => visitor.VisitImplementationModule(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImplementationModule(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsImplementationModule(Elements, leadingTrivia, trailingTrivia);
    }

    public static class ImplementationModuleExtensions
    {
        public static ITsImplementationModule WithElements(this ITsImplementationModule node, ImmutableArray<ITsImplementationModuleElement> value) =>
            node.Elements == value ? node : new TsImplementationModule(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImplementationModuleElement
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all elements that can be a top-level entity within a <see cref="ITsImplementationModule" />.
    /// </summary>
    public interface ITsImplementationModuleElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ImplementationScript
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript implementation source file (extension '.ts'), containing statements and declarations.
    /// </summary>
    public interface ITsImplementationScript : ITsImplementationSourceFile
    {
        ImmutableArray<ITsImplementationScriptElement> Elements { get; }
    }

    /// <summary>
    /// Represents a TypeScript implementation source file (extension '.ts'), containing statements and declarations.
    /// </summary>
    internal partial class TsImplementationScript : TsAstNode, ITsImplementationScript
    {
        public TsImplementationScript(
            ImmutableArray<ITsImplementationScriptElement> elements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements);
            Elements = elements;
        }

        public ImmutableArray<ITsImplementationScriptElement> Elements { get; }

        partial void VerifyInputs(ImmutableArray<ITsImplementationScriptElement> elements);
        public override void Accept(TsVisitor visitor) => visitor.VisitImplementationScript(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImplementationScript(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsImplementationScript(Elements, leadingTrivia, trailingTrivia);
    }

    public static class ImplementationScriptExtensions
    {
        public static ITsImplementationScript WithElements(this ITsImplementationScript node, ImmutableArray<ITsImplementationScriptElement> value) =>
            node.Elements == value ? node : new TsImplementationScript(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImplementationScriptElement
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all elements that can be a top-level entity within a <see cref="ITsImplementationScript" />.
    /// </summary>
    public interface ITsImplementationScriptElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ImplementationSourceFile
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript source file that contains implementation code (vs. just declarations).
    /// </summary>
    public interface ITsImplementationSourceFile : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ImportClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    public interface ITsImportClause : ITsAstNode
    {
        ITsIdentifier? DefaultBinding { get; }
        ITsIdentifier? NamespaceBinding { get; }
        ImmutableArray<ITsImportSpecifier> NamedImports { get; }
    }

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    internal partial class TsImportClause : TsAstNode, ITsImportClause
    {
        public TsImportClause(
            ITsIdentifier? defaultBinding,
            ITsIdentifier? namespaceBinding,
            ImmutableArray<ITsImportSpecifier> namedImports,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(defaultBinding, namespaceBinding, namedImports);
            DefaultBinding = defaultBinding;
            NamespaceBinding = namespaceBinding;
            NamedImports = namedImports;
        }

        public ITsIdentifier? DefaultBinding { get; }
        public ITsIdentifier? NamespaceBinding { get; }
        public ImmutableArray<ITsImportSpecifier> NamedImports { get; }

        partial void VerifyInputs(ITsIdentifier? defaultBinding, ITsIdentifier? namespaceBinding, ImmutableArray<ITsImportSpecifier> namedImports);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportClause(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsImportClause(DefaultBinding, NamespaceBinding, NamedImports, leadingTrivia, trailingTrivia);
    }

    public static class ImportClauseExtensions
    {
        public static ITsImportClause WithDefaultBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.DefaultBinding == value ? node : new TsImportClause(value, node.NamespaceBinding, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamespaceBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.NamespaceBinding == value ? node : new TsImportClause(node.DefaultBinding, value, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamedImports(this ITsImportClause node, ImmutableArray<ITsImportSpecifier> value) =>
            node.NamedImports == value ? node : new TsImportClause(node.DefaultBinding, node.NamespaceBinding, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    public interface ITsImportDeclaration : ITsImplementationModuleElement
    {
        ITsImportClause? ImportClause { get; }
        ITsFromClause? FromClause { get; }
        ITsStringLiteral? Module { get; }
    }

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    internal partial class TsImportDeclaration : TsAstNode, ITsImportDeclaration
    {
        public TsImportDeclaration(
            ITsImportClause? importClause,
            ITsFromClause? fromClause,
            ITsStringLiteral? module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(importClause, fromClause, module);
            ImportClause = importClause;
            FromClause = fromClause;
            Module = module;
        }

        public ITsImportClause? ImportClause { get; }
        public ITsFromClause? FromClause { get; }
        public ITsStringLiteral? Module { get; }

        partial void VerifyInputs(ITsImportClause? importClause, ITsFromClause? fromClause, ITsStringLiteral? module);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportDeclaration(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsImportDeclaration(ImportClause, FromClause, Module, leadingTrivia, trailingTrivia);
    }

    public static class ImportDeclarationExtensions
    {
        public static ITsImportDeclaration WithImportClause(this ITsImportDeclaration node, ITsImportClause? value) =>
            node.ImportClause == value ? node : new TsImportDeclaration(value, node.FromClause, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithFromClause(this ITsImportDeclaration node, ITsFromClause? value) =>
            node.FromClause == value ? node : new TsImportDeclaration(node.ImportClause, value, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithModule(this ITsImportDeclaration node, ITsStringLiteral? value) =>
            node.Module == value ? node : new TsImportDeclaration(node.ImportClause, node.FromClause, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportRequireDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import declaration using 'require', of the form 'import name = require(string);'.
    /// </summary>
    public interface ITsImportRequireDeclaration : ITsImplementationModuleElement
    {
        ITsIdentifier Name { get; }
        ITsStringLiteral Require { get; }
    }

    /// <summary>
    /// Represents an import declaration using 'require', of the form 'import name = require(string);'.
    /// </summary>
    internal partial class TsImportRequireDeclaration : TsAstNode, ITsImportRequireDeclaration
    {
        public TsImportRequireDeclaration(
            ITsIdentifier name,
            ITsStringLiteral require,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, require);
            Name = name;
            Require = require;
        }

        public ITsIdentifier Name { get; }
        public ITsStringLiteral Require { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsStringLiteral require);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportRequireDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportRequireDeclaration(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsImportRequireDeclaration(Name, Require, leadingTrivia, trailingTrivia);
    }

    public static class ImportRequireDeclarationExtensions
    {
        public static ITsImportRequireDeclaration WithName(this ITsImportRequireDeclaration node, ITsIdentifier value) =>
            node.Name == value ? node : new TsImportRequireDeclaration(value, node.Require, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportRequireDeclaration WithRequire(this ITsImportRequireDeclaration node, ITsStringLiteral value) =>
            node.Require == value ? node : new TsImportRequireDeclaration(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportSpecifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    public interface ITsImportSpecifier : ITsAstNode
    {
        ITsIdentifier Name { get; }
        ITsIdentifier? AsName { get; }
    }

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    internal partial class TsImportSpecifier : TsAstNode, ITsImportSpecifier
    {
        public TsImportSpecifier(
            ITsIdentifier name,
            ITsIdentifier? asName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, asName);
            Name = name;
            AsName = asName;
        }

        public ITsIdentifier Name { get; }
        public ITsIdentifier? AsName { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsIdentifier? asName);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportSpecifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportSpecifier(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsImportSpecifier(Name, AsName, leadingTrivia, trailingTrivia);
    }

    public static class ImportSpecifierExtensions
    {
        public static ITsImportSpecifier WithName(this ITsImportSpecifier node, ITsIdentifier value) =>
            node.Name == value ? node : new TsImportSpecifier(value, node.AsName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportSpecifier WithAsName(this ITsImportSpecifier node, ITsIdentifier? value) =>
            node.AsName == value ? node : new TsImportSpecifier(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// LexicalBinding
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all lexical bindings.
    /// </summary>
    public interface ITsLexicalBinding : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// LiteralPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name within an object literal, which can be an identifier, string literal, or a numeric literal.
    /// </summary>
    public interface ITsLiteralPropertyName : ITsPropertyName
    {
    }

    //// ===============================================================================================================
    //// ObjectBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    public interface ITsObjectBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingProperty> Properties { get; }
    }

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    internal partial class TsObjectBindingPattern : TsAstNode, ITsObjectBindingPattern
    {
        public TsObjectBindingPattern(
            ImmutableArray<ITsBindingProperty> properties,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(properties);
            Properties = properties;
        }

        public ImmutableArray<ITsBindingProperty> Properties { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingProperty> properties);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectBindingPattern(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsObjectBindingPattern(Properties, leadingTrivia, trailingTrivia);
    }

    public static class ObjectBindingPatternExtensions
    {
        public static ITsObjectBindingPattern WithProperties(this ITsObjectBindingPattern node, ImmutableArray<ITsBindingProperty> value) =>
            node.Properties == value ? node : new TsObjectBindingPattern(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// OptionalParameter
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for an optional parameter in a <see cref="ITsParameterList" />.
    /// </summary>
    public interface ITsOptionalParameter : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ParameterList
    //// ===============================================================================================================

    /// <summary>
    /// Represents a parameter list of the form '(parameter: type)'.
    /// </summary>
    public interface ITsParameterList : ITsAstNode
    {
        ImmutableArray<ITsRequiredParameter> RequiredParameters { get; }
        ImmutableArray<ITsOptionalParameter> OptionalParameters { get; }
        ITsRestParameter? RestParameter { get; }
    }

    /// <summary>
    /// Represents a parameter list of the form '(parameter: type)'.
    /// </summary>
    internal partial class TsParameterList : TsAstNode, ITsParameterList
    {
        public TsParameterList(
            ImmutableArray<ITsRequiredParameter> requiredParameters,
            ImmutableArray<ITsOptionalParameter> optionalParameters,
            ITsRestParameter? restParameter,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(requiredParameters, optionalParameters, restParameter);
            RequiredParameters = requiredParameters;
            OptionalParameters = optionalParameters;
            RestParameter = restParameter;
        }

        public ImmutableArray<ITsRequiredParameter> RequiredParameters { get; }
        public ImmutableArray<ITsOptionalParameter> OptionalParameters { get; }
        public ITsRestParameter? RestParameter { get; }

        partial void VerifyInputs(ImmutableArray<ITsRequiredParameter> requiredParameters, ImmutableArray<ITsOptionalParameter> optionalParameters, ITsRestParameter? restParameter);
        public override void Accept(TsVisitor visitor) => visitor.VisitParameterList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitParameterList(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsParameterList(RequiredParameters, OptionalParameters, RestParameter, leadingTrivia, trailingTrivia);
    }

    public static class ParameterListExtensions
    {
        public static ITsParameterList WithRequiredParameters(this ITsParameterList node, ImmutableArray<ITsRequiredParameter> value) =>
            node.RequiredParameters == value ? node : new TsParameterList(value, node.OptionalParameters, node.RestParameter, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsParameterList WithOptionalParameters(this ITsParameterList node, ImmutableArray<ITsOptionalParameter> value) =>
            node.OptionalParameters == value ? node : new TsParameterList(node.RequiredParameters, value, node.RestParameter, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsParameterList WithRestParameter(this ITsParameterList node, ITsRestParameter? value) =>
            node.RestParameter == value ? node : new TsParameterList(node.RequiredParameters, node.OptionalParameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PatternBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    public interface ITsPatternBinding : ITsBindingElement
    {
        ITsBindingPattern BindingPattern { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    internal partial class TsPatternBinding : TsAstNode, ITsPatternBinding
    {
        public TsPatternBinding(
            ITsBindingPattern bindingPattern,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bindingPattern, initializer);
            BindingPattern = bindingPattern;
            Initializer = initializer;
        }

        public ITsBindingPattern BindingPattern { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsBindingPattern bindingPattern, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPatternBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPatternBinding(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsPatternBinding(BindingPattern, Initializer, leadingTrivia, trailingTrivia);
    }

    public static class PatternBindingExtensions
    {
        public static ITsPatternBinding WithBindingPattern(this ITsPatternBinding node, ITsBindingPattern value) =>
            node.BindingPattern == value ? node : new TsPatternBinding(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPatternBinding WithInitializer(this ITsPatternBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsPatternBinding(node.BindingPattern, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyAssignment
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    public interface ITsPropertyAssignment : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    internal partial class TsPropertyAssignment : TsAstNode, ITsPropertyAssignment
    {
        public TsPropertyAssignment(
            ITsPropertyName propertyName,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, initializer);
            PropertyName = propertyName;
            Initializer = initializer;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyAssignment(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyAssignment(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsPropertyAssignment(PropertyName, Initializer, leadingTrivia, trailingTrivia);
    }

    public static class PropertyAssignmentExtensions
    {
        public static ITsPropertyAssignment WithPropertyName(this ITsPropertyAssignment node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyAssignment(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyAssignment WithInitializer(this ITsPropertyAssignment node, ITsExpression value) =>
            node.Initializer == value ? node : new TsPropertyAssignment(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyFunction
    //// ===============================================================================================================

    /// <summary>
    /// Represents an object literal property function.
    /// </summary>
    public interface ITsPropertyFunction : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsCallSignature CallSignature { get; }
        ImmutableArray<ITsStatementListItem> FunctionBody { get; }
    }

    /// <summary>
    /// Represents an object literal property function.
    /// </summary>
    internal partial class TsPropertyFunction : TsAstNode, ITsPropertyFunction
    {
        public TsPropertyFunction(
            ITsPropertyName propertyName,
            ITsCallSignature callSignature,
            ImmutableArray<ITsStatementListItem> functionBody,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, callSignature, functionBody);
            PropertyName = propertyName;
            CallSignature = callSignature;
            FunctionBody = functionBody;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsCallSignature CallSignature { get; }
        public ImmutableArray<ITsStatementListItem> FunctionBody { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsCallSignature callSignature, ImmutableArray<ITsStatementListItem> functionBody);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyFunction(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyFunction(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsPropertyFunction(PropertyName, CallSignature, FunctionBody, leadingTrivia, trailingTrivia);
    }

    public static class PropertyFunctionExtensions
    {
        public static ITsPropertyFunction WithPropertyName(this ITsPropertyFunction node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyFunction(value, node.CallSignature, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyFunction WithCallSignature(this ITsPropertyFunction node, ITsCallSignature value) =>
            node.CallSignature == value ? node : new TsPropertyFunction(node.PropertyName, value, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyFunction WithFunctionBody(this ITsPropertyFunction node, ImmutableArray<ITsStatementListItem> value) =>
            node.FunctionBody == value ? node : new TsPropertyFunction(node.PropertyName, node.CallSignature, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single property name within an object literal.
    /// </summary>
    public interface ITsPropertyName : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// PropertyNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    public interface ITsPropertyNameBinding : ITsBindingProperty
    {
        ITsPropertyName PropertyName { get; }
        ITsBindingElement BindingElement { get; }
    }

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    internal partial class TsPropertyNameBinding : TsAstNode, ITsPropertyNameBinding
    {
        public TsPropertyNameBinding(
            ITsPropertyName propertyName,
            ITsBindingElement bindingElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, bindingElement);
            PropertyName = propertyName;
            BindingElement = bindingElement;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsBindingElement BindingElement { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsBindingElement bindingElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyNameBinding(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsPropertyNameBinding(PropertyName, BindingElement, leadingTrivia, trailingTrivia);
    }

    public static class PropertyNameBindingExtensions
    {
        public static ITsPropertyNameBinding WithPropertyName(this ITsPropertyNameBinding node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyNameBinding(value, node.BindingElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyNameBinding WithBindingElement(this ITsPropertyNameBinding node, ITsBindingElement value) =>
            node.BindingElement == value ? node : new TsPropertyNameBinding(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// QualifiedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a qualified name, which has dots between identifiers. For example, 'ns.type.method'.
    /// </summary>
    public interface ITsQualifiedName : ITsTypeName
    {
        ImmutableArray<ITsIdentifier> Left { get; }
        ITsIdentifier Right { get; }
    }

    /// <summary>
    /// Represents a qualified name, which has dots between identifiers. For example, 'ns.type.method'.
    /// </summary>
    internal partial class TsQualifiedName : TsAstNode, ITsQualifiedName
    {
        public TsQualifiedName(
            ImmutableArray<ITsIdentifier> left,
            ITsIdentifier right,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(left, right);
            Left = left;
            Right = right;
        }

        public ImmutableArray<ITsIdentifier> Left { get; }
        public ITsIdentifier Right { get; }

        partial void VerifyInputs(ImmutableArray<ITsIdentifier> left, ITsIdentifier right);
        public override void Accept(TsVisitor visitor) => visitor.VisitQualifiedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitQualifiedName(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsQualifiedName(Left, Right, leadingTrivia, trailingTrivia);
    }

    public static class QualifiedNameExtensions
    {
        public static ITsQualifiedName WithLeft(this ITsQualifiedName node, ImmutableArray<ITsIdentifier> value) =>
            node.Left == value ? node : new TsQualifiedName(value, node.Right, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsQualifiedName WithRight(this ITsQualifiedName node, ITsIdentifier value) =>
            node.Right == value ? node : new TsQualifiedName(node.Left, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// RequiredParameter
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for a required parameter in a <see cref="ITsParameterList" />.
    /// </summary>
    public interface ITsRequiredParameter : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// RestParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a function parameter of the form '... parameterName: type'.
    /// </summary>
    public interface ITsRestParameter : ITsAstNode
    {
        ITsIdentifier ParameterName { get; }
        ITsType? ParameterType { get; }
    }

    /// <summary>
    /// Represents a function parameter of the form '... parameterName: type'.
    /// </summary>
    internal partial class TsRestParameter : TsAstNode, ITsRestParameter
    {
        public TsRestParameter(
            ITsIdentifier parameterName,
            ITsType? parameterType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parameterName, parameterType);
            ParameterName = parameterName;
            ParameterType = parameterType;
        }

        public ITsIdentifier ParameterName { get; }
        public ITsType? ParameterType { get; }

        partial void VerifyInputs(ITsIdentifier parameterName, ITsType? parameterType);
        public override void Accept(TsVisitor visitor) => visitor.VisitRestParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitRestParameter(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsRestParameter(ParameterName, ParameterType, leadingTrivia, trailingTrivia);
    }

    public static class RestParameterExtensions
    {
        public static ITsRestParameter WithParameterName(this ITsRestParameter node, ITsIdentifier value) =>
            node.ParameterName == value ? node : new TsRestParameter(value, node.ParameterType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsRestParameter WithParameterType(this ITsRestParameter node, ITsType? value) =>
            node.ParameterType == value ? node : new TsRestParameter(node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SetAccessor
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property set accessor of the form 'set name(value: type) { body }'.
    /// </summary>
    public interface ITsSetAccessor : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsBindingIdentifierOrPattern ParameterName { get; }
        ITsType? ParameterType { get; }
        ImmutableArray<ITsStatementListItem> FunctionBody { get; }
    }

    /// <summary>
    /// Represents a property set accessor of the form 'set name(value: type) { body }'.
    /// </summary>
    internal partial class TsSetAccessor : TsAstNode, ITsSetAccessor
    {
        public TsSetAccessor(
            ITsPropertyName propertyName,
            ITsBindingIdentifierOrPattern parameterName,
            ITsType? parameterType,
            ImmutableArray<ITsStatementListItem> functionBody,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, parameterName, parameterType, functionBody);
            PropertyName = propertyName;
            ParameterName = parameterName;
            ParameterType = parameterType;
            FunctionBody = functionBody;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsBindingIdentifierOrPattern ParameterName { get; }
        public ITsType? ParameterType { get; }
        public ImmutableArray<ITsStatementListItem> FunctionBody { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsBindingIdentifierOrPattern parameterName, ITsType? parameterType, ImmutableArray<ITsStatementListItem> functionBody);
        public override void Accept(TsVisitor visitor) => visitor.VisitSetAccessor(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSetAccessor(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsSetAccessor(PropertyName, ParameterName, ParameterType, FunctionBody, leadingTrivia, trailingTrivia);
    }

    public static class SetAccessorExtensions
    {
        public static ITsSetAccessor WithPropertyName(this ITsSetAccessor node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsSetAccessor(value, node.ParameterName, node.ParameterType, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSetAccessor WithParameterName(this ITsSetAccessor node, ITsBindingIdentifierOrPattern value) =>
            node.ParameterName == value ? node : new TsSetAccessor(node.PropertyName, value, node.ParameterType, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSetAccessor WithParameterType(this ITsSetAccessor node, ITsType? value) =>
            node.ParameterType == value ? node : new TsSetAccessor(node.PropertyName, node.ParameterName, value, node.FunctionBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSetAccessor WithFunctionBody(this ITsSetAccessor node, ImmutableArray<ITsStatementListItem> value) =>
            node.FunctionBody == value ? node : new TsSetAccessor(node.PropertyName, node.ParameterName, node.ParameterType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SimpleLexicalBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a simple lexical binding of the form 'x: type = y'.
    /// </summary>
    public interface ITsSimpleLexicalBinding : ITsLexicalBinding
    {
        ITsIdentifier VariableName { get; }
        ITsType? VariableType { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a simple lexical binding of the form 'x: type = y'.
    /// </summary>
    internal partial class TsSimpleLexicalBinding : TsAstNode, ITsSimpleLexicalBinding
    {
        public TsSimpleLexicalBinding(
            ITsIdentifier variableName,
            ITsType? variableType,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(variableName, variableType, initializer);
            VariableName = variableName;
            VariableType = variableType;
            Initializer = initializer;
        }

        public ITsIdentifier VariableName { get; }
        public ITsType? VariableType { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsIdentifier variableName, ITsType? variableType, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitSimpleLexicalBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSimpleLexicalBinding(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsSimpleLexicalBinding(VariableName, VariableType, Initializer, leadingTrivia, trailingTrivia);
    }

    public static class SimpleLexicalBindingExtensions
    {
        public static ITsSimpleLexicalBinding WithVariableName(this ITsSimpleLexicalBinding node, ITsIdentifier value) =>
            node.VariableName == value ? node : new TsSimpleLexicalBinding(value, node.VariableType, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSimpleLexicalBinding WithVariableType(this ITsSimpleLexicalBinding node, ITsType? value) =>
            node.VariableType == value ? node : new TsSimpleLexicalBinding(node.VariableName, value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSimpleLexicalBinding WithInitializer(this ITsSimpleLexicalBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsSimpleLexicalBinding(node.VariableName, node.VariableType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SingleNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    public interface ITsSingleNameBinding : ITsBindingProperty, ITsBindingElement
    {
        ITsIdentifier Name { get; }
        ITsExpression? DefaultValue { get; }
    }

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    internal partial class TsSingleNameBinding : TsAstNode, ITsSingleNameBinding
    {
        public TsSingleNameBinding(
            ITsIdentifier name,
            ITsExpression? defaultValue,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, defaultValue);
            Name = name;
            DefaultValue = defaultValue;
        }

        public ITsIdentifier Name { get; }
        public ITsExpression? DefaultValue { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsExpression? defaultValue);
        public override void Accept(TsVisitor visitor) => visitor.VisitSingleNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSingleNameBinding(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsSingleNameBinding(Name, DefaultValue, leadingTrivia, trailingTrivia);
    }

    public static class SingleNameBindingExtensions
    {
        public static ITsSingleNameBinding WithName(this ITsSingleNameBinding node, ITsIdentifier value) =>
            node.Name == value ? node : new TsSingleNameBinding(value, node.DefaultValue, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSingleNameBinding WithDefaultValue(this ITsSingleNameBinding node, ITsExpression? value) =>
            node.DefaultValue == value ? node : new TsSingleNameBinding(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StatementListItem
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for items that can be part of a statement list.
    /// </summary>
    public interface ITsStatementListItem : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// StringOptionalParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents an optional function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    public interface ITsStringOptionalParameter : ITsOptionalParameter
    {
        ITsIdentifier ParameterName { get; }
        ITsStringLiteral StringLiteral { get; }
    }

    /// <summary>
    /// Represents an optional function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    internal partial class TsStringOptionalParameter : TsAstNode, ITsStringOptionalParameter
    {
        public TsStringOptionalParameter(
            ITsIdentifier parameterName,
            ITsStringLiteral stringLiteral,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parameterName, stringLiteral);
            ParameterName = parameterName;
            StringLiteral = stringLiteral;
        }

        public ITsIdentifier ParameterName { get; }
        public ITsStringLiteral StringLiteral { get; }

        partial void VerifyInputs(ITsIdentifier parameterName, ITsStringLiteral stringLiteral);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringOptionalParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringOptionalParameter(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsStringOptionalParameter(ParameterName, StringLiteral, leadingTrivia, trailingTrivia);
    }

    public static class StringOptionalParameterExtensions
    {
        public static ITsStringOptionalParameter WithParameterName(this ITsStringOptionalParameter node, ITsIdentifier value) =>
            node.ParameterName == value ? node : new TsStringOptionalParameter(value, node.StringLiteral, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringOptionalParameter WithStringLiteral(this ITsStringOptionalParameter node, ITsStringLiteral value) =>
            node.StringLiteral == value ? node : new TsStringOptionalParameter(node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StringRequiredParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a required function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    public interface ITsStringRequiredParameter : ITsRequiredParameter
    {
        ITsIdentifier ParameterName { get; }
        ITsStringLiteral StringLiteral { get; }
    }

    /// <summary>
    /// Represents a required function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    internal partial class TsStringRequiredParameter : TsAstNode, ITsStringRequiredParameter
    {
        public TsStringRequiredParameter(
            ITsIdentifier parameterName,
            ITsStringLiteral stringLiteral,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parameterName, stringLiteral);
            ParameterName = parameterName;
            StringLiteral = stringLiteral;
        }

        public ITsIdentifier ParameterName { get; }
        public ITsStringLiteral StringLiteral { get; }

        partial void VerifyInputs(ITsIdentifier parameterName, ITsStringLiteral stringLiteral);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringRequiredParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringRequiredParameter(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsStringRequiredParameter(ParameterName, StringLiteral, leadingTrivia, trailingTrivia);
    }

    public static class StringRequiredParameterExtensions
    {
        public static ITsStringRequiredParameter WithParameterName(this ITsStringRequiredParameter node, ITsIdentifier value) =>
            node.ParameterName == value ? node : new TsStringRequiredParameter(value, node.StringLiteral, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringRequiredParameter WithStringLiteral(this ITsStringRequiredParameter node, ITsStringLiteral value) =>
            node.StringLiteral == value ? node : new TsStringRequiredParameter(node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplatePart
    //// ===============================================================================================================

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    public interface ITsTemplatePart : ITsAstNode
    {
        string Template { get; }
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    internal partial class TsTemplatePart : TsAstNode, ITsTemplatePart
    {
        public TsTemplatePart(
            string template,
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(template, expression);
            Template = template;
            Expression = expression;
        }

        public string Template { get; }
        public ITsExpression? Expression { get; }

        partial void VerifyInputs(string template, ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplatePart(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplatePart(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsTemplatePart(Template, Expression, leadingTrivia, trailingTrivia);
    }

    public static class TemplatePartExtensions
    {
        public static ITsTemplatePart WithTemplate(this ITsTemplatePart node, string value) =>
            node.Template == value ? node : new TsTemplatePart(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTemplatePart WithExpression(this ITsTemplatePart node, ITsExpression? value) =>
            node.Expression == value ? node : new TsTemplatePart(node.Template, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript type parameter, for example &lt;MyType extends MyBase&gt;.
    /// </summary>
    public interface ITsTypeParameter : ITsAstNode
    {
        ITsIdentifier TypeName { get; }
        ITsType? Constraint { get; }
    }

    /// <summary>
    /// Represents a TypeScript type parameter, for example &lt;MyType extends MyBase&gt;.
    /// </summary>
    internal partial class TsTypeParameter : TsAstNode, ITsTypeParameter
    {
        public TsTypeParameter(
            ITsIdentifier typeName,
            ITsType? constraint,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeName, constraint);
            TypeName = typeName;
            Constraint = constraint;
        }

        public ITsIdentifier TypeName { get; }
        public ITsType? Constraint { get; }

        partial void VerifyInputs(ITsIdentifier typeName, ITsType? constraint);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeParameter(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsTypeParameter(TypeName, Constraint, leadingTrivia, trailingTrivia);
    }

    public static class TypeParameterExtensions
    {
        public static ITsTypeParameter WithTypeName(this ITsTypeParameter node, ITsIdentifier value) =>
            node.TypeName == value ? node : new TsTypeParameter(value, node.Constraint, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTypeParameter WithConstraint(this ITsTypeParameter node, ITsType? value) =>
            node.Constraint == value ? node : new TsTypeParameter(node.TypeName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeParameters
    //// ===============================================================================================================

    /// <summary>
    /// Represents a list of type parameters of the form '&lt;type, type&gt;'.
    /// </summary>
    public interface ITsTypeParameters : ITsAstNode
    {
        ImmutableArray<ITsTypeParameter> TypeParameters { get; }
    }

    /// <summary>
    /// Represents a list of type parameters of the form '&lt;type, type&gt;'.
    /// </summary>
    internal partial class TsTypeParameters : TsAstNode, ITsTypeParameters
    {
        public TsTypeParameters(
            ImmutableArray<ITsTypeParameter> typeParameters,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeParameters);
            TypeParameters = typeParameters;
        }

        public ImmutableArray<ITsTypeParameter> TypeParameters { get; }

        partial void VerifyInputs(ImmutableArray<ITsTypeParameter> typeParameters);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeParameters(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeParameters(emitter, this);
        public override ITsAstNode ShallowCopy(
            ImmutableArray<ITsAstTriviaNode> leadingTrivia,
            ImmutableArray<ITsAstTriviaNode> trailingTrivia) =>
            new TsTypeParameters(TypeParameters, leadingTrivia, trailingTrivia);
    }

    public static class TypeParametersExtensions
    {
        public static ITsTypeParameters WithTypeParameters(this ITsTypeParameters node, ImmutableArray<ITsTypeParameter> value) =>
            node.TypeParameters == value ? node : new TsTypeParameters(value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
