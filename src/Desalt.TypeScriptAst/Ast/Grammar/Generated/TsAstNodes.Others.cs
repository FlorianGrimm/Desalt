
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Others.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Argument
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    public interface ITsArgument : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadArgument { get; }
    }

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    internal partial class TsArgument : TsAstNode, ITsArgument
    {
        public TsArgument(
            ITsExpression expression,
            bool isSpreadArgument,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadArgument);
            Expression = expression;
            IsSpreadArgument = isSpreadArgument;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadArgument { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadArgument);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgument(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgument(emitter, this);
    }

    public static class ArgumentExtensions
    {
        public static ITsArgument WithExpression(this ITsArgument node, ITsExpression value) =>
            node.Expression == value ? node : new TsArgument(value, node.IsSpreadArgument, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgument WithIsSpreadArgument(this ITsArgument node, bool value) =>
            node.IsSpreadArgument == value ? node : new TsArgument(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArgumentList
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    public interface ITsArgumentList : ITsAstNode
    {
        ImmutableArray<ITsType> TypeArguments { get; }
        ImmutableArray<ITsArgument> Arguments { get; }
    }

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    internal partial class TsArgumentList : TsAstNode, ITsArgumentList
    {
        public TsArgumentList(
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsArgument> arguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeArguments, arguments);
            TypeArguments = typeArguments;
            Arguments = arguments;
        }

        public ImmutableArray<ITsType> TypeArguments { get; }
        public ImmutableArray<ITsArgument> Arguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> typeArguments, ImmutableArray<ITsArgument> arguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgumentList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgumentList(emitter, this);
    }

    public static class ArgumentListExtensions
    {
        public static ITsArgumentList WithTypeArguments(this ITsArgumentList node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsArgumentList(value, node.Arguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgumentList WithArguments(this ITsArgumentList node, ImmutableArray<ITsArgument> value) =>
            node.Arguments == value ? node : new TsArgumentList(node.TypeArguments, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    public interface ITsArrayBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingElement?> Elements { get; }
        ITsIdentifier? RestElement { get; }
    }

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    internal partial class TsArrayBindingPattern : TsAstNode, ITsArrayBindingPattern
    {
        public TsArrayBindingPattern(
            ImmutableArray<ITsBindingElement?> elements,
            ITsIdentifier? restElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements, restElement);
            Elements = elements;
            RestElement = restElement;
        }

        public ImmutableArray<ITsBindingElement?> Elements { get; }
        public ITsIdentifier? RestElement { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingElement?> elements, ITsIdentifier? restElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayBindingPattern(emitter, this);
    }

    public static class ArrayBindingPatternExtensions
    {
        public static ITsArrayBindingPattern WithElements(this ITsArrayBindingPattern node, ImmutableArray<ITsBindingElement?> value) =>
            node.Elements == value ? node : new TsArrayBindingPattern(value, node.RestElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayBindingPattern WithRestElement(this ITsArrayBindingPattern node, ITsIdentifier? value) =>
            node.RestElement == value ? node : new TsArrayBindingPattern(node.Elements, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    public interface ITsArrayElement : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadElement { get; }
    }

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    internal partial class TsArrayElement : TsAstNode, ITsArrayElement
    {
        public TsArrayElement(
            ITsExpression expression,
            bool isSpreadElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadElement);
            Expression = expression;
            IsSpreadElement = isSpreadElement;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadElement { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayElement(emitter, this);
    }

    public static class ArrayElementExtensions
    {
        public static ITsArrayElement WithExpression(this ITsArrayElement node, ITsExpression value) =>
            node.Expression == value ? node : new TsArrayElement(value, node.IsSpreadElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayElement WithIsSpreadElement(this ITsArrayElement node, bool value) =>
            node.IsSpreadElement == value ? node : new TsArrayElement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingElement
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for binding elements in object and array bindings.
    /// </summary>
    public interface ITsBindingElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BindingIdentifierOrPattern
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for a binding identifier or pattern.
    /// </summary>
    public interface ITsBindingIdentifierOrPattern : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for a binding pattern.
    /// </summary>
    public interface ITsBindingPattern : ITsBindingIdentifierOrPattern
    {
    }

    //// ===============================================================================================================
    //// BindingProperty
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for properties that are bound in array or object initializers.
    /// </summary>
    public interface ITsBindingProperty : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// BoundOptionalParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a bound optional parameter in a parameter list for a function.
    /// </summary>
    public interface ITsBoundOptionalParameter : ITsOptionalParameter
    {
        TsAccessibilityModifier? Modifier { get; }
        ITsBindingIdentifierOrPattern ParameterName { get; }
        ITsType? ParameterType { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a bound optional parameter in a parameter list for a function.
    /// </summary>
    internal partial class TsBoundOptionalParameter : TsAstNode, ITsBoundOptionalParameter
    {
        public TsBoundOptionalParameter(
            TsAccessibilityModifier? modifier,
            ITsBindingIdentifierOrPattern parameterName,
            ITsType? parameterType,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(modifier, parameterName, parameterType, initializer);
            Modifier = modifier;
            ParameterName = parameterName;
            ParameterType = parameterType;
            Initializer = initializer;
        }

        public TsAccessibilityModifier? Modifier { get; }
        public ITsBindingIdentifierOrPattern ParameterName { get; }
        public ITsType? ParameterType { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(TsAccessibilityModifier? modifier, ITsBindingIdentifierOrPattern parameterName, ITsType? parameterType, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitBoundOptionalParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBoundOptionalParameter(emitter, this);
    }

    public static class BoundOptionalParameterExtensions
    {
        public static ITsBoundOptionalParameter WithModifier(this ITsBoundOptionalParameter node, TsAccessibilityModifier? value) =>
            node.Modifier == value ? node : new TsBoundOptionalParameter(value, node.ParameterName, node.ParameterType, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundOptionalParameter WithParameterName(this ITsBoundOptionalParameter node, ITsBindingIdentifierOrPattern value) =>
            node.ParameterName == value ? node : new TsBoundOptionalParameter(node.Modifier, value, node.ParameterType, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundOptionalParameter WithParameterType(this ITsBoundOptionalParameter node, ITsType? value) =>
            node.ParameterType == value ? node : new TsBoundOptionalParameter(node.Modifier, node.ParameterName, value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundOptionalParameter WithInitializer(this ITsBoundOptionalParameter node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsBoundOptionalParameter(node.Modifier, node.ParameterName, node.ParameterType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BoundRequiredParameter
    //// ===============================================================================================================

    public enum TsAccessibilityModifier
    {
        Public,
        Private,
        Protected,
    }

    /// <summary>
    /// Represents a bound required parameter in a parameter list for a function.
    /// </summary>
    public interface ITsBoundRequiredParameter : ITsRequiredParameter
    {
        TsAccessibilityModifier? Modifier { get; }
        ITsBindingIdentifierOrPattern ParameterName { get; }
        ITsType? ParameterType { get; }
    }

    /// <summary>
    /// Represents a bound required parameter in a parameter list for a function.
    /// </summary>
    internal partial class TsBoundRequiredParameter : TsAstNode, ITsBoundRequiredParameter
    {
        public TsBoundRequiredParameter(
            TsAccessibilityModifier? modifier,
            ITsBindingIdentifierOrPattern parameterName,
            ITsType? parameterType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(modifier, parameterName, parameterType);
            Modifier = modifier;
            ParameterName = parameterName;
            ParameterType = parameterType;
        }

        public TsAccessibilityModifier? Modifier { get; }
        public ITsBindingIdentifierOrPattern ParameterName { get; }
        public ITsType? ParameterType { get; }

        partial void VerifyInputs(TsAccessibilityModifier? modifier, ITsBindingIdentifierOrPattern parameterName, ITsType? parameterType);
        public override void Accept(TsVisitor visitor) => visitor.VisitBoundRequiredParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBoundRequiredParameter(emitter, this);
    }

    public static class BoundRequiredParameterExtensions
    {
        public static ITsBoundRequiredParameter WithModifier(this ITsBoundRequiredParameter node, TsAccessibilityModifier? value) =>
            node.Modifier == value ? node : new TsBoundRequiredParameter(value, node.ParameterName, node.ParameterType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundRequiredParameter WithParameterName(this ITsBoundRequiredParameter node, ITsBindingIdentifierOrPattern value) =>
            node.ParameterName == value ? node : new TsBoundRequiredParameter(node.Modifier, value, node.ParameterType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBoundRequiredParameter WithParameterType(this ITsBoundRequiredParameter node, ITsType? value) =>
            node.ParameterType == value ? node : new TsBoundRequiredParameter(node.Modifier, node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CaseClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    public interface ITsCaseClause : ITsCaseOrDefaultClause
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    internal partial class TsCaseClause : TsAstNode, ITsCaseClause
    {
        public TsCaseClause(
            ITsExpression expression,
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, statements);
            Expression = expression;
            Statements = statements;
        }

        public ITsExpression Expression { get; }
        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ITsExpression expression, ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitCaseClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCaseClause(emitter, this);
    }

    public static class CaseClauseExtensions
    {
        public static ITsCaseClause WithExpression(this ITsCaseClause node, ITsExpression value) =>
            node.Expression == value ? node : new TsCaseClause(value, node.Statements, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCaseClause WithStatements(this ITsCaseClause node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsCaseClause(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CaseOrDefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents either a 'case' or 'default' clause within a 'switch' statement.
    /// </summary>
    public interface ITsCaseOrDefaultClause : ITsAstNode
    {
        ImmutableArray<ITsStatementListItem> Statements { get; }
    }

    //// ===============================================================================================================
    //// ComputedPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    public interface ITsComputedPropertyName : ITsPropertyName
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    internal partial class TsComputedPropertyName : TsAstNode, ITsComputedPropertyName
    {
        public TsComputedPropertyName(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitComputedPropertyName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitComputedPropertyName(emitter, this);
    }

    public static class ComputedPropertyNameExtensions
    {
        public static ITsComputedPropertyName WithExpression(this ITsComputedPropertyName node, ITsExpression value) =>
            node.Expression == value ? node : new TsComputedPropertyName(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CoverInitializedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    public interface ITsCoverInitializedName : ITsPropertyDefinition
    {
        ITsIdentifier Identifier { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    internal partial class TsCoverInitializedName : TsAstNode, ITsCoverInitializedName
    {
        public TsCoverInitializedName(
            ITsIdentifier identifier,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(identifier, initializer);
            Identifier = identifier;
            Initializer = initializer;
        }

        public ITsIdentifier Identifier { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsIdentifier identifier, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitCoverInitializedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCoverInitializedName(emitter, this);
    }

    public static class CoverInitializedNameExtensions
    {
        public static ITsCoverInitializedName WithIdentifier(this ITsCoverInitializedName node, ITsIdentifier value) =>
            node.Identifier == value ? node : new TsCoverInitializedName(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCoverInitializedName WithInitializer(this ITsCoverInitializedName node, ITsExpression value) =>
            node.Initializer == value ? node : new TsCoverInitializedName(node.Identifier, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    public interface ITsDefaultClause : ITsCaseOrDefaultClause
    {
    }

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    internal partial class TsDefaultClause : TsAstNode, ITsDefaultClause
    {
        public TsDefaultClause(
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitDefaultClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDefaultClause(emitter, this);
    }

    public static class DefaultClauseExtensions
    {
        public static ITsDefaultClause WithStatements(this ITsDefaultClause node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsDefaultClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// FromClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    public interface ITsFromClause : ITsAstNode
    {
        ITsStringLiteral Module { get; }
    }

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    internal partial class TsFromClause : TsAstNode, ITsFromClause
    {
        public TsFromClause(
            ITsStringLiteral module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(module);
            Module = module;
        }

        public ITsStringLiteral Module { get; }

        partial void VerifyInputs(ITsStringLiteral module);
        public override void Accept(TsVisitor visitor) => visitor.VisitFromClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitFromClause(emitter, this);
    }

    public static class FromClauseExtensions
    {
        public static ITsFromClause WithModule(this ITsFromClause node, ITsStringLiteral value) =>
            node.Module == value ? node : new TsFromClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// GenericTypeName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a qualified name with type arguments. For example, 'ns.type.method&lt;T1, T2&gt;'.
    /// </summary>
    public interface ITsGenericTypeName : ITsQualifiedName
    {
        ImmutableArray<ITsType> TypeArguments { get; }
    }

    /// <summary>
    /// Represents a qualified name with type arguments. For example, 'ns.type.method&lt;T1, T2&gt;'.
    /// </summary>
    internal partial class TsGenericTypeName : TsAstNode, ITsGenericTypeName
    {
        public TsGenericTypeName(
            ImmutableArray<ITsIdentifier> left,
            ITsIdentifier right,
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(left, right, typeArguments);
            Left = left;
            Right = right;
            TypeArguments = typeArguments;
        }

        public ImmutableArray<ITsIdentifier> Left { get; }
        public ITsIdentifier Right { get; }
        public ImmutableArray<ITsType> TypeArguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsIdentifier> left, ITsIdentifier right, ImmutableArray<ITsType> typeArguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitGenericTypeName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitGenericTypeName(emitter, this);
    }

    public static class GenericTypeNameExtensions
    {
        public static ITsGenericTypeName WithLeft(this ITsGenericTypeName node, ImmutableArray<ITsIdentifier> value) =>
            node.Left == value ? node : new TsGenericTypeName(value, node.Right, node.TypeArguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsGenericTypeName WithRight(this ITsGenericTypeName node, ITsIdentifier value) =>
            node.Right == value ? node : new TsGenericTypeName(node.Left, value, node.TypeArguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsGenericTypeName WithTypeArguments(this ITsGenericTypeName node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsGenericTypeName(node.Left, node.Right, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Identifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    public interface ITsIdentifier : ITsTypeName, ITsPropertyDefinition, ITsLiteralPropertyName, ITsBindingIdentifierOrPattern
    {
        string Text { get; }
    }

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    internal partial class TsIdentifier : TsAstNode, ITsIdentifier
    {
        public TsIdentifier(
            string text,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(text);
            Text = text;
        }

        public string Text { get; }

        partial void VerifyInputs(string text);
        public override void Accept(TsVisitor visitor) => visitor.VisitIdentifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIdentifier(emitter, this);
    }

    public static class IdentifierExtensions
    {
        public static ITsIdentifier WithText(this ITsIdentifier node, string value) =>
            node.Text == value ? node : new TsIdentifier(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    public interface ITsImportClause : ITsAstNode
    {
        ITsIdentifier? DefaultBinding { get; }
        ITsIdentifier? NamespaceBinding { get; }
        ImmutableArray<ITsImportSpecifier> NamedImports { get; }
    }

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    internal partial class TsImportClause : TsAstNode, ITsImportClause
    {
        public TsImportClause(
            ITsIdentifier? defaultBinding,
            ITsIdentifier? namespaceBinding,
            ImmutableArray<ITsImportSpecifier> namedImports,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(defaultBinding, namespaceBinding, namedImports);
            DefaultBinding = defaultBinding;
            NamespaceBinding = namespaceBinding;
            NamedImports = namedImports;
        }

        public ITsIdentifier? DefaultBinding { get; }
        public ITsIdentifier? NamespaceBinding { get; }
        public ImmutableArray<ITsImportSpecifier> NamedImports { get; }

        partial void VerifyInputs(ITsIdentifier? defaultBinding, ITsIdentifier? namespaceBinding, ImmutableArray<ITsImportSpecifier> namedImports);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportClause(emitter, this);
    }

    public static class ImportClauseExtensions
    {
        public static ITsImportClause WithDefaultBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.DefaultBinding == value ? node : new TsImportClause(value, node.NamespaceBinding, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamespaceBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.NamespaceBinding == value ? node : new TsImportClause(node.DefaultBinding, value, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamedImports(this ITsImportClause node, ImmutableArray<ITsImportSpecifier> value) =>
            node.NamedImports == value ? node : new TsImportClause(node.DefaultBinding, node.NamespaceBinding, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    public interface ITsImportDeclaration : ITsImplementationModuleElement
    {
        ITsImportClause? ImportClause { get; }
        ITsFromClause? FromClause { get; }
        ITsStringLiteral? Module { get; }
    }

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    internal partial class TsImportDeclaration : TsAstNode, ITsImportDeclaration
    {
        public TsImportDeclaration(
            ITsImportClause? importClause,
            ITsFromClause? fromClause,
            ITsStringLiteral? module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(importClause, fromClause, module);
            ImportClause = importClause;
            FromClause = fromClause;
            Module = module;
        }

        public ITsImportClause? ImportClause { get; }
        public ITsFromClause? FromClause { get; }
        public ITsStringLiteral? Module { get; }

        partial void VerifyInputs(ITsImportClause? importClause, ITsFromClause? fromClause, ITsStringLiteral? module);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportDeclaration(emitter, this);
    }

    public static class ImportDeclarationExtensions
    {
        public static ITsImportDeclaration WithImportClause(this ITsImportDeclaration node, ITsImportClause? value) =>
            node.ImportClause == value ? node : new TsImportDeclaration(value, node.FromClause, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithFromClause(this ITsImportDeclaration node, ITsFromClause? value) =>
            node.FromClause == value ? node : new TsImportDeclaration(node.ImportClause, value, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithModule(this ITsImportDeclaration node, ITsStringLiteral? value) =>
            node.Module == value ? node : new TsImportDeclaration(node.ImportClause, node.FromClause, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportSpecifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    public interface ITsImportSpecifier : ITsAstNode
    {
        ITsIdentifier Name { get; }
        ITsIdentifier? AsName { get; }
    }

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    internal partial class TsImportSpecifier : TsAstNode, ITsImportSpecifier
    {
        public TsImportSpecifier(
            ITsIdentifier name,
            ITsIdentifier? asName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, asName);
            Name = name;
            AsName = asName;
        }

        public ITsIdentifier Name { get; }
        public ITsIdentifier? AsName { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsIdentifier? asName);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportSpecifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportSpecifier(emitter, this);
    }

    public static class ImportSpecifierExtensions
    {
        public static ITsImportSpecifier WithName(this ITsImportSpecifier node, ITsIdentifier value) =>
            node.Name == value ? node : new TsImportSpecifier(value, node.AsName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportSpecifier WithAsName(this ITsImportSpecifier node, ITsIdentifier? value) =>
            node.AsName == value ? node : new TsImportSpecifier(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// LiteralPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name within an object literal, which can be an identifier, string literal, or a numeric literal.
    /// </summary>
    public interface ITsLiteralPropertyName : ITsPropertyName
    {
    }

    //// ===============================================================================================================
    //// ObjectBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    public interface ITsObjectBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingProperty> Properties { get; }
    }

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    internal partial class TsObjectBindingPattern : TsAstNode, ITsObjectBindingPattern
    {
        public TsObjectBindingPattern(
            ImmutableArray<ITsBindingProperty> properties,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(properties);
            Properties = properties;
        }

        public ImmutableArray<ITsBindingProperty> Properties { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingProperty> properties);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectBindingPattern(emitter, this);
    }

    public static class ObjectBindingPatternExtensions
    {
        public static ITsObjectBindingPattern WithProperties(this ITsObjectBindingPattern node, ImmutableArray<ITsBindingProperty> value) =>
            node.Properties == value ? node : new TsObjectBindingPattern(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// OptionalParameter
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for an optional parameter in a <see cref="ITsParameterList" />.
    /// </summary>
    public interface ITsOptionalParameter : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// ParameterList
    //// ===============================================================================================================

    /// <summary>
    /// Represents a parameter list of the form '(parameter: type)'.
    /// </summary>
    public interface ITsParameterList : ITsAstNode
    {
        ImmutableArray<ITsRequiredParameter> RequiredParameters { get; }
        ImmutableArray<ITsOptionalParameter> OptionalParameters { get; }
        ITsRestParameter? RestParameter { get; }
    }

    /// <summary>
    /// Represents a parameter list of the form '(parameter: type)'.
    /// </summary>
    internal partial class TsParameterList : TsAstNode, ITsParameterList
    {
        public TsParameterList(
            ImmutableArray<ITsRequiredParameter> requiredParameters,
            ImmutableArray<ITsOptionalParameter> optionalParameters,
            ITsRestParameter? restParameter,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(requiredParameters, optionalParameters, restParameter);
            RequiredParameters = requiredParameters;
            OptionalParameters = optionalParameters;
            RestParameter = restParameter;
        }

        public ImmutableArray<ITsRequiredParameter> RequiredParameters { get; }
        public ImmutableArray<ITsOptionalParameter> OptionalParameters { get; }
        public ITsRestParameter? RestParameter { get; }

        partial void VerifyInputs(ImmutableArray<ITsRequiredParameter> requiredParameters, ImmutableArray<ITsOptionalParameter> optionalParameters, ITsRestParameter? restParameter);
        public override void Accept(TsVisitor visitor) => visitor.VisitParameterList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitParameterList(emitter, this);
    }

    public static class ParameterListExtensions
    {
        public static ITsParameterList WithRequiredParameters(this ITsParameterList node, ImmutableArray<ITsRequiredParameter> value) =>
            node.RequiredParameters == value ? node : new TsParameterList(value, node.OptionalParameters, node.RestParameter, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsParameterList WithOptionalParameters(this ITsParameterList node, ImmutableArray<ITsOptionalParameter> value) =>
            node.OptionalParameters == value ? node : new TsParameterList(node.RequiredParameters, value, node.RestParameter, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsParameterList WithRestParameter(this ITsParameterList node, ITsRestParameter? value) =>
            node.RestParameter == value ? node : new TsParameterList(node.RequiredParameters, node.OptionalParameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PatternBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    public interface ITsPatternBinding : ITsBindingElement
    {
        ITsBindingPattern BindingPattern { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    internal partial class TsPatternBinding : TsAstNode, ITsPatternBinding
    {
        public TsPatternBinding(
            ITsBindingPattern bindingPattern,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bindingPattern, initializer);
            BindingPattern = bindingPattern;
            Initializer = initializer;
        }

        public ITsBindingPattern BindingPattern { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsBindingPattern bindingPattern, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPatternBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPatternBinding(emitter, this);
    }

    public static class PatternBindingExtensions
    {
        public static ITsPatternBinding WithBindingPattern(this ITsPatternBinding node, ITsBindingPattern value) =>
            node.BindingPattern == value ? node : new TsPatternBinding(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPatternBinding WithInitializer(this ITsPatternBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsPatternBinding(node.BindingPattern, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyAssignment
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    public interface ITsPropertyAssignment : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    internal partial class TsPropertyAssignment : TsAstNode, ITsPropertyAssignment
    {
        public TsPropertyAssignment(
            ITsPropertyName propertyName,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, initializer);
            PropertyName = propertyName;
            Initializer = initializer;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyAssignment(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyAssignment(emitter, this);
    }

    public static class PropertyAssignmentExtensions
    {
        public static ITsPropertyAssignment WithPropertyName(this ITsPropertyAssignment node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyAssignment(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyAssignment WithInitializer(this ITsPropertyAssignment node, ITsExpression value) =>
            node.Initializer == value ? node : new TsPropertyAssignment(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single property name within an object literal.
    /// </summary>
    public interface ITsPropertyName : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// PropertyNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    public interface ITsPropertyNameBinding : ITsBindingProperty
    {
        ITsPropertyName PropertyName { get; }
        ITsBindingElement BindingElement { get; }
    }

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    internal partial class TsPropertyNameBinding : TsAstNode, ITsPropertyNameBinding
    {
        public TsPropertyNameBinding(
            ITsPropertyName propertyName,
            ITsBindingElement bindingElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, bindingElement);
            PropertyName = propertyName;
            BindingElement = bindingElement;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsBindingElement BindingElement { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsBindingElement bindingElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyNameBinding(emitter, this);
    }

    public static class PropertyNameBindingExtensions
    {
        public static ITsPropertyNameBinding WithPropertyName(this ITsPropertyNameBinding node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyNameBinding(value, node.BindingElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyNameBinding WithBindingElement(this ITsPropertyNameBinding node, ITsBindingElement value) =>
            node.BindingElement == value ? node : new TsPropertyNameBinding(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// QualifiedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a qualified name, which has dots between identifiers. For example, 'ns.type.method'.
    /// </summary>
    public interface ITsQualifiedName : ITsTypeName
    {
        ImmutableArray<ITsIdentifier> Left { get; }
        ITsIdentifier Right { get; }
    }

    /// <summary>
    /// Represents a qualified name, which has dots between identifiers. For example, 'ns.type.method'.
    /// </summary>
    internal partial class TsQualifiedName : TsAstNode, ITsQualifiedName
    {
        public TsQualifiedName(
            ImmutableArray<ITsIdentifier> left,
            ITsIdentifier right,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(left, right);
            Left = left;
            Right = right;
        }

        public ImmutableArray<ITsIdentifier> Left { get; }
        public ITsIdentifier Right { get; }

        partial void VerifyInputs(ImmutableArray<ITsIdentifier> left, ITsIdentifier right);
        public override void Accept(TsVisitor visitor) => visitor.VisitQualifiedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitQualifiedName(emitter, this);
    }

    public static class QualifiedNameExtensions
    {
        public static ITsQualifiedName WithLeft(this ITsQualifiedName node, ImmutableArray<ITsIdentifier> value) =>
            node.Left == value ? node : new TsQualifiedName(value, node.Right, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsQualifiedName WithRight(this ITsQualifiedName node, ITsIdentifier value) =>
            node.Right == value ? node : new TsQualifiedName(node.Left, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// RequiredParameter
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for a required parameter in a <see cref="ITsParameterList" />.
    /// </summary>
    public interface ITsRequiredParameter : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// RestParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a function parameter of the form '... parameterName: type'.
    /// </summary>
    public interface ITsRestParameter : ITsAstNode
    {
        ITsIdentifier ParameterName { get; }
        ITsType? ParameterType { get; }
    }

    /// <summary>
    /// Represents a function parameter of the form '... parameterName: type'.
    /// </summary>
    internal partial class TsRestParameter : TsAstNode, ITsRestParameter
    {
        public TsRestParameter(
            ITsIdentifier parameterName,
            ITsType? parameterType,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parameterName, parameterType);
            ParameterName = parameterName;
            ParameterType = parameterType;
        }

        public ITsIdentifier ParameterName { get; }
        public ITsType? ParameterType { get; }

        partial void VerifyInputs(ITsIdentifier parameterName, ITsType? parameterType);
        public override void Accept(TsVisitor visitor) => visitor.VisitRestParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitRestParameter(emitter, this);
    }

    public static class RestParameterExtensions
    {
        public static ITsRestParameter WithParameterName(this ITsRestParameter node, ITsIdentifier value) =>
            node.ParameterName == value ? node : new TsRestParameter(value, node.ParameterType, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsRestParameter WithParameterType(this ITsRestParameter node, ITsType? value) =>
            node.ParameterType == value ? node : new TsRestParameter(node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SingleNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    public interface ITsSingleNameBinding : ITsBindingProperty, ITsBindingElement
    {
        ITsIdentifier Name { get; }
        ITsExpression? DefaultValue { get; }
    }

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    internal partial class TsSingleNameBinding : TsAstNode, ITsSingleNameBinding
    {
        public TsSingleNameBinding(
            ITsIdentifier name,
            ITsExpression? defaultValue,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, defaultValue);
            Name = name;
            DefaultValue = defaultValue;
        }

        public ITsIdentifier Name { get; }
        public ITsExpression? DefaultValue { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsExpression? defaultValue);
        public override void Accept(TsVisitor visitor) => visitor.VisitSingleNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSingleNameBinding(emitter, this);
    }

    public static class SingleNameBindingExtensions
    {
        public static ITsSingleNameBinding WithName(this ITsSingleNameBinding node, ITsIdentifier value) =>
            node.Name == value ? node : new TsSingleNameBinding(value, node.DefaultValue, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSingleNameBinding WithDefaultValue(this ITsSingleNameBinding node, ITsExpression? value) =>
            node.DefaultValue == value ? node : new TsSingleNameBinding(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StatementListItem
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for items that can be part of a statement list.
    /// </summary>
    public interface ITsStatementListItem : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// StringOptionalParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents an optional function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    public interface ITsStringOptionalParameter : ITsOptionalParameter
    {
        ITsIdentifier ParameterName { get; }
        ITsStringLiteral StringLiteral { get; }
    }

    /// <summary>
    /// Represents an optional function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    internal partial class TsStringOptionalParameter : TsAstNode, ITsStringOptionalParameter
    {
        public TsStringOptionalParameter(
            ITsIdentifier parameterName,
            ITsStringLiteral stringLiteral,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parameterName, stringLiteral);
            ParameterName = parameterName;
            StringLiteral = stringLiteral;
        }

        public ITsIdentifier ParameterName { get; }
        public ITsStringLiteral StringLiteral { get; }

        partial void VerifyInputs(ITsIdentifier parameterName, ITsStringLiteral stringLiteral);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringOptionalParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringOptionalParameter(emitter, this);
    }

    public static class StringOptionalParameterExtensions
    {
        public static ITsStringOptionalParameter WithParameterName(this ITsStringOptionalParameter node, ITsIdentifier value) =>
            node.ParameterName == value ? node : new TsStringOptionalParameter(value, node.StringLiteral, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringOptionalParameter WithStringLiteral(this ITsStringOptionalParameter node, ITsStringLiteral value) =>
            node.StringLiteral == value ? node : new TsStringOptionalParameter(node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StringRequiredParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a required function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    public interface ITsStringRequiredParameter : ITsRequiredParameter
    {
        ITsIdentifier ParameterName { get; }
        ITsStringLiteral StringLiteral { get; }
    }

    /// <summary>
    /// Represents a required function parameter in the form <c>parameterName: 'stringLiteral'</c>.
    /// </summary>
    internal partial class TsStringRequiredParameter : TsAstNode, ITsStringRequiredParameter
    {
        public TsStringRequiredParameter(
            ITsIdentifier parameterName,
            ITsStringLiteral stringLiteral,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parameterName, stringLiteral);
            ParameterName = parameterName;
            StringLiteral = stringLiteral;
        }

        public ITsIdentifier ParameterName { get; }
        public ITsStringLiteral StringLiteral { get; }

        partial void VerifyInputs(ITsIdentifier parameterName, ITsStringLiteral stringLiteral);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringRequiredParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringRequiredParameter(emitter, this);
    }

    public static class StringRequiredParameterExtensions
    {
        public static ITsStringRequiredParameter WithParameterName(this ITsStringRequiredParameter node, ITsIdentifier value) =>
            node.ParameterName == value ? node : new TsStringRequiredParameter(value, node.StringLiteral, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringRequiredParameter WithStringLiteral(this ITsStringRequiredParameter node, ITsStringLiteral value) =>
            node.StringLiteral == value ? node : new TsStringRequiredParameter(node.ParameterName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplatePart
    //// ===============================================================================================================

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    public interface ITsTemplatePart : ITsAstNode
    {
        string Template { get; }
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    internal partial class TsTemplatePart : TsAstNode, ITsTemplatePart
    {
        public TsTemplatePart(
            string template,
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(template, expression);
            Template = template;
            Expression = expression;
        }

        public string Template { get; }
        public ITsExpression? Expression { get; }

        partial void VerifyInputs(string template, ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplatePart(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplatePart(emitter, this);
    }

    public static class TemplatePartExtensions
    {
        public static ITsTemplatePart WithTemplate(this ITsTemplatePart node, string value) =>
            node.Template == value ? node : new TsTemplatePart(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTemplatePart WithExpression(this ITsTemplatePart node, ITsExpression? value) =>
            node.Expression == value ? node : new TsTemplatePart(node.Template, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeParameter
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript type parameter, for example &lt;MyType extends MyBase&gt;.
    /// </summary>
    public interface ITsTypeParameter : ITsAstNode
    {
        ITsIdentifier TypeName { get; }
        ITsType? Constraint { get; }
    }

    /// <summary>
    /// Represents a TypeScript type parameter, for example &lt;MyType extends MyBase&gt;.
    /// </summary>
    internal partial class TsTypeParameter : TsAstNode, ITsTypeParameter
    {
        public TsTypeParameter(
            ITsIdentifier typeName,
            ITsType? constraint,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeName, constraint);
            TypeName = typeName;
            Constraint = constraint;
        }

        public ITsIdentifier TypeName { get; }
        public ITsType? Constraint { get; }

        partial void VerifyInputs(ITsIdentifier typeName, ITsType? constraint);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeParameter(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeParameter(emitter, this);
    }

    public static class TypeParameterExtensions
    {
        public static ITsTypeParameter WithTypeName(this ITsTypeParameter node, ITsIdentifier value) =>
            node.TypeName == value ? node : new TsTypeParameter(value, node.Constraint, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTypeParameter WithConstraint(this ITsTypeParameter node, ITsType? value) =>
            node.Constraint == value ? node : new TsTypeParameter(node.TypeName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeParameters
    //// ===============================================================================================================

    /// <summary>
    /// Represents a list of type parameters of the form '&lt;type, type&gt;'.
    /// </summary>
    public interface ITsTypeParameters : ITsAstNode
    {
        ImmutableArray<ITsTypeParameter> TypeParameters { get; }
    }

    /// <summary>
    /// Represents a list of type parameters of the form '&lt;type, type&gt;'.
    /// </summary>
    internal partial class TsTypeParameters : TsAstNode, ITsTypeParameters
    {
        public TsTypeParameters(
            ImmutableArray<ITsTypeParameter> typeParameters,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeParameters);
            TypeParameters = typeParameters;
        }

        public ImmutableArray<ITsTypeParameter> TypeParameters { get; }

        partial void VerifyInputs(ImmutableArray<ITsTypeParameter> typeParameters);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeParameters(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeParameters(emitter, this);
    }

    public static class TypeParametersExtensions
    {
        public static ITsTypeParameters WithTypeParameters(this ITsTypeParameters node, ImmutableArray<ITsTypeParameter> value) =>
            node.TypeParameters == value ? node : new TsTypeParameters(value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
