// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Declarations.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Declaration
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all declarations.
    /// </summary>
    public interface ITsDeclaration : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// LexicalDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    public interface ITsLexicalDeclaration : ITsDeclaration
    {
        bool IsConst { get; }
        ImmutableArray<ITsLexicalBinding> Declarations { get; }
    }

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    internal partial class TsLexicalDeclaration : TsAstNode, ITsLexicalDeclaration
    {
        public TsLexicalDeclaration(
            bool isConst,
            ImmutableArray<ITsLexicalBinding> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(isConst, declarations);
            IsConst = isConst;
            Declarations = declarations;
        }

        public bool IsConst { get; }
        public ImmutableArray<ITsLexicalBinding> Declarations { get; }

        partial void VerifyInputs(bool isConst, ImmutableArray<ITsLexicalBinding> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitLexicalDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitLexicalDeclaration(emitter, this);
    }

    public static class LexicalDeclarationExtensions
    {
        public static ITsLexicalDeclaration WithIsConst(this ITsLexicalDeclaration node, bool value) =>
            node.IsConst == value ? node : new TsLexicalDeclaration(value, node.Declarations, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLexicalDeclaration WithDeclarations(this ITsLexicalDeclaration node, ImmutableArray<ITsLexicalBinding> value) =>
            node.Declarations == value ? node : new TsLexicalDeclaration(node.IsConst, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
