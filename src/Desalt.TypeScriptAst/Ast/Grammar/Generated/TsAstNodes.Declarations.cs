// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.Declarations.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Declaration
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all declarations.
    /// </summary>
    public interface ITsDeclaration : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// LexicalDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    public interface ITsLexicalDeclaration : ITsDeclaration
    {
        bool IsConst { get; }
        ImmutableArray<ITsLexicalBinding> Declarations { get; }
    }

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    internal partial class TsLexicalDeclaration : TsAstNode, ITsLexicalDeclaration
    {
        public TsLexicalDeclaration(
            bool isConst,
            ImmutableArray<ITsLexicalBinding> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(isConst, declarations);
            IsConst = isConst;
            Declarations = declarations;
        }

        public bool IsConst { get; }
        public ImmutableArray<ITsLexicalBinding> Declarations { get; }

        partial void VerifyInputs(bool isConst, ImmutableArray<ITsLexicalBinding> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitLexicalDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitLexicalDeclaration(emitter, this);
    }

    public static class LexicalDeclarationExtensions
    {
        public static ITsLexicalDeclaration WithIsConst(this ITsLexicalDeclaration node, bool value) =>
            node.IsConst == value ? node : new TsLexicalDeclaration(value, node.Declarations, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLexicalDeclaration WithDeclarations(this ITsLexicalDeclaration node, ImmutableArray<ITsLexicalBinding> value) =>
            node.Declarations == value ? node : new TsLexicalDeclaration(node.IsConst, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TypeAliasDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents a type alias of the form 'type alias&lt;T&gt; = type'.
    /// </summary>
    public interface ITsTypeAliasDeclaration : ITsDeclaration
    {
        ITsIdentifier AliasName { get; }
        ITsTypeParameters? TypeParameters { get; }
        ITsType Type { get; }
    }

    /// <summary>
    /// Represents a type alias of the form 'type alias&lt;T&gt; = type'.
    /// </summary>
    internal partial class TsTypeAliasDeclaration : TsAstNode, ITsTypeAliasDeclaration
    {
        public TsTypeAliasDeclaration(
            ITsIdentifier aliasName,
            ITsTypeParameters? typeParameters,
            ITsType type,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(aliasName, typeParameters, type);
            AliasName = aliasName;
            TypeParameters = typeParameters;
            Type = type;
        }

        public ITsIdentifier AliasName { get; }
        public ITsTypeParameters? TypeParameters { get; }
        public ITsType Type { get; }

        partial void VerifyInputs(ITsIdentifier aliasName, ITsTypeParameters? typeParameters, ITsType type);
        public override void Accept(TsVisitor visitor) => visitor.VisitTypeAliasDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTypeAliasDeclaration(emitter, this);
    }

    public static class TypeAliasDeclarationExtensions
    {
        public static ITsTypeAliasDeclaration WithAliasName(this ITsTypeAliasDeclaration node, ITsIdentifier value) =>
            node.AliasName == value ? node : new TsTypeAliasDeclaration(value, node.TypeParameters, node.Type, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTypeAliasDeclaration WithTypeParameters(this ITsTypeAliasDeclaration node, ITsTypeParameters? value) =>
            node.TypeParameters == value ? node : new TsTypeAliasDeclaration(node.AliasName, value, node.Type, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTypeAliasDeclaration WithType(this ITsTypeAliasDeclaration node, ITsType value) =>
            node.Type == value ? node : new TsTypeAliasDeclaration(node.AliasName, node.TypeParameters, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
