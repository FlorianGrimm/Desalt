<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#+
    public const string GeneratedDirectoryName = "Generated";

    public string RootOutputDirectory => Path.Combine(Path.GetDirectoryName(Host.TemplateFile), GeneratedDirectoryName);
    public string TemplateFileName => Path.GetFileName(Host.TemplateFile);
    public string OutputFileName => Path.ChangeExtension(TemplateFileName, ".cs");

    private static readonly XNamespace Xmlns = "https://github.com/jrockwood/Desalt/GrammarSchema.xsd";
    private static readonly string SingleIndent = new string(' ', 4);
    private static readonly string DoubleIndent = new string(' ', 8);
    private static readonly string TripleIndent = new string(' ', 12);

    public void SaveToFile(string fileName)
    {
        Directory.CreateDirectory(RootOutputDirectory);
        string filePath = Path.Combine(RootOutputDirectory, fileName);
        File.WriteAllText(filePath, GenerationEnvironment.ToString());
        GenerationEnvironment.Clear();
    }

    public IReadOnlyList<AstNodeDefinition> GatherAstDefinitions()
    {
        return GatherDefinitions<AstNodeDefinition>("AstNode");
    }

    public IReadOnlyList<TriviaNodeDefinition> GatherTriviaDefinitions()
    {
        return GatherDefinitions<TriviaNodeDefinition>("TriviaNode");
    }

    private IReadOnlyList<T> GatherDefinitions<T>(string nodeNameToGather) where T : NodeDefinition
    {
        string grammarPath = Host.ResolvePath(@"TypeScriptGrammar.xml");
        XDocument doc = XDocument.Load(grammarPath);

        var definitions = new List<T>();

        var triviaDefinitions = doc.Root.Descendants(Xmlns + nodeNameToGather).Select(ParseNode).Cast<T>();
        definitions.AddRange(triviaDefinitions);

        return definitions;
    }

    public void WriteEnumDeclarations(AstNodeDefinition node)
    {
        PushIndent(SingleIndent);

        foreach (var enumDefinition in node.Enums)
        {
            WriteLine($"public enum {enumDefinition.Name}");
            WriteLine("{");
            PushIndent(SingleIndent);

            foreach (var value in enumDefinition.Values)
            {
                WriteLine($"{value},");
            }

            PopIndent();
            WriteLine("}");
        }

        PopIndent();

        if (node.Enums.Any())
        {
            WriteLine("");
        }
    }

    public void WriteProperties(NodeDefinition node, bool isInterface)
    {
        if (!node.HasProperties && !node.HasTokens)
        {
            return;
        }

        if (!isInterface)
        {
            WriteLine("");
        }

        PushIndent(DoubleIndent);

        foreach (var property in isInterface ? node.InterfaceProperties : node.Properties)
        {
            if (property.Comment != null)
            {
                WriteLine("/// <summary>");
                WriteLine("/// " + property.Comment);
                WriteLine("/// </summary>");
            }

            if (!isInterface)
            {
                Write("public ");
            }

            WriteLine($"{property.Type} {property.Name} {{ get; }}");
        }

        // Write out the tokens if we're an AstNodeDefinition.
        if (node is AstNodeDefinition astNode && node.HasTokens)
        {
            foreach (var property in astNode.Tokens)
            {
                if (property.Comment != null)
                {
                    WriteLine("/// <summary>");
                    WriteLine("/// " + property.Comment);
                    WriteLine("/// </summary>");
                }

                WriteLine($"public {property.Type} {property.Name} {{ get; }}");
            }
        }

        PopIndent();
    }

    public void WriteCtorAssignments(NodeDefinition node, bool skipVerifyInputs = false)
    {
        var astNode = node as AstNodeDefinition;

        PushIndent(TripleIndent);

        if (!skipVerifyInputs)
        {
            WriteLine($"VerifyInputs({node.ToPropertyList(noTypes: true)});");

            // Verify the token nodes if we're an AstNodeDefinition.
            if (astNode != null && astNode.HasTokens)
            {
                WriteLine("");

                foreach (var tokenNode in astNode.Tokens)
                {
                    var token = $"{tokenNode.TsTokenName}.Token";

                    if (tokenNode.IsOptional)
                    {
                        WriteLine($"if ({tokenNode.ArgumentName} != null && {tokenNode.ArgumentName}.Token != {token})");
                    }
                    else
                    {
                        WriteLine($"{tokenNode.ArgumentName} ??= {tokenNode.TsTokenName};");
                        WriteLine($"if ({tokenNode.ArgumentName}.Token != {token})");
                    }

                    WriteLine("{");
                    WriteLine($"{SingleIndent}throw new ArgumentException($\"Token must be '{{{token}}}'.\", nameof({tokenNode.ArgumentName}));");
                    WriteLine("}");
                    WriteLine("");
                }
            }
        }

        foreach (var property in node.Properties)
        {
            WriteLine($"{property.Name} = {property.ArgumentName};");
        }

        if (astNode != null)
        {
            foreach (var token in astNode.Tokens)
            {
                WriteLine($"{token.Name} = {token.ArgumentName};");
            }
        }

        PopIndent();
    }

    public void WriteWithExtensionMethods(NodeDefinition node)
    {
        var propsAndTokens = node.PropertiesAndTokens.ToArray();

        if (!propsAndTokens.Any())
        {
            return;
        }

        WriteLine("");

        PushIndent(SingleIndent);

        WriteLine($"public static class {node.Name}Extensions");
        WriteLine("{");
        PushIndent(SingleIndent);

        for (int i = 0; i < propsAndTokens.Length; i++)
        {
            var property = propsAndTokens[i];
            WriteWithExtensionMethod(node, property.Name, property.Type, skipLeadingNewline: i == 0);
        }

        PopIndent();
        WriteLine("}");

        PopIndent();
    }

    private void WriteWithExtensionMethod(
        NodeDefinition node,
        string propertyName,
        string propertyType,
        bool skipLeadingNewline = false)
    {
        if (!skipLeadingNewline)
        {
            WriteLine("");
        }

        WriteLine($"public static {node.InterfaceName} With{propertyName}(this {node.InterfaceName} node, {propertyType} value) =>");
        PushIndent(SingleIndent);
        Write($"node.{propertyName} == value ? node : new {node.ClassName}(");

        foreach (var prop in node.PropertiesAndTokens)
        {
            if (prop.Name == propertyName)
            {
                Write("value, ");
            }
            else
            {
                Write($"node.{prop.Name}, ");
            }
        }

        // Write the trivia node arguments.
        if (node is AstNodeDefinition)
        {
            Write(propertyName == "LeadingTrivia" ? "value, " : "node.LeadingTrivia, ");
            Write(propertyName == "TrailingTrivia" ? "value" : "node.TrailingTrivia");
        }
        else
        {
            Write("node.PreserveSpacing");
        }

        WriteLine(");");

        PopIndent();
    }

    private static readonly ISet<string> s_csharpKeywords = new HashSet<string>
    {
        "operator"
    };

    private static string SafeArgumentName(string name)
    {
        string argumentName = char.ToLowerInvariant(name[0]) + name.Substring(1);

        if (s_csharpKeywords.Contains(argumentName))
        {
            argumentName = "@" + argumentName;
        }

        return argumentName;
    }

    private static NodeDefinition ParseNode(XElement node)
    {
        string name = (string)node.Attribute("name");
        string comment = (string)node.Element(Xmlns + "Comment") ?? string.Empty;

        string rawBaseInterfaces = (string)node.Attribute("baseInterfaces");
        string baseInterfaces = string.Join(", ", rawBaseInterfaces.Split(',').Select(s => s.Trim()));

        bool isInterfaceOnly = ((bool?)node.Attribute("interfaceOnly")) ?? false;

        var properties = new List<PropertyDefinition>();
        foreach (var propertyNode in node.Descendants(Xmlns + "Property"))
        {
            string propertyName = (string)propertyNode.Attribute("name");
            string propertyType = (string)propertyNode.Attribute("type");
            string propertyComment = (string)propertyNode.Element(Xmlns + "Comment");
            bool declaredInBaseInterface = ((bool?)propertyNode.Attribute("declaredInBaseInterface")).GetValueOrDefault();

            var propertyDefinition =
                new PropertyDefinition(propertyName, propertyType, propertyComment, declaredInBaseInterface);
            properties.Add(propertyDefinition);
        }

        var enums = new List<EnumDefinition>();
        foreach (var enumNode in node.Descendants(Xmlns + "Enum"))
        {
            string enumName = (string)enumNode.Attribute("name");
            var enumValues = enumNode.Descendants(Xmlns + "EnumValue").Select(x => (string)x.Attribute("name")).ToList();
            var enumDefinition = new EnumDefinition(enumName, enumValues);
            enums.Add(enumDefinition);
        }

        var tokens = new List<TokenDefinition>();
        foreach (var tokenNode in node.Descendants(Xmlns + "Token"))
        {
            string tokenName = (string)tokenNode.Attribute("name");
            string tokenComment = (string)tokenNode.Element(Xmlns + "Comment");
            bool isOptional = ((bool?)tokenNode.Attribute("isOptional")).GetValueOrDefault();

            var tokenDefinition = new TokenDefinition(tokenName, tokenComment, isOptional);
            tokens.Add(tokenDefinition);
        }

        if (node.Name.LocalName == "TriviaNode")
        {
            return new TriviaNodeDefinition(name)
            {
                Comment = comment,
                BaseClassName = "TsAstTriviaNode",
                BaseInterfaces = baseInterfaces,
                Enums = enums,
                IsInterfaceOnly = isInterfaceOnly,
                Properties = properties,
            };
        }

        return new AstNodeDefinition(name)
        {
            Comment = comment,
            BaseClassName = "TsAstNode",
            BaseInterfaces = baseInterfaces,
            Enums = enums,
            IsInterfaceOnly = isInterfaceOnly,
            Properties = properties,
            Tokens = tokens,
        };
    }

    public abstract class NodeDefinition
    {
        protected NodeDefinition(string name)
        {
            Name = name;
        }

        // Read-only Properties
        public string Name { get; }

        // Writable Properties
        public string BaseClassName { get; set; }
        public string Comment { get; set; }
        public string BaseInterfaces { get; set; }
        public IList<EnumDefinition> Enums { get; set; } = new List<EnumDefinition>();
        public bool IsInterfaceOnly { get; set; }
        public IList<PropertyDefinition> Properties { get; set; } = new List<PropertyDefinition>();
        public IList<TokenDefinition> Tokens { get; set; } = new List<TokenDefinition>();

        // Computed Properties
        public string ArgumentName => SafeArgumentName(Name);
        public IEnumerable<string> BaseInterfaceList => BaseInterfaces.Split(',').Select(s => s.Trim());
        public string ClassName => "Ts" + Name;
        public string EmitImplementation => $"TsAstEmitter.Emit{Name}(emitter, this)";
        public bool HasProperties => Properties.Any();
        public bool HasTokens => Tokens.Any();
        public string InterfaceName => "ITs" + Name;

        public IEnumerable<PropertyDefinition> InterfaceProperties =>
            Properties.Where(prop => !prop.DeclaredInBaseInterface);

        public IEnumerable<IProperty> PropertiesAndTokens => Properties.Cast<IProperty>().Concat(Tokens);

        public string ToPropertyList(
            bool includeTriviaParams = false,
            bool multipleLines = false,
            bool noTypes = false,
            bool prefixComma = false,
            bool useNameInsteadOfArgumentName = false)
        {
            string indent = TripleIndent;

            var builder = new StringBuilder();

            for (int i = 0; i < Properties.Count; i++)
            {
                var property = Properties[i];

                if (i == 0)
                {
                    if (prefixComma && multipleLines)
                    {
                        builder.AppendLine(",");
                    }
                    else if (prefixComma && !multipleLines)
                    {
                        builder.Append(", ");
                    }

                    if (multipleLines)
                    {
                        builder.AppendLine().Append(indent);
                    }
                }
                else
                {
                    if (multipleLines)
                    {
                        builder.AppendLine(",").Append(indent);
                    }
                    else
                    {
                        builder.Append(", ");
                    }
                }

                if (!noTypes)
                {
                    builder.Append(property.Type).Append(" ");
                }

                builder.Append(useNameInsteadOfArgumentName ? property.Name : property.ArgumentName);
            }

            // Add the base class argumnets.
            if (includeTriviaParams)
            {
                if (Properties.Count > 0)
                {
                    builder.Append(",");
                }

                builder.AppendLine().Append(indent).Append("ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null");
                builder.AppendLine(",").Append(indent).Append("ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null");
            }

            return builder.ToString();
        }
    }

    public sealed class TriviaNodeDefinition : NodeDefinition
    {
        public TriviaNodeDefinition(string name)
            : base(name)
        {
        }

        public string ConstructorParameters =>
            string.Join("", Properties.Select(prop => $"{prop.Type} {prop.ArgumentName}, ")) + "bool preserveSpacing";
    }

    public sealed class AstNodeDefinition : NodeDefinition
    {
        public AstNodeDefinition(string name)
            : base(name)
        {
        }

        public string ConstructorParameters
        {
            get
            {
                string prefix = Environment.NewLine + TripleIndent;
                var builder = new StringBuilder();

                // Add the "normal" parameters.
                builder.Append(string.Join("", Properties.Select(prop => $"{prefix}{prop.Type} {prop.ArgumentName},")));

                // Add the token parameters as optional parameters.
                builder.Append(string.Join("", Tokens.Select(token => $"{prefix}{token.OptionalType} {token.ArgumentName} = null,")));

                // Add the trivia nodes.
                builder.Append($"{prefix}ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,");
                builder.Append($"{prefix}ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null");

                return builder.ToString();
            }
        }

        public string ShallowCopyImplementation
        {
            get
            {
                var builder = new StringBuilder();
                builder.Append($"new {ClassName}(");
                builder.Append(string.Join("", PropertiesAndTokens.Select(prop => $"{prop.Name}, ")));
                builder.Append("leadingTrivia, trailingTrivia)");

                return builder.ToString();
            }
        }
    }

    public interface IProperty
    {
        public string Name { get; }
        public string ArgumentName { get; }
        public string Type { get; }
        public string Comment { get; }
    }

    public sealed class PropertyDefinition : IProperty
    {
        public PropertyDefinition(string name, string type, string comment, bool declaredInBaseInterface)
        {
            Name = name;
            Type = type;
            Comment = comment;
            DeclaredInBaseInterface = declaredInBaseInterface;
        }

        public string Name { get; }
        public string ArgumentName => SafeArgumentName(Name);

        public string Type { get; }
        public string Comment { get; }
        public bool DeclaredInBaseInterface { get; }
    }

    public sealed class TokenDefinition : IProperty
    {
        public TokenDefinition(string name, string comment, bool isOptional)
        {
            Name = name;
            Comment = comment;
            IsOptional = isOptional;
        }

        public string Name { get; }
        public bool IsOptional { get;
        }
        public string ArgumentName => SafeArgumentName(Name);
        public string Type => IsOptional ? "ITsTokenNode?" : "ITsTokenNode";
        public string OptionalType => "ITsTokenNode?";
        public string Comment { get; }

        public string TsTokenName => $"TsTokenNode.{Name}";
    }

    public sealed class EnumDefinition
    {
        public EnumDefinition(string name, IEnumerable<string> values = null)
        {
            Name = name;
            Values = values?.ToList() ?? new List<string>();
        }

        public string Name { get; }
        public IList<string> Values { get; }
    }
#>
