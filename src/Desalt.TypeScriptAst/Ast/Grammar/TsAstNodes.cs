
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Identifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    public interface ITsIdentifier : ITsTypeName, ITsPropertyDefinition, ITsLiteralPropertyName, ITsBindingIdentifierOrPattern
    {
        string Text { get; }
    }

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    internal partial class TsIdentifier : TsAstNode, ITsIdentifier
    {
        public TsIdentifier(
            string text,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(text);
            Text = text;
        }

        public string Text { get; }

        partial void VerifyInputs(string text);
        public override void Accept(TsVisitor visitor) => visitor.VisitIdentifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIdentifier(emitter, this);
    }

    public static class IdentifierExtensions
    {
        public static ITsIdentifier WithText(this ITsIdentifier node, string value) =>
            node.Text == value ? node : new TsIdentifier(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// This
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'this' expression.
    /// </summary>
    public interface ITsThis : ITsExpression
    {
    }

    /// <summary>
    /// Represents the 'this' expression.
    /// </summary>
    internal partial class TsThis : TsAstNode, ITsThis
    {
        public TsThis(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitThis(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitThis(emitter, this);
    }

    //// ===============================================================================================================
    //// ParenthesizedExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a parenthesized expression, of the form '(expression)'.
    /// </summary>
    public interface ITsParenthesizedExpression : ITsExpression
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a parenthesized expression, of the form '(expression)'.
    /// </summary>
    internal partial class TsParenthesizedExpression : TsAstNode, ITsParenthesizedExpression
    {
        public TsParenthesizedExpression(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitParenthesizedExpression(emitter, this);
    }

    public static class ParenthesizedExpressionExtensions
    {
        public static ITsParenthesizedExpression WithExpression(this ITsParenthesizedExpression node, ITsExpression value) =>
            node.Expression == value ? node : new TsParenthesizedExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NullLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'null' literal expression.
    /// </summary>
    public interface ITsNullLiteral : ITsExpression
    {
    }

    /// <summary>
    /// Represents the 'null' literal expression.
    /// </summary>
    internal partial class TsNullLiteral : TsAstNode, ITsNullLiteral
    {
        public TsNullLiteral(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitNullLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNullLiteral(emitter, this);
    }

    //// ===============================================================================================================
    //// BooleanLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a boolean literal expression (either 'true' or 'false').
    /// </summary>
    public interface ITsBooleanLiteral : ITsExpression
    {
        bool Value { get; }
    }

    /// <summary>
    /// Represents a boolean literal expression (either 'true' or 'false').
    /// </summary>
    internal partial class TsBooleanLiteral : TsAstNode, ITsBooleanLiteral
    {
        public TsBooleanLiteral(
            bool value,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value);
            Value = value;
        }

        public bool Value { get; }

        partial void VerifyInputs(bool value);
        public override void Accept(TsVisitor visitor) => visitor.VisitBooleanLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBooleanLiteral(emitter, this);
    }

    public static class BooleanLiteralExtensions
    {
        public static ITsBooleanLiteral WithValue(this ITsBooleanLiteral node, bool value) =>
            node.Value == value ? node : new TsBooleanLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NumericLiteral
    //// ===============================================================================================================

    public enum TsNumericLiteralKind
    {
        Decimal,
        BinaryInteger,
        OctalInteger,
        HexInteger,
    }

    /// <summary>
    /// Represents an expression containing a numeric literal value.
    /// </summary>
    public interface ITsNumericLiteral : ITsExpression, ITsLiteralPropertyName
    {
        double Value { get; }
        TsNumericLiteralKind Kind { get; }
    }

    /// <summary>
    /// Represents an expression containing a numeric literal value.
    /// </summary>
    internal partial class TsNumericLiteral : TsAstNode, ITsNumericLiteral
    {
        public TsNumericLiteral(
            double value,
            TsNumericLiteralKind kind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value, kind);
            Value = value;
            Kind = kind;
        }

        public double Value { get; }
        public TsNumericLiteralKind Kind { get; }

        partial void VerifyInputs(double value, TsNumericLiteralKind kind);
        public override void Accept(TsVisitor visitor) => visitor.VisitNumericLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNumericLiteral(emitter, this);
    }

    public static class NumericLiteralExtensions
    {
        public static ITsNumericLiteral WithValue(this ITsNumericLiteral node, double value) =>
            node.Value == value ? node : new TsNumericLiteral(value, node.Kind, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsNumericLiteral WithKind(this ITsNumericLiteral node, TsNumericLiteralKind value) =>
            node.Kind == value ? node : new TsNumericLiteral(node.Value, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StringLiteral
    //// ===============================================================================================================

    public enum StringLiteralQuoteKind
    {
        DoubleQuote,
        SingleQuote,
    }

    /// <summary>
    /// Represents a string literal of the form 'string' or "string".
    /// </summary>
    public interface ITsStringLiteral : ITsExpression, ITsLiteralPropertyName
    {
        string Value { get; }
        StringLiteralQuoteKind QuoteKind { get; }
    }

    /// <summary>
    /// Represents a string literal of the form 'string' or "string".
    /// </summary>
    internal partial class TsStringLiteral : TsAstNode, ITsStringLiteral
    {
        public TsStringLiteral(
            string value,
            StringLiteralQuoteKind quoteKind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value, quoteKind);
            Value = value;
            QuoteKind = quoteKind;
        }

        public string Value { get; }
        public StringLiteralQuoteKind QuoteKind { get; }

        partial void VerifyInputs(string value, StringLiteralQuoteKind quoteKind);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringLiteral(emitter, this);
    }

    public static class StringLiteralExtensions
    {
        public static ITsStringLiteral WithValue(this ITsStringLiteral node, string value) =>
            node.Value == value ? node : new TsStringLiteral(value, node.QuoteKind, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringLiteral WithQuoteKind(this ITsStringLiteral node, StringLiteralQuoteKind value) =>
            node.QuoteKind == value ? node : new TsStringLiteral(node.Value, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// RegularExpressionLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a regular expression literal of the form '/body/flags'.
    /// </summary>
    public interface ITsRegularExpressionLiteral : ITsExpression
    {
        string Body { get; }
        string? Flags { get; }
    }

    /// <summary>
    /// Represents a regular expression literal of the form '/body/flags'.
    /// </summary>
    internal partial class TsRegularExpressionLiteral : TsAstNode, ITsRegularExpressionLiteral
    {
        public TsRegularExpressionLiteral(
            string body,
            string? flags,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(body, flags);
            Body = body;
            Flags = flags;
        }

        public string Body { get; }
        public string? Flags { get; }

        partial void VerifyInputs(string body, string? flags);
        public override void Accept(TsVisitor visitor) => visitor.VisitRegularExpressionLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitRegularExpressionLiteral(emitter, this);
    }

    public static class RegularExpressionLiteralExtensions
    {
        public static ITsRegularExpressionLiteral WithBody(this ITsRegularExpressionLiteral node, string value) =>
            node.Body == value ? node : new TsRegularExpressionLiteral(value, node.Flags, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsRegularExpressionLiteral WithFlags(this ITsRegularExpressionLiteral node, string? value) =>
            node.Flags == value ? node : new TsRegularExpressionLiteral(node.Body, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array literal of the form '[element...]'.
    /// </summary>
    public interface ITsArrayLiteral : ITsExpression
    {
        ImmutableArray<ITsArrayElement?> Elements { get; }
    }

    /// <summary>
    /// Represents an array literal of the form '[element...]'.
    /// </summary>
    internal partial class TsArrayLiteral : TsAstNode, ITsArrayLiteral
    {
        public TsArrayLiteral(
            ImmutableArray<ITsArrayElement?> elements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements);
            Elements = elements;
        }

        public ImmutableArray<ITsArrayElement?> Elements { get; }

        partial void VerifyInputs(ImmutableArray<ITsArrayElement?> elements);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayLiteral(emitter, this);
    }

    public static class ArrayLiteralExtensions
    {
        public static ITsArrayLiteral WithElements(this ITsArrayLiteral node, ImmutableArray<ITsArrayElement?> value) =>
            node.Elements == value ? node : new TsArrayLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    public interface ITsArrayElement : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadElement { get; }
    }

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    internal partial class TsArrayElement : TsAstNode, ITsArrayElement
    {
        public TsArrayElement(
            ITsExpression expression,
            bool isSpreadElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadElement);
            Expression = expression;
            IsSpreadElement = isSpreadElement;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadElement { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayElement(emitter, this);
    }

    public static class ArrayElementExtensions
    {
        public static ITsArrayElement WithExpression(this ITsArrayElement node, ITsExpression value) =>
            node.Expression == value ? node : new TsArrayElement(value, node.IsSpreadElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayElement WithIsSpreadElement(this ITsArrayElement node, bool value) =>
            node.IsSpreadElement == value ? node : new TsArrayElement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ObjectLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents on object literal of the form '{ PropertyDefinition... }'.
    /// </summary>
    public interface ITsObjectLiteral : ITsExpression
    {
        ImmutableArray<ITsPropertyDefinition> PropertyDefinitions { get; }
    }

    /// <summary>
    /// Represents on object literal of the form '{ PropertyDefinition... }'.
    /// </summary>
    internal partial class TsObjectLiteral : TsAstNode, ITsObjectLiteral
    {
        public TsObjectLiteral(
            ImmutableArray<ITsPropertyDefinition> propertyDefinitions,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyDefinitions);
            PropertyDefinitions = propertyDefinitions;
        }

        public ImmutableArray<ITsPropertyDefinition> PropertyDefinitions { get; }

        partial void VerifyInputs(ImmutableArray<ITsPropertyDefinition> propertyDefinitions);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectLiteral(emitter, this);
    }

    public static class ObjectLiteralExtensions
    {
        public static ITsObjectLiteral WithPropertyDefinitions(this ITsObjectLiteral node, ImmutableArray<ITsPropertyDefinition> value) =>
            node.PropertyDefinitions == value ? node : new TsObjectLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyDefinition
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property definition within an object literal.
    /// </summary>
    public interface ITsPropertyDefinition : ITsExpression
    {
    }

    //// ===============================================================================================================
    //// CoverInitializedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    public interface ITsCoverInitializedName : ITsPropertyDefinition
    {
        ITsIdentifier Identifier { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    internal partial class TsCoverInitializedName : TsAstNode, ITsCoverInitializedName
    {
        public TsCoverInitializedName(
            ITsIdentifier identifier,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(identifier, initializer);
            Identifier = identifier;
            Initializer = initializer;
        }

        public ITsIdentifier Identifier { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsIdentifier identifier, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitCoverInitializedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCoverInitializedName(emitter, this);
    }

    public static class CoverInitializedNameExtensions
    {
        public static ITsCoverInitializedName WithIdentifier(this ITsCoverInitializedName node, ITsIdentifier value) =>
            node.Identifier == value ? node : new TsCoverInitializedName(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCoverInitializedName WithInitializer(this ITsCoverInitializedName node, ITsExpression value) =>
            node.Initializer == value ? node : new TsCoverInitializedName(node.Identifier, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyAssignment
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    public interface ITsPropertyAssignment : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    internal partial class TsPropertyAssignment : TsAstNode, ITsPropertyAssignment
    {
        public TsPropertyAssignment(
            ITsPropertyName propertyName,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, initializer);
            PropertyName = propertyName;
            Initializer = initializer;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyAssignment(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyAssignment(emitter, this);
    }

    public static class PropertyAssignmentExtensions
    {
        public static ITsPropertyAssignment WithPropertyName(this ITsPropertyAssignment node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyAssignment(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyAssignment WithInitializer(this ITsPropertyAssignment node, ITsExpression value) =>
            node.Initializer == value ? node : new TsPropertyAssignment(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single property name within an object literal.
    /// </summary>
    public interface ITsPropertyName : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// LiteralPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name within an object literal, which can be an identifier, string literal, or a numeric literal.
    /// </summary>
    public interface ITsLiteralPropertyName : ITsPropertyName
    {
    }

    //// ===============================================================================================================
    //// ComputedPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    public interface ITsComputedPropertyName : ITsPropertyName
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    internal partial class TsComputedPropertyName : TsAstNode, ITsComputedPropertyName
    {
        public TsComputedPropertyName(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitComputedPropertyName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitComputedPropertyName(emitter, this);
    }

    public static class ComputedPropertyNameExtensions
    {
        public static ITsComputedPropertyName WithExpression(this ITsComputedPropertyName node, ITsExpression value) =>
            node.Expression == value ? node : new TsComputedPropertyName(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplatePart
    //// ===============================================================================================================

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    public interface ITsTemplatePart : ITsAstNode
    {
        string Template { get; }
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    internal partial class TsTemplatePart : TsAstNode, ITsTemplatePart
    {
        public TsTemplatePart(
            string template,
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(template, expression);
            Template = template;
            Expression = expression;
        }

        public string Template { get; }
        public ITsExpression? Expression { get; }

        partial void VerifyInputs(string template, ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplatePart(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplatePart(emitter, this);
    }

    public static class TemplatePartExtensions
    {
        public static ITsTemplatePart WithTemplate(this ITsTemplatePart node, string value) =>
            node.Template == value ? node : new TsTemplatePart(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTemplatePart WithExpression(this ITsTemplatePart node, ITsExpression? value) =>
            node.Expression == value ? node : new TsTemplatePart(node.Template, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplateLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a template string literal.
    /// </summary>
    public interface ITsTemplateLiteral : ITsExpression
    {
        ImmutableArray<ITsTemplatePart> Parts { get; }
    }

    /// <summary>
    /// Represents a template string literal.
    /// </summary>
    internal partial class TsTemplateLiteral : TsAstNode, ITsTemplateLiteral
    {
        public TsTemplateLiteral(
            ImmutableArray<ITsTemplatePart> parts,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parts);
            Parts = parts;
        }

        public ImmutableArray<ITsTemplatePart> Parts { get; }

        partial void VerifyInputs(ImmutableArray<ITsTemplatePart> parts);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplateLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplateLiteral(emitter, this);
    }

    public static class TemplateLiteralExtensions
    {
        public static ITsTemplateLiteral WithParts(this ITsTemplateLiteral node, ImmutableArray<ITsTemplatePart> value) =>
            node.Parts == value ? node : new TsTemplateLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MemberBracketExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'expression[expression]'.
    /// </summary>
    public interface ITsMemberBracketExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsExpression BracketContents { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'expression[expression]'.
    /// </summary>
    internal partial class TsMemberBracketExpression : TsAstNode, ITsMemberBracketExpression
    {
        public TsMemberBracketExpression(
            ITsExpression leftSide,
            ITsExpression bracketContents,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, bracketContents);
            LeftSide = leftSide;
            BracketContents = bracketContents;
        }

        public ITsExpression LeftSide { get; }
        public ITsExpression BracketContents { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsExpression bracketContents);
        public override void Accept(TsVisitor visitor) => visitor.VisitMemberBracketExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberBracketExpression(emitter, this);
    }

    public static class MemberBracketExpressionExtensions
    {
        public static ITsMemberBracketExpression WithLeftSide(this ITsMemberBracketExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsMemberBracketExpression(value, node.BracketContents, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMemberBracketExpression WithBracketContents(this ITsMemberBracketExpression node, ITsExpression value) =>
            node.BracketContents == value ? node : new TsMemberBracketExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MemberDotExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'expression.name'.
    /// </summary>
    public interface ITsMemberDotExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        string DotName { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'expression.name'.
    /// </summary>
    internal partial class TsMemberDotExpression : TsAstNode, ITsMemberDotExpression
    {
        public TsMemberDotExpression(
            ITsExpression leftSide,
            string dotName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, dotName);
            LeftSide = leftSide;
            DotName = dotName;
        }

        public ITsExpression LeftSide { get; }
        public string DotName { get; }

        partial void VerifyInputs(ITsExpression leftSide, string dotName);
        public override void Accept(TsVisitor visitor) => visitor.VisitMemberDotExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberDotExpression(emitter, this);
    }

    public static class MemberDotExpressionExtensions
    {
        public static ITsMemberDotExpression WithLeftSide(this ITsMemberDotExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsMemberDotExpression(value, node.DotName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMemberDotExpression WithDotName(this ITsMemberDotExpression node, string value) =>
            node.DotName == value ? node : new TsMemberDotExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperBracketExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'super[expression]'.
    /// </summary>
    public interface ITsSuperBracketExpression : ITsExpression
    {
        ITsExpression BracketContents { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'super[expression]'.
    /// </summary>
    internal partial class TsSuperBracketExpression : TsAstNode, ITsSuperBracketExpression
    {
        public TsSuperBracketExpression(
            ITsExpression bracketContents,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bracketContents);
            BracketContents = bracketContents;
        }

        public ITsExpression BracketContents { get; }

        partial void VerifyInputs(ITsExpression bracketContents);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperBracketExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperBracketExpression(emitter, this);
    }

    public static class SuperBracketExpressionExtensions
    {
        public static ITsSuperBracketExpression WithBracketContents(this ITsSuperBracketExpression node, ITsExpression value) =>
            node.BracketContents == value ? node : new TsSuperBracketExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperDotExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'super.name'.
    /// </summary>
    public interface ITsSuperDotExpression : ITsExpression
    {
        string DotName { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'super.name'.
    /// </summary>
    internal partial class TsSuperDotExpression : TsAstNode, ITsSuperDotExpression
    {
        public TsSuperDotExpression(
            string dotName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(dotName);
            DotName = dotName;
        }

        public string DotName { get; }

        partial void VerifyInputs(string dotName);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperDotExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperDotExpression(emitter, this);
    }

    public static class SuperDotExpressionExtensions
    {
        public static ITsSuperDotExpression WithDotName(this ITsSuperDotExpression node, string value) =>
            node.DotName == value ? node : new TsSuperDotExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NewTargetExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression of the form 'new.target'.
    /// </summary>
    public interface ITsNewTargetExpression : ITsExpression
    {
    }

    /// <summary>
    /// Represents an expression of the form 'new.target'.
    /// </summary>
    internal partial class TsNewTargetExpression : TsAstNode, ITsNewTargetExpression
    {
        public TsNewTargetExpression(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitNewTargetExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNewTargetExpression(emitter, this);
    }

    //// ===============================================================================================================
    //// CallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'expression(arguments)'.
    /// </summary>
    public interface ITsCallExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'expression(arguments)'.
    /// </summary>
    internal partial class TsCallExpression : TsAstNode, ITsCallExpression
    {
        public TsCallExpression(
            ITsExpression leftSide,
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, argumentList);
            LeftSide = leftSide;
            ArgumentList = argumentList;
        }

        public ITsExpression LeftSide { get; }
        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCallExpression(emitter, this);
    }

    public static class CallExpressionExtensions
    {
        public static ITsCallExpression WithLeftSide(this ITsCallExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsCallExpression(value, node.ArgumentList, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCallExpression WithArgumentList(this ITsCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsCallExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NewCallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'new expression(arguments)'.
    /// </summary>
    public interface ITsNewCallExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'new expression(arguments)'.
    /// </summary>
    internal partial class TsNewCallExpression : TsAstNode, ITsNewCallExpression
    {
        public TsNewCallExpression(
            ITsExpression leftSide,
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, argumentList);
            LeftSide = leftSide;
            ArgumentList = argumentList;
        }

        public ITsExpression LeftSide { get; }
        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitNewCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNewCallExpression(emitter, this);
    }

    public static class NewCallExpressionExtensions
    {
        public static ITsNewCallExpression WithLeftSide(this ITsNewCallExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsNewCallExpression(value, node.ArgumentList, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsNewCallExpression WithArgumentList(this ITsNewCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsNewCallExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperCallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'super(arguments)'.
    /// </summary>
    public interface ITsSuperCallExpression : ITsExpression
    {
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'super(arguments)'.
    /// </summary>
    internal partial class TsSuperCallExpression : TsAstNode, ITsSuperCallExpression
    {
        public TsSuperCallExpression(
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(argumentList);
            ArgumentList = argumentList;
        }

        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperCallExpression(emitter, this);
    }

    public static class SuperCallExpressionExtensions
    {
        public static ITsSuperCallExpression WithArgumentList(this ITsSuperCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsSuperCallExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArgumentList
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    public interface ITsArgumentList : ITsAstNode
    {
        ImmutableArray<ITsType> TypeArguments { get; }
        ImmutableArray<ITsArgument> Arguments { get; }
    }

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    internal partial class TsArgumentList : TsAstNode, ITsArgumentList
    {
        public TsArgumentList(
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsArgument> arguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeArguments, arguments);
            TypeArguments = typeArguments;
            Arguments = arguments;
        }

        public ImmutableArray<ITsType> TypeArguments { get; }
        public ImmutableArray<ITsArgument> Arguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> typeArguments, ImmutableArray<ITsArgument> arguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgumentList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgumentList(emitter, this);
    }

    public static class ArgumentListExtensions
    {
        public static ITsArgumentList WithTypeArguments(this ITsArgumentList node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsArgumentList(value, node.Arguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgumentList WithArguments(this ITsArgumentList node, ImmutableArray<ITsArgument> value) =>
            node.Arguments == value ? node : new TsArgumentList(node.TypeArguments, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Argument
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    public interface ITsArgument : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadArgument { get; }
    }

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    internal partial class TsArgument : TsAstNode, ITsArgument
    {
        public TsArgument(
            ITsExpression expression,
            bool isSpreadArgument,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadArgument);
            Expression = expression;
            IsSpreadArgument = isSpreadArgument;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadArgument { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadArgument);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgument(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgument(emitter, this);
    }

    public static class ArgumentExtensions
    {
        public static ITsArgument WithExpression(this ITsArgument node, ITsExpression value) =>
            node.Expression == value ? node : new TsArgument(value, node.IsSpreadArgument, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgument WithIsSpreadArgument(this ITsArgument node, bool value) =>
            node.IsSpreadArgument == value ? node : new TsArgument(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// UnaryExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a unary expression.
    /// </summary>
    public interface ITsUnaryExpression : ITsExpression
    {
        ITsExpression Operand { get; }
        TsUnaryOperator Operator { get; }
    }

    /// <summary>
    /// Represents a unary expression.
    /// </summary>
    internal partial class TsUnaryExpression : TsAstNode, ITsUnaryExpression
    {
        public TsUnaryExpression(
            ITsExpression operand,
            TsUnaryOperator @operator,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(operand, @operator);
            Operand = operand;
            Operator = @operator;
        }

        public ITsExpression Operand { get; }
        public TsUnaryOperator Operator { get; }

        partial void VerifyInputs(ITsExpression operand, TsUnaryOperator @operator);
        public override void Accept(TsVisitor visitor) => visitor.VisitUnaryExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitUnaryExpression(emitter, this);
    }

    public static class UnaryExpressionExtensions
    {
        public static ITsUnaryExpression WithOperand(this ITsUnaryExpression node, ITsExpression value) =>
            node.Operand == value ? node : new TsUnaryExpression(value, node.Operator, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsUnaryExpression WithOperator(this ITsUnaryExpression node, TsUnaryOperator value) =>
            node.Operator == value ? node : new TsUnaryExpression(node.Operand, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CastExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a unary cast expression of the form, '&lt;Type&gt;expression'.
    /// </summary>
    public interface ITsCastExpression : ITsExpression
    {
        ITsType CastType { get; }
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a unary cast expression of the form, '&lt;Type&gt;expression'.
    /// </summary>
    internal partial class TsCastExpression : TsAstNode, ITsCastExpression
    {
        public TsCastExpression(
            ITsType castType,
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(castType, expression);
            CastType = castType;
            Expression = expression;
        }

        public ITsType CastType { get; }
        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsType castType, ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitCastExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCastExpression(emitter, this);
    }

    public static class CastExpressionExtensions
    {
        public static ITsCastExpression WithCastType(this ITsCastExpression node, ITsType value) =>
            node.CastType == value ? node : new TsCastExpression(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCastExpression WithExpression(this ITsCastExpression node, ITsExpression value) =>
            node.Expression == value ? node : new TsCastExpression(node.CastType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BinaryExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a binary expression.
    /// </summary>
    public interface ITsBinaryExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        TsBinaryOperator Operator { get; }
        ITsExpression RightSide { get; }
    }

    /// <summary>
    /// Represents a binary expression.
    /// </summary>
    internal partial class TsBinaryExpression : TsAstNode, ITsBinaryExpression
    {
        public TsBinaryExpression(
            ITsExpression leftSide,
            TsBinaryOperator @operator,
            ITsExpression rightSide,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, @operator, rightSide);
            LeftSide = leftSide;
            Operator = @operator;
            RightSide = rightSide;
        }

        public ITsExpression LeftSide { get; }
        public TsBinaryOperator Operator { get; }
        public ITsExpression RightSide { get; }

        partial void VerifyInputs(ITsExpression leftSide, TsBinaryOperator @operator, ITsExpression rightSide);
        public override void Accept(TsVisitor visitor) => visitor.VisitBinaryExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBinaryExpression(emitter, this);
    }

    public static class BinaryExpressionExtensions
    {
        public static ITsBinaryExpression WithLeftSide(this ITsBinaryExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsBinaryExpression(value, node.Operator, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBinaryExpression WithOperator(this ITsBinaryExpression node, TsBinaryOperator value) =>
            node.Operator == value ? node : new TsBinaryExpression(node.LeftSide, value, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBinaryExpression WithRightSide(this ITsBinaryExpression node, ITsExpression value) =>
            node.RightSide == value ? node : new TsBinaryExpression(node.LeftSide, node.Operator, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ConditionalExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a conditional expression of the form 'x ? y : z'.
    /// </summary>
    public interface ITsConditionalExpression : ITsExpression
    {
        ITsExpression Condition { get; }
        ITsExpression WhenTrue { get; }
        ITsExpression WhenFalse { get; }
    }

    /// <summary>
    /// Represents a conditional expression of the form 'x ? y : z'.
    /// </summary>
    internal partial class TsConditionalExpression : TsAstNode, ITsConditionalExpression
    {
        public TsConditionalExpression(
            ITsExpression condition,
            ITsExpression whenTrue,
            ITsExpression whenFalse,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(condition, whenTrue, whenFalse);
            Condition = condition;
            WhenTrue = whenTrue;
            WhenFalse = whenFalse;
        }

        public ITsExpression Condition { get; }
        public ITsExpression WhenTrue { get; }
        public ITsExpression WhenFalse { get; }

        partial void VerifyInputs(ITsExpression condition, ITsExpression whenTrue, ITsExpression whenFalse);
        public override void Accept(TsVisitor visitor) => visitor.VisitConditionalExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitConditionalExpression(emitter, this);
    }

    public static class ConditionalExpressionExtensions
    {
        public static ITsConditionalExpression WithCondition(this ITsConditionalExpression node, ITsExpression value) =>
            node.Condition == value ? node : new TsConditionalExpression(value, node.WhenTrue, node.WhenFalse, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConditionalExpression WithWhenTrue(this ITsConditionalExpression node, ITsExpression value) =>
            node.WhenTrue == value ? node : new TsConditionalExpression(node.Condition, value, node.WhenFalse, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConditionalExpression WithWhenFalse(this ITsConditionalExpression node, ITsExpression value) =>
            node.WhenFalse == value ? node : new TsConditionalExpression(node.Condition, node.WhenTrue, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// AssignmentExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an assignment of the form 'left == right'.
    /// </summary>
    public interface ITsAssignmentExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        TsAssignmentOperator Operator { get; }
        ITsExpression RightSide { get; }
    }

    /// <summary>
    /// Represents an assignment of the form 'left == right'.
    /// </summary>
    internal partial class TsAssignmentExpression : TsAstNode, ITsAssignmentExpression
    {
        public TsAssignmentExpression(
            ITsExpression leftSide,
            TsAssignmentOperator @operator,
            ITsExpression rightSide,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, @operator, rightSide);
            LeftSide = leftSide;
            Operator = @operator;
            RightSide = rightSide;
        }

        public ITsExpression LeftSide { get; }
        public TsAssignmentOperator Operator { get; }
        public ITsExpression RightSide { get; }

        partial void VerifyInputs(ITsExpression leftSide, TsAssignmentOperator @operator, ITsExpression rightSide);
        public override void Accept(TsVisitor visitor) => visitor.VisitAssignmentExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitAssignmentExpression(emitter, this);
    }

    public static class AssignmentExpressionExtensions
    {
        public static ITsAssignmentExpression WithLeftSide(this ITsAssignmentExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsAssignmentExpression(value, node.Operator, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAssignmentExpression WithOperator(this ITsAssignmentExpression node, TsAssignmentOperator value) =>
            node.Operator == value ? node : new TsAssignmentExpression(node.LeftSide, value, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAssignmentExpression WithRightSide(this ITsAssignmentExpression node, ITsExpression value) =>
            node.RightSide == value ? node : new TsAssignmentExpression(node.LeftSide, node.Operator, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Expression
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all expressions.
    /// </summary>
    public interface ITsExpression : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// CommaExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression list separated by commas. Useful in for loops for the initializer or incrementor, for example.
    /// </summary>
    public interface ITsCommaExpression : ITsExpression
    {
        ImmutableArray<ITsExpression> Expressions { get; }
    }

    /// <summary>
    /// Represents an expression list separated by commas. Useful in for loops for the initializer or incrementor, for example.
    /// </summary>
    internal partial class TsCommaExpression : TsAstNode, ITsCommaExpression
    {
        public TsCommaExpression(
            ImmutableArray<ITsExpression> expressions,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expressions);
            Expressions = expressions;
        }

        public ImmutableArray<ITsExpression> Expressions { get; }

        partial void VerifyInputs(ImmutableArray<ITsExpression> expressions);
        public override void Accept(TsVisitor visitor) => visitor.VisitCommaExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCommaExpression(emitter, this);
    }

    public static class CommaExpressionExtensions
    {
        public static ITsCommaExpression WithExpressions(this ITsCommaExpression node, ImmutableArray<ITsExpression> value) =>
            node.Expressions == value ? node : new TsCommaExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Statement
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all statements.
    /// </summary>
    public interface ITsStatement : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// Declaration
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all declarations.
    /// </summary>
    public interface ITsDeclaration : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// BlockStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a block statement of the form '{ statements }'.
    /// </summary>
    public interface ITsBlockStatement : ITsStatement
    {
        ImmutableArray<ITsStatementListItem> Statements { get; }
    }

    /// <summary>
    /// Represents a block statement of the form '{ statements }'.
    /// </summary>
    internal partial class TsBlockStatement : TsAstNode, ITsBlockStatement
    {
        public TsBlockStatement(
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitBlockStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBlockStatement(emitter, this);
    }

    public static class BlockStatementExtensions
    {
        public static ITsBlockStatement WithStatements(this ITsBlockStatement node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsBlockStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StatementListItem
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for items that can be part of a statement list.
    /// </summary>
    public interface ITsStatementListItem : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// LexicalDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    public interface ITsLexicalDeclaration : ITsDeclaration
    {
        bool IsConst { get; }
        ImmutableArray<ITsLexicalBinding> Declarations { get; }
    }

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    internal partial class TsLexicalDeclaration : TsAstNode, ITsLexicalDeclaration
    {
        public TsLexicalDeclaration(
            bool isConst,
            ImmutableArray<ITsLexicalBinding> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(isConst, declarations);
            IsConst = isConst;
            Declarations = declarations;
        }

        public bool IsConst { get; }
        public ImmutableArray<ITsLexicalBinding> Declarations { get; }

        partial void VerifyInputs(bool isConst, ImmutableArray<ITsLexicalBinding> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitLexicalDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitLexicalDeclaration(emitter, this);
    }

    public static class LexicalDeclarationExtensions
    {
        public static ITsLexicalDeclaration WithIsConst(this ITsLexicalDeclaration node, bool value) =>
            node.IsConst == value ? node : new TsLexicalDeclaration(value, node.Declarations, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLexicalDeclaration WithDeclarations(this ITsLexicalDeclaration node, ImmutableArray<ITsLexicalBinding> value) =>
            node.Declarations == value ? node : new TsLexicalDeclaration(node.IsConst, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// VariableStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a variable declaration statement of the form 'var x = y;'.
    /// </summary>
    public interface ITsVariableStatement : ITsStatement
    {
        ImmutableArray<ITsVariableDeclaration> Declarations { get; }
    }

    /// <summary>
    /// Represents a variable declaration statement of the form 'var x = y;'.
    /// </summary>
    internal partial class TsVariableStatement : TsAstNode, ITsVariableStatement
    {
        public TsVariableStatement(
            ImmutableArray<ITsVariableDeclaration> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(declarations);
            Declarations = declarations;
        }

        public ImmutableArray<ITsVariableDeclaration> Declarations { get; }

        partial void VerifyInputs(ImmutableArray<ITsVariableDeclaration> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitVariableStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitVariableStatement(emitter, this);
    }

    public static class VariableStatementExtensions
    {
        public static ITsVariableStatement WithDeclarations(this ITsVariableStatement node, ImmutableArray<ITsVariableDeclaration> value) =>
            node.Declarations == value ? node : new TsVariableStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for a binding pattern.
    /// </summary>
    public interface ITsBindingPattern : ITsBindingIdentifierOrPattern
    {
    }

    //// ===============================================================================================================
    //// ObjectBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    public interface ITsObjectBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingProperty> Properties { get; }
    }

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    internal partial class TsObjectBindingPattern : TsAstNode, ITsObjectBindingPattern
    {
        public TsObjectBindingPattern(
            ImmutableArray<ITsBindingProperty> properties,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(properties);
            Properties = properties;
        }

        public ImmutableArray<ITsBindingProperty> Properties { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingProperty> properties);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectBindingPattern(emitter, this);
    }

    public static class ObjectBindingPatternExtensions
    {
        public static ITsObjectBindingPattern WithProperties(this ITsObjectBindingPattern node, ImmutableArray<ITsBindingProperty> value) =>
            node.Properties == value ? node : new TsObjectBindingPattern(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    public interface ITsArrayBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingElement?> Elements { get; }
        ITsIdentifier? RestElement { get; }
    }

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    internal partial class TsArrayBindingPattern : TsAstNode, ITsArrayBindingPattern
    {
        public TsArrayBindingPattern(
            ImmutableArray<ITsBindingElement?> elements,
            ITsIdentifier? restElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements, restElement);
            Elements = elements;
            RestElement = restElement;
        }

        public ImmutableArray<ITsBindingElement?> Elements { get; }
        public ITsIdentifier? RestElement { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingElement?> elements, ITsIdentifier? restElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayBindingPattern(emitter, this);
    }

    public static class ArrayBindingPatternExtensions
    {
        public static ITsArrayBindingPattern WithElements(this ITsArrayBindingPattern node, ImmutableArray<ITsBindingElement?> value) =>
            node.Elements == value ? node : new TsArrayBindingPattern(value, node.RestElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayBindingPattern WithRestElement(this ITsArrayBindingPattern node, ITsIdentifier? value) =>
            node.RestElement == value ? node : new TsArrayBindingPattern(node.Elements, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingProperty
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for properties that are bound in array or object initializers.
    /// </summary>
    public interface ITsBindingProperty : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// SingleNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    public interface ITsSingleNameBinding : ITsBindingProperty, ITsBindingElement
    {
        ITsIdentifier Name { get; }
        ITsExpression? DefaultValue { get; }
    }

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    internal partial class TsSingleNameBinding : TsAstNode, ITsSingleNameBinding
    {
        public TsSingleNameBinding(
            ITsIdentifier name,
            ITsExpression? defaultValue,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, defaultValue);
            Name = name;
            DefaultValue = defaultValue;
        }

        public ITsIdentifier Name { get; }
        public ITsExpression? DefaultValue { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsExpression? defaultValue);
        public override void Accept(TsVisitor visitor) => visitor.VisitSingleNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSingleNameBinding(emitter, this);
    }

    public static class SingleNameBindingExtensions
    {
        public static ITsSingleNameBinding WithName(this ITsSingleNameBinding node, ITsIdentifier value) =>
            node.Name == value ? node : new TsSingleNameBinding(value, node.DefaultValue, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSingleNameBinding WithDefaultValue(this ITsSingleNameBinding node, ITsExpression? value) =>
            node.DefaultValue == value ? node : new TsSingleNameBinding(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    public interface ITsPropertyNameBinding : ITsBindingProperty
    {
        ITsPropertyName PropertyName { get; }
        ITsBindingElement BindingElement { get; }
    }

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    internal partial class TsPropertyNameBinding : TsAstNode, ITsPropertyNameBinding
    {
        public TsPropertyNameBinding(
            ITsPropertyName propertyName,
            ITsBindingElement bindingElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, bindingElement);
            PropertyName = propertyName;
            BindingElement = bindingElement;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsBindingElement BindingElement { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsBindingElement bindingElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyNameBinding(emitter, this);
    }

    public static class PropertyNameBindingExtensions
    {
        public static ITsPropertyNameBinding WithPropertyName(this ITsPropertyNameBinding node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyNameBinding(value, node.BindingElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyNameBinding WithBindingElement(this ITsPropertyNameBinding node, ITsBindingElement value) =>
            node.BindingElement == value ? node : new TsPropertyNameBinding(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingElement
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for binding elements in object and array bindings.
    /// </summary>
    public interface ITsBindingElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// PatternBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    public interface ITsPatternBinding : ITsBindingElement
    {
        ITsBindingPattern BindingPattern { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    internal partial class TsPatternBinding : TsAstNode, ITsPatternBinding
    {
        public TsPatternBinding(
            ITsBindingPattern bindingPattern,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bindingPattern, initializer);
            BindingPattern = bindingPattern;
            Initializer = initializer;
        }

        public ITsBindingPattern BindingPattern { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsBindingPattern bindingPattern, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPatternBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPatternBinding(emitter, this);
    }

    public static class PatternBindingExtensions
    {
        public static ITsPatternBinding WithBindingPattern(this ITsPatternBinding node, ITsBindingPattern value) =>
            node.BindingPattern == value ? node : new TsPatternBinding(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPatternBinding WithInitializer(this ITsPatternBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsPatternBinding(node.BindingPattern, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// EmptyStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an empty statement.
    /// </summary>
    public interface ITsEmptyStatement : ITsStatement
    {
    }

    /// <summary>
    /// Represents an empty statement.
    /// </summary>
    internal partial class TsEmptyStatement : TsAstNode, ITsEmptyStatement
    {
        public TsEmptyStatement(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitEmptyStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitEmptyStatement(emitter, this);
    }

    //// ===============================================================================================================
    //// ExpressionStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression in statement form.
    /// </summary>
    public interface ITsExpressionStatement : ITsStatement
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents an expression in statement form.
    /// </summary>
    internal partial class TsExpressionStatement : TsAstNode, ITsExpressionStatement
    {
        public TsExpressionStatement(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitExpressionStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitExpressionStatement(emitter, this);
    }

    public static class ExpressionStatementExtensions
    {
        public static ITsExpressionStatement WithExpression(this ITsExpressionStatement node, ITsExpression value) =>
            node.Expression == value ? node : new TsExpressionStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// IfStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an 'if' statement of the form 'if (expression) statement else statement'.
    /// </summary>
    public interface ITsIfStatement : ITsStatement
    {
        ITsExpression IfCondition { get; }
        ITsStatement IfStatement { get; }
        ITsStatement? ElseStatement { get; }
    }

    /// <summary>
    /// Represents an 'if' statement of the form 'if (expression) statement else statement'.
    /// </summary>
    internal partial class TsIfStatement : TsAstNode, ITsIfStatement
    {
        public TsIfStatement(
            ITsExpression ifCondition,
            ITsStatement ifStatement,
            ITsStatement? elseStatement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(ifCondition, ifStatement, elseStatement);
            IfCondition = ifCondition;
            IfStatement = ifStatement;
            ElseStatement = elseStatement;
        }

        public ITsExpression IfCondition { get; }
        public ITsStatement IfStatement { get; }
        public ITsStatement? ElseStatement { get; }

        partial void VerifyInputs(ITsExpression ifCondition, ITsStatement ifStatement, ITsStatement? elseStatement);
        public override void Accept(TsVisitor visitor) => visitor.VisitIfStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIfStatement(emitter, this);
    }

    public static class IfStatementExtensions
    {
        public static ITsIfStatement WithIfCondition(this ITsIfStatement node, ITsExpression value) =>
            node.IfCondition == value ? node : new TsIfStatement(value, node.IfStatement, node.ElseStatement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsIfStatement WithIfStatement(this ITsIfStatement node, ITsStatement value) =>
            node.IfStatement == value ? node : new TsIfStatement(node.IfCondition, value, node.ElseStatement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsIfStatement WithElseStatement(this ITsIfStatement node, ITsStatement? value) =>
            node.ElseStatement == value ? node : new TsIfStatement(node.IfCondition, node.IfStatement, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DoWhileStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a do/while statement.
    /// </summary>
    public interface ITsDoWhileStatement : ITsStatement
    {
        ITsStatement DoStatement { get; }
        ITsExpression WhileCondition { get; }
    }

    /// <summary>
    /// Represents a do/while statement.
    /// </summary>
    internal partial class TsDoWhileStatement : TsAstNode, ITsDoWhileStatement
    {
        public TsDoWhileStatement(
            ITsStatement doStatement,
            ITsExpression whileCondition,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(doStatement, whileCondition);
            DoStatement = doStatement;
            WhileCondition = whileCondition;
        }

        public ITsStatement DoStatement { get; }
        public ITsExpression WhileCondition { get; }

        partial void VerifyInputs(ITsStatement doStatement, ITsExpression whileCondition);
        public override void Accept(TsVisitor visitor) => visitor.VisitDoWhileStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDoWhileStatement(emitter, this);
    }

    public static class DoWhileStatementExtensions
    {
        public static ITsDoWhileStatement WithDoStatement(this ITsDoWhileStatement node, ITsStatement value) =>
            node.DoStatement == value ? node : new TsDoWhileStatement(value, node.WhileCondition, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsDoWhileStatement WithWhileCondition(this ITsDoWhileStatement node, ITsExpression value) =>
            node.WhileCondition == value ? node : new TsDoWhileStatement(node.DoStatement, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// WhileStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a while loop.
    /// </summary>
    public interface ITsWhileStatement : ITsStatement
    {
        ITsExpression WhileCondition { get; }
        ITsStatement WhileStatement { get; }
    }

    /// <summary>
    /// Represents a while loop.
    /// </summary>
    internal partial class TsWhileStatement : TsAstNode, ITsWhileStatement
    {
        public TsWhileStatement(
            ITsExpression whileCondition,
            ITsStatement whileStatement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(whileCondition, whileStatement);
            WhileCondition = whileCondition;
            WhileStatement = whileStatement;
        }

        public ITsExpression WhileCondition { get; }
        public ITsStatement WhileStatement { get; }

        partial void VerifyInputs(ITsExpression whileCondition, ITsStatement whileStatement);
        public override void Accept(TsVisitor visitor) => visitor.VisitWhileStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitWhileStatement(emitter, this);
    }

    public static class WhileStatementExtensions
    {
        public static ITsWhileStatement WithWhileCondition(this ITsWhileStatement node, ITsExpression value) =>
            node.WhileCondition == value ? node : new TsWhileStatement(value, node.WhileStatement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsWhileStatement WithWhileStatement(this ITsWhileStatement node, ITsStatement value) =>
            node.WhileStatement == value ? node : new TsWhileStatement(node.WhileCondition, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ForStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'for' loop.
    /// </summary>
    public interface ITsForStatement : ITsStatement
    {
        ITsExpression? Initializer { get; }
        ImmutableArray<ITsVariableDeclaration>? InitializerWithVariableDeclarations { get; }
        ITsLexicalDeclaration? InitializerWithLexicalDeclaration { get; }
        ITsExpression? Condition { get; }
        ITsExpression? Incrementor { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a 'for' loop.
    /// </summary>
    internal partial class TsForStatement : TsAstNode, ITsForStatement
    {
        public TsForStatement(
            ITsExpression? initializer,
            ImmutableArray<ITsVariableDeclaration>? initializerWithVariableDeclarations,
            ITsLexicalDeclaration? initializerWithLexicalDeclaration,
            ITsExpression? condition,
            ITsExpression? incrementor,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(initializer, initializerWithVariableDeclarations, initializerWithLexicalDeclaration, condition, incrementor, statement);
            Initializer = initializer;
            InitializerWithVariableDeclarations = initializerWithVariableDeclarations;
            InitializerWithLexicalDeclaration = initializerWithLexicalDeclaration;
            Condition = condition;
            Incrementor = incrementor;
            Statement = statement;
        }

        public ITsExpression? Initializer { get; }
        public ImmutableArray<ITsVariableDeclaration>? InitializerWithVariableDeclarations { get; }
        public ITsLexicalDeclaration? InitializerWithLexicalDeclaration { get; }
        public ITsExpression? Condition { get; }
        public ITsExpression? Incrementor { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression? initializer, ImmutableArray<ITsVariableDeclaration>? initializerWithVariableDeclarations, ITsLexicalDeclaration? initializerWithLexicalDeclaration, ITsExpression? condition, ITsExpression? incrementor, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitForStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitForStatement(emitter, this);
    }

    public static class ForStatementExtensions
    {
        public static ITsForStatement WithInitializer(this ITsForStatement node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsForStatement(value, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, node.Condition, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithInitializerWithVariableDeclarations(this ITsForStatement node, ImmutableArray<ITsVariableDeclaration>? value) =>
            node.InitializerWithVariableDeclarations == value ? node : new TsForStatement(node.Initializer, value, node.InitializerWithLexicalDeclaration, node.Condition, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithInitializerWithLexicalDeclaration(this ITsForStatement node, ITsLexicalDeclaration? value) =>
            node.InitializerWithLexicalDeclaration == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, value, node.Condition, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithCondition(this ITsForStatement node, ITsExpression? value) =>
            node.Condition == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, value, node.Incrementor, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithIncrementor(this ITsForStatement node, ITsExpression? value) =>
            node.Incrementor == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, node.Condition, value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForStatement WithStatement(this ITsForStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsForStatement(node.Initializer, node.InitializerWithVariableDeclarations, node.InitializerWithLexicalDeclaration, node.Condition, node.Incrementor, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ForInStatement
    //// ===============================================================================================================

    public enum VariableDeclarationKind
    {
        Var,
        Let,
        Const,
    }

    /// <summary>
    /// Represents a for-in loop of the form 'for (const x: type in expression) statement'.
    /// </summary>
    public interface ITsForInStatement : ITsStatement
    {
        ITsExpression? Initializer { get; }
        VariableDeclarationKind? DeclarationKind { get; }
        ITsBindingIdentifierOrPattern? Declaration { get; }
        ITsExpression RightSide { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a for-in loop of the form 'for (const x: type in expression) statement'.
    /// </summary>
    internal partial class TsForInStatement : TsAstNode, ITsForInStatement
    {
        public TsForInStatement(
            ITsExpression? initializer,
            VariableDeclarationKind? declarationKind,
            ITsBindingIdentifierOrPattern? declaration,
            ITsExpression rightSide,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(initializer, declarationKind, declaration, rightSide, statement);
            Initializer = initializer;
            DeclarationKind = declarationKind;
            Declaration = declaration;
            RightSide = rightSide;
            Statement = statement;
        }

        public ITsExpression? Initializer { get; }
        public VariableDeclarationKind? DeclarationKind { get; }
        public ITsBindingIdentifierOrPattern? Declaration { get; }
        public ITsExpression RightSide { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression? initializer, VariableDeclarationKind? declarationKind, ITsBindingIdentifierOrPattern? declaration, ITsExpression rightSide, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitForInStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitForInStatement(emitter, this);
    }

    public static class ForInStatementExtensions
    {
        public static ITsForInStatement WithInitializer(this ITsForInStatement node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsForInStatement(value, node.DeclarationKind, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithDeclarationKind(this ITsForInStatement node, VariableDeclarationKind? value) =>
            node.DeclarationKind == value ? node : new TsForInStatement(node.Initializer, value, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithDeclaration(this ITsForInStatement node, ITsBindingIdentifierOrPattern? value) =>
            node.Declaration == value ? node : new TsForInStatement(node.Initializer, node.DeclarationKind, value, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithRightSide(this ITsForInStatement node, ITsExpression value) =>
            node.RightSide == value ? node : new TsForInStatement(node.Initializer, node.DeclarationKind, node.Declaration, value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForInStatement WithStatement(this ITsForInStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsForInStatement(node.Initializer, node.DeclarationKind, node.Declaration, node.RightSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ForOfStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a for-of loop of the form 'for (const x: type of expression) statement'.
    /// </summary>
    public interface ITsForOfStatement : ITsStatement
    {
        ITsExpression? Initializer { get; }
        VariableDeclarationKind? DeclarationKind { get; }
        ITsBindingIdentifierOrPattern? Declaration { get; }
        ITsExpression RightSide { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a for-of loop of the form 'for (const x: type of expression) statement'.
    /// </summary>
    internal partial class TsForOfStatement : TsAstNode, ITsForOfStatement
    {
        public TsForOfStatement(
            ITsExpression? initializer,
            VariableDeclarationKind? declarationKind,
            ITsBindingIdentifierOrPattern? declaration,
            ITsExpression rightSide,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(initializer, declarationKind, declaration, rightSide, statement);
            Initializer = initializer;
            DeclarationKind = declarationKind;
            Declaration = declaration;
            RightSide = rightSide;
            Statement = statement;
        }

        public ITsExpression? Initializer { get; }
        public VariableDeclarationKind? DeclarationKind { get; }
        public ITsBindingIdentifierOrPattern? Declaration { get; }
        public ITsExpression RightSide { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression? initializer, VariableDeclarationKind? declarationKind, ITsBindingIdentifierOrPattern? declaration, ITsExpression rightSide, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitForOfStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitForOfStatement(emitter, this);
    }

    public static class ForOfStatementExtensions
    {
        public static ITsForOfStatement WithInitializer(this ITsForOfStatement node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsForOfStatement(value, node.DeclarationKind, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithDeclarationKind(this ITsForOfStatement node, VariableDeclarationKind? value) =>
            node.DeclarationKind == value ? node : new TsForOfStatement(node.Initializer, value, node.Declaration, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithDeclaration(this ITsForOfStatement node, ITsBindingIdentifierOrPattern? value) =>
            node.Declaration == value ? node : new TsForOfStatement(node.Initializer, node.DeclarationKind, value, node.RightSide, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithRightSide(this ITsForOfStatement node, ITsExpression value) =>
            node.RightSide == value ? node : new TsForOfStatement(node.Initializer, node.DeclarationKind, node.Declaration, value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsForOfStatement WithStatement(this ITsForOfStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsForOfStatement(node.Initializer, node.DeclarationKind, node.Declaration, node.RightSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ContinueStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a continue statement of the form, 'continue [label]'.
    /// </summary>
    public interface ITsContinueStatement : ITsStatement
    {
        ITsIdentifier? Label { get; }
    }

    /// <summary>
    /// Represents a continue statement of the form, 'continue [label]'.
    /// </summary>
    internal partial class TsContinueStatement : TsAstNode, ITsContinueStatement
    {
        public TsContinueStatement(
            ITsIdentifier? label,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(label);
            Label = label;
        }

        public ITsIdentifier? Label { get; }

        partial void VerifyInputs(ITsIdentifier? label);
        public override void Accept(TsVisitor visitor) => visitor.VisitContinueStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitContinueStatement(emitter, this);
    }

    public static class ContinueStatementExtensions
    {
        public static ITsContinueStatement WithLabel(this ITsContinueStatement node, ITsIdentifier? value) =>
            node.Label == value ? node : new TsContinueStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BreakStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a break statement of the form, 'break [label]'.
    /// </summary>
    public interface ITsBreakStatement : ITsStatement
    {
        ITsIdentifier? Label { get; }
    }

    /// <summary>
    /// Represents a break statement of the form, 'break [label]'.
    /// </summary>
    internal partial class TsBreakStatement : TsAstNode, ITsBreakStatement
    {
        public TsBreakStatement(
            ITsIdentifier? label,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(label);
            Label = label;
        }

        public ITsIdentifier? Label { get; }

        partial void VerifyInputs(ITsIdentifier? label);
        public override void Accept(TsVisitor visitor) => visitor.VisitBreakStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBreakStatement(emitter, this);
    }

    public static class BreakStatementExtensions
    {
        public static ITsBreakStatement WithLabel(this ITsBreakStatement node, ITsIdentifier? value) =>
            node.Label == value ? node : new TsBreakStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ReturnStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'return' statement.
    /// </summary>
    public interface ITsReturnStatement : ITsStatement
    {
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a 'return' statement.
    /// </summary>
    internal partial class TsReturnStatement : TsAstNode, ITsReturnStatement
    {
        public TsReturnStatement(
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression? Expression { get; }

        partial void VerifyInputs(ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitReturnStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitReturnStatement(emitter, this);
    }

    public static class ReturnStatementExtensions
    {
        public static ITsReturnStatement WithExpression(this ITsReturnStatement node, ITsExpression? value) =>
            node.Expression == value ? node : new TsReturnStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// WithStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'with' statement of the form, 'with (expression) statement'.
    /// </summary>
    public interface ITsWithStatement : ITsStatement
    {
        ITsExpression Expression { get; }
        ITsStatement Statement { get; }
    }

    /// <summary>
    /// Represents a 'with' statement of the form, 'with (expression) statement'.
    /// </summary>
    internal partial class TsWithStatement : TsAstNode, ITsWithStatement
    {
        public TsWithStatement(
            ITsExpression expression,
            ITsStatement statement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, statement);
            Expression = expression;
            Statement = statement;
        }

        public ITsExpression Expression { get; }
        public ITsStatement Statement { get; }

        partial void VerifyInputs(ITsExpression expression, ITsStatement statement);
        public override void Accept(TsVisitor visitor) => visitor.VisitWithStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitWithStatement(emitter, this);
    }

    public static class WithStatementExtensions
    {
        public static ITsWithStatement WithExpression(this ITsWithStatement node, ITsExpression value) =>
            node.Expression == value ? node : new TsWithStatement(value, node.Statement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsWithStatement WithStatement(this ITsWithStatement node, ITsStatement value) =>
            node.Statement == value ? node : new TsWithStatement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SwitchStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a switch statement of the form 'switch (condition) { case x: statement; default: statement; }'.
    /// </summary>
    public interface ITsSwitchStatement : ITsStatement
    {
        ITsExpression Condition { get; }
        ImmutableArray<ITsCaseOrDefaultClause> Clauses { get; }
    }

    /// <summary>
    /// Represents a switch statement of the form 'switch (condition) { case x: statement; default: statement; }'.
    /// </summary>
    internal partial class TsSwitchStatement : TsAstNode, ITsSwitchStatement
    {
        public TsSwitchStatement(
            ITsExpression condition,
            ImmutableArray<ITsCaseOrDefaultClause> clauses,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(condition, clauses);
            Condition = condition;
            Clauses = clauses;
        }

        public ITsExpression Condition { get; }
        public ImmutableArray<ITsCaseOrDefaultClause> Clauses { get; }

        partial void VerifyInputs(ITsExpression condition, ImmutableArray<ITsCaseOrDefaultClause> clauses);
        public override void Accept(TsVisitor visitor) => visitor.VisitSwitchStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSwitchStatement(emitter, this);
    }

    public static class SwitchStatementExtensions
    {
        public static ITsSwitchStatement WithCondition(this ITsSwitchStatement node, ITsExpression value) =>
            node.Condition == value ? node : new TsSwitchStatement(value, node.Clauses, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSwitchStatement WithClauses(this ITsSwitchStatement node, ImmutableArray<ITsCaseOrDefaultClause> value) =>
            node.Clauses == value ? node : new TsSwitchStatement(node.Condition, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CaseOrDefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents either a 'case' or 'default' clause within a 'switch' statement.
    /// </summary>
    public interface ITsCaseOrDefaultClause : ITsAstNode
    {
        ImmutableArray<ITsStatementListItem>? Statements { get; }
    }

    //// ===============================================================================================================
    //// CaseClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    public interface ITsCaseClause : ITsCaseOrDefaultClause
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a 'case' clause within a 'switch' statement of the form 'case expression: statements'.
    /// </summary>
    internal partial class TsCaseClause : TsAstNode, ITsCaseClause
    {
        public TsCaseClause(
            ITsExpression expression,
            ImmutableArray<ITsStatementListItem>? statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, statements);
            Expression = expression;
            Statements = statements;
        }

        public ITsExpression Expression { get; }
        public ImmutableArray<ITsStatementListItem>? Statements { get; }

        partial void VerifyInputs(ITsExpression expression, ImmutableArray<ITsStatementListItem>? statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitCaseClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCaseClause(emitter, this);
    }

    public static class CaseClauseExtensions
    {
        public static ITsCaseClause WithExpression(this ITsCaseClause node, ITsExpression value) =>
            node.Expression == value ? node : new TsCaseClause(value, node.Statements, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCaseClause WithStatements(this ITsCaseClause node, ImmutableArray<ITsStatementListItem>? value) =>
            node.Statements == value ? node : new TsCaseClause(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DefaultClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    public interface ITsDefaultClause : ITsCaseOrDefaultClause
    {
    }

    /// <summary>
    /// Represents a 'default' clause within a 'switch' statement of the form 'default: statements'.
    /// </summary>
    internal partial class TsDefaultClause : TsAstNode, ITsDefaultClause
    {
        public TsDefaultClause(
            ImmutableArray<ITsStatementListItem>? statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem>? Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem>? statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitDefaultClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDefaultClause(emitter, this);
    }

    public static class DefaultClauseExtensions
    {
        public static ITsDefaultClause WithStatements(this ITsDefaultClause node, ImmutableArray<ITsStatementListItem>? value) =>
            node.Statements == value ? node : new TsDefaultClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// LabeledStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a labeled statement.
    /// </summary>
    public interface ITsLabeledStatement : ITsStatement
    {
        ITsIdentifier Label { get; }
        ITsStatement? Statement { get; }
        ITsFunctionDeclaration? FunctionDeclaration { get; }
    }

    /// <summary>
    /// Represents a labeled statement.
    /// </summary>
    internal partial class TsLabeledStatement : TsAstNode, ITsLabeledStatement
    {
        public TsLabeledStatement(
            ITsIdentifier label,
            ITsStatement? statement,
            ITsFunctionDeclaration? functionDeclaration,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(label, statement, functionDeclaration);
            Label = label;
            Statement = statement;
            FunctionDeclaration = functionDeclaration;
        }

        public ITsIdentifier Label { get; }
        public ITsStatement? Statement { get; }
        public ITsFunctionDeclaration? FunctionDeclaration { get; }

        partial void VerifyInputs(ITsIdentifier label, ITsStatement? statement, ITsFunctionDeclaration? functionDeclaration);
        public override void Accept(TsVisitor visitor) => visitor.VisitLabeledStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitLabeledStatement(emitter, this);
    }

    public static class LabeledStatementExtensions
    {
        public static ITsLabeledStatement WithLabel(this ITsLabeledStatement node, ITsIdentifier value) =>
            node.Label == value ? node : new TsLabeledStatement(value, node.Statement, node.FunctionDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLabeledStatement WithStatement(this ITsLabeledStatement node, ITsStatement? value) =>
            node.Statement == value ? node : new TsLabeledStatement(node.Label, value, node.FunctionDeclaration, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLabeledStatement WithFunctionDeclaration(this ITsLabeledStatement node, ITsFunctionDeclaration? value) =>
            node.FunctionDeclaration == value ? node : new TsLabeledStatement(node.Label, node.Statement, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ThrowStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'throw' statement.
    /// </summary>
    public interface ITsThrowStatement : ITsStatement
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a 'throw' statement.
    /// </summary>
    internal partial class TsThrowStatement : TsAstNode, ITsThrowStatement
    {
        public TsThrowStatement(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitThrowStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitThrowStatement(emitter, this);
    }

    public static class ThrowStatementExtensions
    {
        public static ITsThrowStatement WithExpression(this ITsThrowStatement node, ITsExpression value) =>
            node.Expression == value ? node : new TsThrowStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TryStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a try/catch/finally statement.
    /// </summary>
    public interface ITsTryStatement : ITsStatement
    {
        ITsBlockStatement TryBlock { get; }
        ITsBindingIdentifierOrPattern? CatchParameter { get; }
        ITsBlockStatement? CatchBlock { get; }
        ITsBlockStatement? FinallyBlock { get; }
    }

    /// <summary>
    /// Represents a try/catch/finally statement.
    /// </summary>
    internal partial class TsTryStatement : TsAstNode, ITsTryStatement
    {
        public TsTryStatement(
            ITsBlockStatement tryBlock,
            ITsBindingIdentifierOrPattern? catchParameter,
            ITsBlockStatement? catchBlock,
            ITsBlockStatement? finallyBlock,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(tryBlock, catchParameter, catchBlock, finallyBlock);
            TryBlock = tryBlock;
            CatchParameter = catchParameter;
            CatchBlock = catchBlock;
            FinallyBlock = finallyBlock;
        }

        public ITsBlockStatement TryBlock { get; }
        public ITsBindingIdentifierOrPattern? CatchParameter { get; }
        public ITsBlockStatement? CatchBlock { get; }
        public ITsBlockStatement? FinallyBlock { get; }

        partial void VerifyInputs(ITsBlockStatement tryBlock, ITsBindingIdentifierOrPattern? catchParameter, ITsBlockStatement? catchBlock, ITsBlockStatement? finallyBlock);
        public override void Accept(TsVisitor visitor) => visitor.VisitTryStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTryStatement(emitter, this);
    }

    public static class TryStatementExtensions
    {
        public static ITsTryStatement WithTryBlock(this ITsTryStatement node, ITsBlockStatement value) =>
            node.TryBlock == value ? node : new TsTryStatement(value, node.CatchParameter, node.CatchBlock, node.FinallyBlock, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTryStatement WithCatchParameter(this ITsTryStatement node, ITsBindingIdentifierOrPattern? value) =>
            node.CatchParameter == value ? node : new TsTryStatement(node.TryBlock, value, node.CatchBlock, node.FinallyBlock, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTryStatement WithCatchBlock(this ITsTryStatement node, ITsBlockStatement? value) =>
            node.CatchBlock == value ? node : new TsTryStatement(node.TryBlock, node.CatchParameter, value, node.FinallyBlock, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTryStatement WithFinallyBlock(this ITsTryStatement node, ITsBlockStatement? value) =>
            node.FinallyBlock == value ? node : new TsTryStatement(node.TryBlock, node.CatchParameter, node.CatchBlock, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// DebuggerStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a 'debugger' statement.
    /// </summary>
    public interface ITsDebuggerStatement : ITsStatement
    {
    }

    /// <summary>
    /// Represents a 'debugger' statement.
    /// </summary>
    internal partial class TsDebuggerStatement : TsAstNode, ITsDebuggerStatement
    {
        public TsDebuggerStatement(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitDebuggerStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitDebuggerStatement(emitter, this);
    }

    //// ===============================================================================================================
    //// ArrowFunction
    //// ===============================================================================================================

    /// <summary>
    /// Represents an arrow function expression of the form '() => body'.
    /// </summary>
    public interface ITsArrowFunction : ITsExpression
    {
        ITsIdentifier? SingleParameterName { get; }
        ITsCallSignature? CallSignature { get; }
        ITsExpression? BodyExpression { get; }
        ImmutableArray<ITsStatementListItem>? Body { get; }
    }

    /// <summary>
    /// Represents an arrow function expression of the form '() => body'.
    /// </summary>
    internal partial class TsArrowFunction : TsAstNode, ITsArrowFunction
    {
        public TsArrowFunction(
            ITsIdentifier? singleParameterName,
            ITsCallSignature? callSignature,
            ITsExpression? bodyExpression,
            ImmutableArray<ITsStatementListItem>? body,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(singleParameterName, callSignature, bodyExpression, body);
            SingleParameterName = singleParameterName;
            CallSignature = callSignature;
            BodyExpression = bodyExpression;
            Body = body;
        }

        public ITsIdentifier? SingleParameterName { get; }
        public ITsCallSignature? CallSignature { get; }
        public ITsExpression? BodyExpression { get; }
        public ImmutableArray<ITsStatementListItem>? Body { get; }

        partial void VerifyInputs(ITsIdentifier? singleParameterName, ITsCallSignature? callSignature, ITsExpression? bodyExpression, ImmutableArray<ITsStatementListItem>? body);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrowFunction(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrowFunction(emitter, this);
    }

    public static class ArrowFunctionExtensions
    {
        public static ITsArrowFunction WithSingleParameterName(this ITsArrowFunction node, ITsIdentifier? value) =>
            node.SingleParameterName == value ? node : new TsArrowFunction(value, node.CallSignature, node.BodyExpression, node.Body, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrowFunction WithCallSignature(this ITsArrowFunction node, ITsCallSignature? value) =>
            node.CallSignature == value ? node : new TsArrowFunction(node.SingleParameterName, value, node.BodyExpression, node.Body, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrowFunction WithBodyExpression(this ITsArrowFunction node, ITsExpression? value) =>
            node.BodyExpression == value ? node : new TsArrowFunction(node.SingleParameterName, node.CallSignature, value, node.Body, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrowFunction WithBody(this ITsArrowFunction node, ImmutableArray<ITsStatementListItem>? value) =>
            node.Body == value ? node : new TsArrowFunction(node.SingleParameterName, node.CallSignature, node.BodyExpression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ClassExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a class declaration acting as an expression.
    /// </summary>
    public interface ITsClassExpression : ITsExpression
    {
        ITsIdentifier? ClassName { get; }
        ITsClassHeritage? Heritage { get; }
        ImmutableArray<ITsClassElement> ClassBody { get; }
    }

    /// <summary>
    /// Represents a class declaration acting as an expression.
    /// </summary>
    internal partial class TsClassExpression : TsAstNode, ITsClassExpression
    {
        public TsClassExpression(
            ITsIdentifier? className,
            ITsClassHeritage? heritage,
            ImmutableArray<ITsClassElement> classBody,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(className, heritage, classBody);
            ClassName = className;
            Heritage = heritage;
            ClassBody = classBody;
        }

        public ITsIdentifier? ClassName { get; }
        public ITsClassHeritage? Heritage { get; }
        public ImmutableArray<ITsClassElement> ClassBody { get; }

        partial void VerifyInputs(ITsIdentifier? className, ITsClassHeritage? heritage, ImmutableArray<ITsClassElement> classBody);
        public override void Accept(TsVisitor visitor) => visitor.VisitClassExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitClassExpression(emitter, this);
    }

    public static class ClassExpressionExtensions
    {
        public static ITsClassExpression WithClassName(this ITsClassExpression node, ITsIdentifier? value) =>
            node.ClassName == value ? node : new TsClassExpression(value, node.Heritage, node.ClassBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsClassExpression WithHeritage(this ITsClassExpression node, ITsClassHeritage? value) =>
            node.Heritage == value ? node : new TsClassExpression(node.ClassName, value, node.ClassBody, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsClassExpression WithClassBody(this ITsClassExpression node, ImmutableArray<ITsClassElement> value) =>
            node.ClassBody == value ? node : new TsClassExpression(node.ClassName, node.Heritage, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    public interface ITsImportDeclaration : ITsImplementationModuleElement
    {
        ITsImportClause? ImportClause { get; }
        ITsFromClause? FromClause { get; }
        ITsStringLiteral? Module { get; }
    }

    /// <summary>
    /// Represents an import declaration of the form 'import ImportClause FromClause;' or 'import Module;'.
    /// </summary>
    internal partial class TsImportDeclaration : TsAstNode, ITsImportDeclaration
    {
        public TsImportDeclaration(
            ITsImportClause? importClause,
            ITsFromClause? fromClause,
            ITsStringLiteral? module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(importClause, fromClause, module);
            ImportClause = importClause;
            FromClause = fromClause;
            Module = module;
        }

        public ITsImportClause? ImportClause { get; }
        public ITsFromClause? FromClause { get; }
        public ITsStringLiteral? Module { get; }

        partial void VerifyInputs(ITsImportClause? importClause, ITsFromClause? fromClause, ITsStringLiteral? module);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportDeclaration(emitter, this);
    }

    public static class ImportDeclarationExtensions
    {
        public static ITsImportDeclaration WithImportClause(this ITsImportDeclaration node, ITsImportClause? value) =>
            node.ImportClause == value ? node : new TsImportDeclaration(value, node.FromClause, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithFromClause(this ITsImportDeclaration node, ITsFromClause? value) =>
            node.FromClause == value ? node : new TsImportDeclaration(node.ImportClause, value, node.Module, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportDeclaration WithModule(this ITsImportDeclaration node, ITsStringLiteral? value) =>
            node.Module == value ? node : new TsImportDeclaration(node.ImportClause, node.FromClause, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    public interface ITsImportClause : ITsAstNode
    {
        ITsIdentifier? DefaultBinding { get; }
        ITsIdentifier? NamespaceBinding { get; }
        ImmutableArray<ITsImportSpecifier>? NamedImports { get; }
    }

    /// <summary>
    /// Represents an import clause of the form 'identifier', '* as identifier', '{ importSpecifier, ... }', 'identifier, * as identifier', or 'identifier, { importSpecifier, ... }'.
    /// </summary>
    internal partial class TsImportClause : TsAstNode, ITsImportClause
    {
        public TsImportClause(
            ITsIdentifier? defaultBinding,
            ITsIdentifier? namespaceBinding,
            ImmutableArray<ITsImportSpecifier>? namedImports,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(defaultBinding, namespaceBinding, namedImports);
            DefaultBinding = defaultBinding;
            NamespaceBinding = namespaceBinding;
            NamedImports = namedImports;
        }

        public ITsIdentifier? DefaultBinding { get; }
        public ITsIdentifier? NamespaceBinding { get; }
        public ImmutableArray<ITsImportSpecifier>? NamedImports { get; }

        partial void VerifyInputs(ITsIdentifier? defaultBinding, ITsIdentifier? namespaceBinding, ImmutableArray<ITsImportSpecifier>? namedImports);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportClause(emitter, this);
    }

    public static class ImportClauseExtensions
    {
        public static ITsImportClause WithDefaultBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.DefaultBinding == value ? node : new TsImportClause(value, node.NamespaceBinding, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamespaceBinding(this ITsImportClause node, ITsIdentifier? value) =>
            node.NamespaceBinding == value ? node : new TsImportClause(node.DefaultBinding, value, node.NamedImports, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportClause WithNamedImports(this ITsImportClause node, ImmutableArray<ITsImportSpecifier>? value) =>
            node.NamedImports == value ? node : new TsImportClause(node.DefaultBinding, node.NamespaceBinding, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// FromClause
    //// ===============================================================================================================

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    public interface ITsFromClause : ITsAstNode
    {
        ITsStringLiteral Module { get; }
    }

    /// <summary>
    /// Represents a from clause in an import or export statement, of the form 'from moduleName'.
    /// </summary>
    internal partial class TsFromClause : TsAstNode, ITsFromClause
    {
        public TsFromClause(
            ITsStringLiteral module,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(module);
            Module = module;
        }

        public ITsStringLiteral Module { get; }

        partial void VerifyInputs(ITsStringLiteral module);
        public override void Accept(TsVisitor visitor) => visitor.VisitFromClause(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitFromClause(emitter, this);
    }

    public static class FromClauseExtensions
    {
        public static ITsFromClause WithModule(this ITsFromClause node, ITsStringLiteral value) =>
            node.Module == value ? node : new TsFromClause(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ImportSpecifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    public interface ITsImportSpecifier : ITsAstNode
    {
        ITsIdentifier Name { get; }
        ITsIdentifier? AsName { get; }
    }

    /// <summary>
    /// Represents an import specifier, which is either an identifier or 'identifier as identifier'.
    /// </summary>
    internal partial class TsImportSpecifier : TsAstNode, ITsImportSpecifier
    {
        public TsImportSpecifier(
            ITsIdentifier name,
            ITsIdentifier? asName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, asName);
            Name = name;
            AsName = asName;
        }

        public ITsIdentifier Name { get; }
        public ITsIdentifier? AsName { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsIdentifier? asName);
        public override void Accept(TsVisitor visitor) => visitor.VisitImportSpecifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitImportSpecifier(emitter, this);
    }

    public static class ImportSpecifierExtensions
    {
        public static ITsImportSpecifier WithName(this ITsImportSpecifier node, ITsIdentifier value) =>
            node.Name == value ? node : new TsImportSpecifier(value, node.AsName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsImportSpecifier WithAsName(this ITsImportSpecifier node, ITsIdentifier? value) =>
            node.AsName == value ? node : new TsImportSpecifier(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
