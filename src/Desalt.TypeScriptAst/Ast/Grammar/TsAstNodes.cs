
// ---------------------------------------------------------------------------------------------------------------------
// <copyright file="TsAstNodes.cs" company="Justin Rockwood">
//   Copyright (c) Justin Rockwood. All Rights Reserved. Licensed under the Apache License, Version 2.0. See
//   LICENSE.txt in the project root for license information.
// </copyright>
// <auto-generated/>
// ---------------------------------------------------------------------------------------------------------------------

// DO NOT HAND-MODIFY. This is auto-generated code from the template file 'TsAstNodes.tt'.
// ReSharper disable ArrangeMethodOrOperatorBody
// ReSharper disable CheckNamespace
// ReSharper disable CompareOfFloatsByEqualityOperator
// ReSharper disable RedundantUsingDirective
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#nullable enable

// ---------------------------------------------------------------------------------------------------------------------
// References:
// * Ecma-262 6.0 (ES 2015) Grammar (http://www.ecma-international.org/ecma-262/6.0/)
// ---------------------------------------------------------------------------------------------------------------------

namespace Desalt.TypeScriptAst.Ast
{
    using System;
    using System.Collections.Immutable;
    using Desalt.TypeScriptAst.Emit;

    //// ===============================================================================================================
    //// Identifier
    //// ===============================================================================================================

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    public interface ITsIdentifier : ITsTypeName, ITsPropertyDefinition, ITsLiteralPropertyName, ITsBindingIdentifierOrPattern
    {
        string Text { get; }
    }

    /// <summary>
    /// Represents a TypeScript identifier.
    /// </summary>
    internal partial class TsIdentifier : TsAstNode, ITsIdentifier
    {
        public TsIdentifier(
            string text,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(text);
            Text = text;
        }

        public string Text { get; }

        partial void VerifyInputs(string text);
        public override void Accept(TsVisitor visitor) => visitor.VisitIdentifier(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitIdentifier(emitter, Text);
    }

    public static class IdentifierExtensions
    {
        public static ITsIdentifier WithText(this ITsIdentifier node, string value) =>
            node.Text == value ? node : new TsIdentifier(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// This
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'this' expression.
    /// </summary>
    public interface ITsThis : ITsExpression
    {
    }

    /// <summary>
    /// Represents the 'this' expression.
    /// </summary>
    internal partial class TsThis : TsAstNode, ITsThis
    {
        public TsThis(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitThis(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitThis(emitter);
    }

    //// ===============================================================================================================
    //// ParenthesizedExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a parenthesized expression, of the form '(expression)'.
    /// </summary>
    public interface ITsParenthesizedExpression : ITsExpression
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a parenthesized expression, of the form '(expression)'.
    /// </summary>
    internal partial class TsParenthesizedExpression : TsAstNode, ITsParenthesizedExpression
    {
        public TsParenthesizedExpression(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitParenthesizedExpression(emitter, Expression);
    }

    public static class ParenthesizedExpressionExtensions
    {
        public static ITsParenthesizedExpression WithExpression(this ITsParenthesizedExpression node, ITsExpression value) =>
            node.Expression == value ? node : new TsParenthesizedExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NullLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents the 'null' literal expression.
    /// </summary>
    public interface ITsNullLiteral : ITsExpression
    {
    }

    /// <summary>
    /// Represents the 'null' literal expression.
    /// </summary>
    internal partial class TsNullLiteral : TsAstNode, ITsNullLiteral
    {
        public TsNullLiteral(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitNullLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNullLiteral(emitter);
    }

    //// ===============================================================================================================
    //// BooleanLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a boolean literal expression (either 'true' or 'false').
    /// </summary>
    public interface ITsBooleanLiteral : ITsExpression
    {
        bool Value { get; }
    }

    /// <summary>
    /// Represents a boolean literal expression (either 'true' or 'false').
    /// </summary>
    internal partial class TsBooleanLiteral : TsAstNode, ITsBooleanLiteral
    {
        public TsBooleanLiteral(
            bool value,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value);
            Value = value;
        }

        public bool Value { get; }

        partial void VerifyInputs(bool value);
        public override void Accept(TsVisitor visitor) => visitor.VisitBooleanLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBooleanLiteral(emitter, Value);
    }

    public static class BooleanLiteralExtensions
    {
        public static ITsBooleanLiteral WithValue(this ITsBooleanLiteral node, bool value) =>
            node.Value == value ? node : new TsBooleanLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NumericLiteral
    //// ===============================================================================================================

    public enum TsNumericLiteralKind
    {
        Decimal,
        BinaryInteger,
        OctalInteger,
        HexInteger,
    }

    /// <summary>
    /// Represents an expression containing a numeric literal value.
    /// </summary>
    public interface ITsNumericLiteral : ITsExpression, ITsLiteralPropertyName
    {
        double Value { get; }
        TsNumericLiteralKind Kind { get; }
    }

    /// <summary>
    /// Represents an expression containing a numeric literal value.
    /// </summary>
    internal partial class TsNumericLiteral : TsAstNode, ITsNumericLiteral
    {
        public TsNumericLiteral(
            double value,
            TsNumericLiteralKind kind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value, kind);
            Value = value;
            Kind = kind;
        }

        public double Value { get; }
        public TsNumericLiteralKind Kind { get; }

        partial void VerifyInputs(double value, TsNumericLiteralKind kind);
        public override void Accept(TsVisitor visitor) => visitor.VisitNumericLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNumericLiteral(emitter, Value, Kind);
    }

    public static class NumericLiteralExtensions
    {
        public static ITsNumericLiteral WithValue(this ITsNumericLiteral node, double value) =>
            node.Value == value ? node : new TsNumericLiteral(value, node.Kind, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsNumericLiteral WithKind(this ITsNumericLiteral node, TsNumericLiteralKind value) =>
            node.Kind == value ? node : new TsNumericLiteral(node.Value, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StringLiteral
    //// ===============================================================================================================

    public enum StringLiteralQuoteKind
    {
        DoubleQuote,
        SingleQuote,
    }

    /// <summary>
    /// Represents a string literal of the form 'string' or "string".
    /// </summary>
    public interface ITsStringLiteral : ITsExpression, ITsLiteralPropertyName
    {
        string Value { get; }
        StringLiteralQuoteKind QuoteKind { get; }
    }

    /// <summary>
    /// Represents a string literal of the form 'string' or "string".
    /// </summary>
    internal partial class TsStringLiteral : TsAstNode, ITsStringLiteral
    {
        public TsStringLiteral(
            string value,
            StringLiteralQuoteKind quoteKind,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(value, quoteKind);
            Value = value;
            QuoteKind = quoteKind;
        }

        public string Value { get; }
        public StringLiteralQuoteKind QuoteKind { get; }

        partial void VerifyInputs(string value, StringLiteralQuoteKind quoteKind);
        public override void Accept(TsVisitor visitor) => visitor.VisitStringLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitStringLiteral(emitter, Value, QuoteKind);
    }

    public static class StringLiteralExtensions
    {
        public static ITsStringLiteral WithValue(this ITsStringLiteral node, string value) =>
            node.Value == value ? node : new TsStringLiteral(value, node.QuoteKind, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsStringLiteral WithQuoteKind(this ITsStringLiteral node, StringLiteralQuoteKind value) =>
            node.QuoteKind == value ? node : new TsStringLiteral(node.Value, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// RegularExpressionLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a regular expression literal of the form '/body/flags'.
    /// </summary>
    public interface ITsRegularExpressionLiteral : ITsExpression
    {
        string Body { get; }
        string? Flags { get; }
    }

    /// <summary>
    /// Represents a regular expression literal of the form '/body/flags'.
    /// </summary>
    internal partial class TsRegularExpressionLiteral : TsAstNode, ITsRegularExpressionLiteral
    {
        public TsRegularExpressionLiteral(
            string body,
            string? flags,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(body, flags);
            Body = body;
            Flags = flags;
        }

        public string Body { get; }
        public string? Flags { get; }

        partial void VerifyInputs(string body, string? flags);
        public override void Accept(TsVisitor visitor) => visitor.VisitRegularExpressionLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitRegularExpressionLiteral(emitter, Body, Flags);
    }

    public static class RegularExpressionLiteralExtensions
    {
        public static ITsRegularExpressionLiteral WithBody(this ITsRegularExpressionLiteral node, string value) =>
            node.Body == value ? node : new TsRegularExpressionLiteral(value, node.Flags, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsRegularExpressionLiteral WithFlags(this ITsRegularExpressionLiteral node, string? value) =>
            node.Flags == value ? node : new TsRegularExpressionLiteral(node.Body, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array literal of the form '[element...]'.
    /// </summary>
    public interface ITsArrayLiteral : ITsExpression
    {
        ImmutableArray<ITsArrayElement?> Elements { get; }
    }

    /// <summary>
    /// Represents an array literal of the form '[element...]'.
    /// </summary>
    internal partial class TsArrayLiteral : TsAstNode, ITsArrayLiteral
    {
        public TsArrayLiteral(
            ImmutableArray<ITsArrayElement?> elements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements);
            Elements = elements;
        }

        public ImmutableArray<ITsArrayElement?> Elements { get; }

        partial void VerifyInputs(ImmutableArray<ITsArrayElement?> elements);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayLiteral(emitter, Elements);
    }

    public static class ArrayLiteralExtensions
    {
        public static ITsArrayLiteral WithElements(this ITsArrayLiteral node, ImmutableArray<ITsArrayElement?> value) =>
            node.Elements == value ? node : new TsArrayLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayElement
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    public interface ITsArrayElement : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadElement { get; }
    }

    /// <summary>
    /// Represents an element in an array.
    /// </summary>
    internal partial class TsArrayElement : TsAstNode, ITsArrayElement
    {
        public TsArrayElement(
            ITsExpression expression,
            bool isSpreadElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadElement);
            Expression = expression;
            IsSpreadElement = isSpreadElement;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the <see cref="Expression" /> is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadElement { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayElement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayElement(emitter, Expression, IsSpreadElement);
    }

    public static class ArrayElementExtensions
    {
        public static ITsArrayElement WithExpression(this ITsArrayElement node, ITsExpression value) =>
            node.Expression == value ? node : new TsArrayElement(value, node.IsSpreadElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayElement WithIsSpreadElement(this ITsArrayElement node, bool value) =>
            node.IsSpreadElement == value ? node : new TsArrayElement(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ObjectLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents on object literal of the form '{ PropertyDefinition... }'.
    /// </summary>
    public interface ITsObjectLiteral : ITsExpression
    {
        ImmutableArray<ITsPropertyDefinition> PropertyDefinitions { get; }
    }

    /// <summary>
    /// Represents on object literal of the form '{ PropertyDefinition... }'.
    /// </summary>
    internal partial class TsObjectLiteral : TsAstNode, ITsObjectLiteral
    {
        public TsObjectLiteral(
            ImmutableArray<ITsPropertyDefinition> propertyDefinitions,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyDefinitions);
            PropertyDefinitions = propertyDefinitions;
        }

        public ImmutableArray<ITsPropertyDefinition> PropertyDefinitions { get; }

        partial void VerifyInputs(ImmutableArray<ITsPropertyDefinition> propertyDefinitions);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectLiteral(emitter, PropertyDefinitions);
    }

    public static class ObjectLiteralExtensions
    {
        public static ITsObjectLiteral WithPropertyDefinitions(this ITsObjectLiteral node, ImmutableArray<ITsPropertyDefinition> value) =>
            node.PropertyDefinitions == value ? node : new TsObjectLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyDefinition
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property definition within an object literal.
    /// </summary>
    public interface ITsPropertyDefinition : ITsExpression
    {
    }

    //// ===============================================================================================================
    //// CoverInitializedName
    //// ===============================================================================================================

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    public interface ITsCoverInitializedName : ITsPropertyDefinition
    {
        ITsIdentifier Identifier { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents an element in an object initializer of the form 'identifier = expression'.
    /// </summary>
    internal partial class TsCoverInitializedName : TsAstNode, ITsCoverInitializedName
    {
        public TsCoverInitializedName(
            ITsIdentifier identifier,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(identifier, initializer);
            Identifier = identifier;
            Initializer = initializer;
        }

        public ITsIdentifier Identifier { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsIdentifier identifier, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitCoverInitializedName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCoverInitializedName(emitter, Identifier, Initializer);
    }

    public static class CoverInitializedNameExtensions
    {
        public static ITsCoverInitializedName WithIdentifier(this ITsCoverInitializedName node, ITsIdentifier value) =>
            node.Identifier == value ? node : new TsCoverInitializedName(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCoverInitializedName WithInitializer(this ITsCoverInitializedName node, ITsExpression value) =>
            node.Initializer == value ? node : new TsCoverInitializedName(node.Identifier, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyAssignment
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    public interface ITsPropertyAssignment : ITsPropertyDefinition
    {
        ITsPropertyName PropertyName { get; }
        ITsExpression Initializer { get; }
    }

    /// <summary>
    /// Represents a property assignment within an object literal of the form 'propertyName: initializer'.
    /// </summary>
    internal partial class TsPropertyAssignment : TsAstNode, ITsPropertyAssignment
    {
        public TsPropertyAssignment(
            ITsPropertyName propertyName,
            ITsExpression initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, initializer);
            PropertyName = propertyName;
            Initializer = initializer;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsExpression Initializer { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsExpression initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyAssignment(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyAssignment(emitter, PropertyName, Initializer);
    }

    public static class PropertyAssignmentExtensions
    {
        public static ITsPropertyAssignment WithPropertyName(this ITsPropertyAssignment node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyAssignment(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyAssignment WithInitializer(this ITsPropertyAssignment node, ITsExpression value) =>
            node.Initializer == value ? node : new TsPropertyAssignment(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single property name within an object literal.
    /// </summary>
    public interface ITsPropertyName : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// LiteralPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name within an object literal, which can be an identifier, string literal, or a numeric literal.
    /// </summary>
    public interface ITsLiteralPropertyName : ITsPropertyName
    {
    }

    //// ===============================================================================================================
    //// ComputedPropertyName
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    public interface ITsComputedPropertyName : ITsPropertyName
    {
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a property name inside of an object of the form '[ expression ]'.
    /// </summary>
    internal partial class TsComputedPropertyName : TsAstNode, ITsComputedPropertyName
    {
        public TsComputedPropertyName(
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression);
            Expression = expression;
        }

        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitComputedPropertyName(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitComputedPropertyName(emitter, Expression);
    }

    public static class ComputedPropertyNameExtensions
    {
        public static ITsComputedPropertyName WithExpression(this ITsComputedPropertyName node, ITsExpression value) =>
            node.Expression == value ? node : new TsComputedPropertyName(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplatePart
    //// ===============================================================================================================

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    public interface ITsTemplatePart : ITsAstNode
    {
        string Template { get; }
        ITsExpression? Expression { get; }
    }

    /// <summary>
    /// Represents a part within a template string literal.
    /// </summary>
    internal partial class TsTemplatePart : TsAstNode, ITsTemplatePart
    {
        public TsTemplatePart(
            string template,
            ITsExpression? expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(template, expression);
            Template = template;
            Expression = expression;
        }

        public string Template { get; }
        public ITsExpression? Expression { get; }

        partial void VerifyInputs(string template, ITsExpression? expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplatePart(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplatePart(emitter, Template, Expression);
    }

    public static class TemplatePartExtensions
    {
        public static ITsTemplatePart WithTemplate(this ITsTemplatePart node, string value) =>
            node.Template == value ? node : new TsTemplatePart(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsTemplatePart WithExpression(this ITsTemplatePart node, ITsExpression? value) =>
            node.Expression == value ? node : new TsTemplatePart(node.Template, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// TemplateLiteral
    //// ===============================================================================================================

    /// <summary>
    /// Represents a template string literal.
    /// </summary>
    public interface ITsTemplateLiteral : ITsExpression
    {
        ImmutableArray<ITsTemplatePart> Parts { get; }
    }

    /// <summary>
    /// Represents a template string literal.
    /// </summary>
    internal partial class TsTemplateLiteral : TsAstNode, ITsTemplateLiteral
    {
        public TsTemplateLiteral(
            ImmutableArray<ITsTemplatePart> parts,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(parts);
            Parts = parts;
        }

        public ImmutableArray<ITsTemplatePart> Parts { get; }

        partial void VerifyInputs(ImmutableArray<ITsTemplatePart> parts);
        public override void Accept(TsVisitor visitor) => visitor.VisitTemplateLiteral(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitTemplateLiteral(emitter, Parts);
    }

    public static class TemplateLiteralExtensions
    {
        public static ITsTemplateLiteral WithParts(this ITsTemplateLiteral node, ImmutableArray<ITsTemplatePart> value) =>
            node.Parts == value ? node : new TsTemplateLiteral(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MemberBracketExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'expression[expression]'.
    /// </summary>
    public interface ITsMemberBracketExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsExpression BracketContents { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'expression[expression]'.
    /// </summary>
    internal partial class TsMemberBracketExpression : TsAstNode, ITsMemberBracketExpression
    {
        public TsMemberBracketExpression(
            ITsExpression leftSide,
            ITsExpression bracketContents,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, bracketContents);
            LeftSide = leftSide;
            BracketContents = bracketContents;
        }

        public ITsExpression LeftSide { get; }
        public ITsExpression BracketContents { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsExpression bracketContents);
        public override void Accept(TsVisitor visitor) => visitor.VisitMemberBracketExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberBracketExpression(emitter, LeftSide, BracketContents);
    }

    public static class MemberBracketExpressionExtensions
    {
        public static ITsMemberBracketExpression WithLeftSide(this ITsMemberBracketExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsMemberBracketExpression(value, node.BracketContents, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMemberBracketExpression WithBracketContents(this ITsMemberBracketExpression node, ITsExpression value) =>
            node.BracketContents == value ? node : new TsMemberBracketExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// MemberDotExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'expression.name'.
    /// </summary>
    public interface ITsMemberDotExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        string DotName { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'expression.name'.
    /// </summary>
    internal partial class TsMemberDotExpression : TsAstNode, ITsMemberDotExpression
    {
        public TsMemberDotExpression(
            ITsExpression leftSide,
            string dotName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, dotName);
            LeftSide = leftSide;
            DotName = dotName;
        }

        public ITsExpression LeftSide { get; }
        public string DotName { get; }

        partial void VerifyInputs(ITsExpression leftSide, string dotName);
        public override void Accept(TsVisitor visitor) => visitor.VisitMemberDotExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitMemberDotExpression(emitter, LeftSide, DotName);
    }

    public static class MemberDotExpressionExtensions
    {
        public static ITsMemberDotExpression WithLeftSide(this ITsMemberDotExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsMemberDotExpression(value, node.DotName, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsMemberDotExpression WithDotName(this ITsMemberDotExpression node, string value) =>
            node.DotName == value ? node : new TsMemberDotExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperBracketExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'super[expression]'.
    /// </summary>
    public interface ITsSuperBracketExpression : ITsExpression
    {
        ITsExpression BracketContents { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'super[expression]'.
    /// </summary>
    internal partial class TsSuperBracketExpression : TsAstNode, ITsSuperBracketExpression
    {
        public TsSuperBracketExpression(
            ITsExpression bracketContents,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bracketContents);
            BracketContents = bracketContents;
        }

        public ITsExpression BracketContents { get; }

        partial void VerifyInputs(ITsExpression bracketContents);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperBracketExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperBracketExpression(emitter, BracketContents);
    }

    public static class SuperBracketExpressionExtensions
    {
        public static ITsSuperBracketExpression WithBracketContents(this ITsSuperBracketExpression node, ITsExpression value) =>
            node.BracketContents == value ? node : new TsSuperBracketExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperDotExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a member expression of the form 'super.name'.
    /// </summary>
    public interface ITsSuperDotExpression : ITsExpression
    {
        string DotName { get; }
    }

    /// <summary>
    /// Represents a member expression of the form 'super.name'.
    /// </summary>
    internal partial class TsSuperDotExpression : TsAstNode, ITsSuperDotExpression
    {
        public TsSuperDotExpression(
            string dotName,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(dotName);
            DotName = dotName;
        }

        public string DotName { get; }

        partial void VerifyInputs(string dotName);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperDotExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperDotExpression(emitter, DotName);
    }

    public static class SuperDotExpressionExtensions
    {
        public static ITsSuperDotExpression WithDotName(this ITsSuperDotExpression node, string value) =>
            node.DotName == value ? node : new TsSuperDotExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NewTargetExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression of the form 'new.target'.
    /// </summary>
    public interface ITsNewTargetExpression : ITsExpression
    {
    }

    /// <summary>
    /// Represents an expression of the form 'new.target'.
    /// </summary>
    internal partial class TsNewTargetExpression : TsAstNode, ITsNewTargetExpression
    {
        public TsNewTargetExpression(
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs();
        }

        partial void VerifyInputs();
        public override void Accept(TsVisitor visitor) => visitor.VisitNewTargetExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNewTargetExpression(emitter);
    }

    //// ===============================================================================================================
    //// CallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'expression(arguments)'.
    /// </summary>
    public interface ITsCallExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'expression(arguments)'.
    /// </summary>
    internal partial class TsCallExpression : TsAstNode, ITsCallExpression
    {
        public TsCallExpression(
            ITsExpression leftSide,
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, argumentList);
            LeftSide = leftSide;
            ArgumentList = argumentList;
        }

        public ITsExpression LeftSide { get; }
        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCallExpression(emitter, LeftSide, ArgumentList);
    }

    public static class CallExpressionExtensions
    {
        public static ITsCallExpression WithLeftSide(this ITsCallExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsCallExpression(value, node.ArgumentList, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCallExpression WithArgumentList(this ITsCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsCallExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// NewCallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'new expression(arguments)'.
    /// </summary>
    public interface ITsNewCallExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'new expression(arguments)'.
    /// </summary>
    internal partial class TsNewCallExpression : TsAstNode, ITsNewCallExpression
    {
        public TsNewCallExpression(
            ITsExpression leftSide,
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, argumentList);
            LeftSide = leftSide;
            ArgumentList = argumentList;
        }

        public ITsExpression LeftSide { get; }
        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsExpression leftSide, ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitNewCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitNewCallExpression(emitter, LeftSide, ArgumentList);
    }

    public static class NewCallExpressionExtensions
    {
        public static ITsNewCallExpression WithLeftSide(this ITsNewCallExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsNewCallExpression(value, node.ArgumentList, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsNewCallExpression WithArgumentList(this ITsNewCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsNewCallExpression(node.LeftSide, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// SuperCallExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a call expression of the form 'super(arguments)'.
    /// </summary>
    public interface ITsSuperCallExpression : ITsExpression
    {
        ITsArgumentList ArgumentList { get; }
    }

    /// <summary>
    /// Represents a call expression of the form 'super(arguments)'.
    /// </summary>
    internal partial class TsSuperCallExpression : TsAstNode, ITsSuperCallExpression
    {
        public TsSuperCallExpression(
            ITsArgumentList argumentList,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(argumentList);
            ArgumentList = argumentList;
        }

        public ITsArgumentList ArgumentList { get; }

        partial void VerifyInputs(ITsArgumentList argumentList);
        public override void Accept(TsVisitor visitor) => visitor.VisitSuperCallExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSuperCallExpression(emitter, ArgumentList);
    }

    public static class SuperCallExpressionExtensions
    {
        public static ITsSuperCallExpression WithArgumentList(this ITsSuperCallExpression node, ITsArgumentList value) =>
            node.ArgumentList == value ? node : new TsSuperCallExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArgumentList
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    public interface ITsArgumentList : ITsAstNode
    {
        ImmutableArray<ITsType> TypeArguments { get; }
        ImmutableArray<ITsArgument> Arguments { get; }
    }

    /// <summary>
    /// Represents an argument list of the form '&lt;T&gt;(x: type, y: type).
    /// </summary>
    internal partial class TsArgumentList : TsAstNode, ITsArgumentList
    {
        public TsArgumentList(
            ImmutableArray<ITsType> typeArguments,
            ImmutableArray<ITsArgument> arguments,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(typeArguments, arguments);
            TypeArguments = typeArguments;
            Arguments = arguments;
        }

        public ImmutableArray<ITsType> TypeArguments { get; }
        public ImmutableArray<ITsArgument> Arguments { get; }

        partial void VerifyInputs(ImmutableArray<ITsType> typeArguments, ImmutableArray<ITsArgument> arguments);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgumentList(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgumentList(emitter, TypeArguments, Arguments);
    }

    public static class ArgumentListExtensions
    {
        public static ITsArgumentList WithTypeArguments(this ITsArgumentList node, ImmutableArray<ITsType> value) =>
            node.TypeArguments == value ? node : new TsArgumentList(value, node.Arguments, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgumentList WithArguments(this ITsArgumentList node, ImmutableArray<ITsArgument> value) =>
            node.Arguments == value ? node : new TsArgumentList(node.TypeArguments, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Argument
    //// ===============================================================================================================

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    public interface ITsArgument : ITsAstNode
    {
        ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        bool IsSpreadArgument { get; }
    }

    /// <summary>
    /// Represents an argument within an <see cref="ITsArgumentList" />.
    /// </summary>
    internal partial class TsArgument : TsAstNode, ITsArgument
    {
        public TsArgument(
            ITsExpression expression,
            bool isSpreadArgument,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expression, isSpreadArgument);
            Expression = expression;
            IsSpreadArgument = isSpreadArgument;
        }

        public ITsExpression Expression { get; }
        /// <summary>
        /// Indicates whether the argument is preceded by a spread operator '...'.
        /// </summary>
        public bool IsSpreadArgument { get; }

        partial void VerifyInputs(ITsExpression expression, bool isSpreadArgument);
        public override void Accept(TsVisitor visitor) => visitor.VisitArgument(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArgument(emitter, Expression, IsSpreadArgument);
    }

    public static class ArgumentExtensions
    {
        public static ITsArgument WithExpression(this ITsArgument node, ITsExpression value) =>
            node.Expression == value ? node : new TsArgument(value, node.IsSpreadArgument, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArgument WithIsSpreadArgument(this ITsArgument node, bool value) =>
            node.IsSpreadArgument == value ? node : new TsArgument(node.Expression, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// UnaryExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a unary expression.
    /// </summary>
    public interface ITsUnaryExpression : ITsExpression
    {
        ITsExpression Operand { get; }
        TsUnaryOperator Operator { get; }
    }

    /// <summary>
    /// Represents a unary expression.
    /// </summary>
    internal partial class TsUnaryExpression : TsAstNode, ITsUnaryExpression
    {
        public TsUnaryExpression(
            ITsExpression operand,
            TsUnaryOperator @operator,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(operand, @operator);
            Operand = operand;
            Operator = @operator;
        }

        public ITsExpression Operand { get; }
        public TsUnaryOperator Operator { get; }

        partial void VerifyInputs(ITsExpression operand, TsUnaryOperator @operator);
        public override void Accept(TsVisitor visitor) => visitor.VisitUnaryExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitUnaryExpression(emitter, Operand, Operator);
    }

    public static class UnaryExpressionExtensions
    {
        public static ITsUnaryExpression WithOperand(this ITsUnaryExpression node, ITsExpression value) =>
            node.Operand == value ? node : new TsUnaryExpression(value, node.Operator, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsUnaryExpression WithOperator(this ITsUnaryExpression node, TsUnaryOperator value) =>
            node.Operator == value ? node : new TsUnaryExpression(node.Operand, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// CastExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a unary cast expression of the form, '&lt;Type&gt;expression'.
    /// </summary>
    public interface ITsCastExpression : ITsExpression
    {
        ITsType CastType { get; }
        ITsExpression Expression { get; }
    }

    /// <summary>
    /// Represents a unary cast expression of the form, '&lt;Type&gt;expression'.
    /// </summary>
    internal partial class TsCastExpression : TsAstNode, ITsCastExpression
    {
        public TsCastExpression(
            ITsType castType,
            ITsExpression expression,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(castType, expression);
            CastType = castType;
            Expression = expression;
        }

        public ITsType CastType { get; }
        public ITsExpression Expression { get; }

        partial void VerifyInputs(ITsType castType, ITsExpression expression);
        public override void Accept(TsVisitor visitor) => visitor.VisitCastExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCastExpression(emitter, CastType, Expression);
    }

    public static class CastExpressionExtensions
    {
        public static ITsCastExpression WithCastType(this ITsCastExpression node, ITsType value) =>
            node.CastType == value ? node : new TsCastExpression(value, node.Expression, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsCastExpression WithExpression(this ITsCastExpression node, ITsExpression value) =>
            node.Expression == value ? node : new TsCastExpression(node.CastType, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BinaryExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a binary expression.
    /// </summary>
    public interface ITsBinaryExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        TsBinaryOperator Operator { get; }
        ITsExpression RightSide { get; }
    }

    /// <summary>
    /// Represents a binary expression.
    /// </summary>
    internal partial class TsBinaryExpression : TsAstNode, ITsBinaryExpression
    {
        public TsBinaryExpression(
            ITsExpression leftSide,
            TsBinaryOperator @operator,
            ITsExpression rightSide,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, @operator, rightSide);
            LeftSide = leftSide;
            Operator = @operator;
            RightSide = rightSide;
        }

        public ITsExpression LeftSide { get; }
        public TsBinaryOperator Operator { get; }
        public ITsExpression RightSide { get; }

        partial void VerifyInputs(ITsExpression leftSide, TsBinaryOperator @operator, ITsExpression rightSide);
        public override void Accept(TsVisitor visitor) => visitor.VisitBinaryExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBinaryExpression(emitter, LeftSide, Operator, RightSide);
    }

    public static class BinaryExpressionExtensions
    {
        public static ITsBinaryExpression WithLeftSide(this ITsBinaryExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsBinaryExpression(value, node.Operator, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBinaryExpression WithOperator(this ITsBinaryExpression node, TsBinaryOperator value) =>
            node.Operator == value ? node : new TsBinaryExpression(node.LeftSide, value, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsBinaryExpression WithRightSide(this ITsBinaryExpression node, ITsExpression value) =>
            node.RightSide == value ? node : new TsBinaryExpression(node.LeftSide, node.Operator, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ConditionalExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents a conditional expression of the form 'x ? y : z'.
    /// </summary>
    public interface ITsConditionalExpression : ITsExpression
    {
        ITsExpression Condition { get; }
        ITsExpression WhenTrue { get; }
        ITsExpression WhenFalse { get; }
    }

    /// <summary>
    /// Represents a conditional expression of the form 'x ? y : z'.
    /// </summary>
    internal partial class TsConditionalExpression : TsAstNode, ITsConditionalExpression
    {
        public TsConditionalExpression(
            ITsExpression condition,
            ITsExpression whenTrue,
            ITsExpression whenFalse,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(condition, whenTrue, whenFalse);
            Condition = condition;
            WhenTrue = whenTrue;
            WhenFalse = whenFalse;
        }

        public ITsExpression Condition { get; }
        public ITsExpression WhenTrue { get; }
        public ITsExpression WhenFalse { get; }

        partial void VerifyInputs(ITsExpression condition, ITsExpression whenTrue, ITsExpression whenFalse);
        public override void Accept(TsVisitor visitor) => visitor.VisitConditionalExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitConditionalExpression(emitter, Condition, WhenTrue, WhenFalse);
    }

    public static class ConditionalExpressionExtensions
    {
        public static ITsConditionalExpression WithCondition(this ITsConditionalExpression node, ITsExpression value) =>
            node.Condition == value ? node : new TsConditionalExpression(value, node.WhenTrue, node.WhenFalse, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConditionalExpression WithWhenTrue(this ITsConditionalExpression node, ITsExpression value) =>
            node.WhenTrue == value ? node : new TsConditionalExpression(node.Condition, value, node.WhenFalse, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsConditionalExpression WithWhenFalse(this ITsConditionalExpression node, ITsExpression value) =>
            node.WhenFalse == value ? node : new TsConditionalExpression(node.Condition, node.WhenTrue, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// AssignmentExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an assignment of the form 'left == right'.
    /// </summary>
    public interface ITsAssignmentExpression : ITsExpression
    {
        ITsExpression LeftSide { get; }
        TsAssignmentOperator Operator { get; }
        ITsExpression RightSide { get; }
    }

    /// <summary>
    /// Represents an assignment of the form 'left == right'.
    /// </summary>
    internal partial class TsAssignmentExpression : TsAstNode, ITsAssignmentExpression
    {
        public TsAssignmentExpression(
            ITsExpression leftSide,
            TsAssignmentOperator @operator,
            ITsExpression rightSide,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(leftSide, @operator, rightSide);
            LeftSide = leftSide;
            Operator = @operator;
            RightSide = rightSide;
        }

        public ITsExpression LeftSide { get; }
        public TsAssignmentOperator Operator { get; }
        public ITsExpression RightSide { get; }

        partial void VerifyInputs(ITsExpression leftSide, TsAssignmentOperator @operator, ITsExpression rightSide);
        public override void Accept(TsVisitor visitor) => visitor.VisitAssignmentExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitAssignmentExpression(emitter, LeftSide, Operator, RightSide);
    }

    public static class AssignmentExpressionExtensions
    {
        public static ITsAssignmentExpression WithLeftSide(this ITsAssignmentExpression node, ITsExpression value) =>
            node.LeftSide == value ? node : new TsAssignmentExpression(value, node.Operator, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAssignmentExpression WithOperator(this ITsAssignmentExpression node, TsAssignmentOperator value) =>
            node.Operator == value ? node : new TsAssignmentExpression(node.LeftSide, value, node.RightSide, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsAssignmentExpression WithRightSide(this ITsAssignmentExpression node, ITsExpression value) =>
            node.RightSide == value ? node : new TsAssignmentExpression(node.LeftSide, node.Operator, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Expression
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all expressions.
    /// </summary>
    public interface ITsExpression : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// CommaExpression
    //// ===============================================================================================================

    /// <summary>
    /// Represents an expression list separated by commas. Useful in for loops for the initializer or incrementor, for example.
    /// </summary>
    public interface ITsCommaExpression : ITsExpression
    {
        ImmutableArray<ITsExpression> Expressions { get; }
    }

    /// <summary>
    /// Represents an expression list separated by commas. Useful in for loops for the initializer or incrementor, for example.
    /// </summary>
    internal partial class TsCommaExpression : TsAstNode, ITsCommaExpression
    {
        public TsCommaExpression(
            ImmutableArray<ITsExpression> expressions,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(expressions);
            Expressions = expressions;
        }

        public ImmutableArray<ITsExpression> Expressions { get; }

        partial void VerifyInputs(ImmutableArray<ITsExpression> expressions);
        public override void Accept(TsVisitor visitor) => visitor.VisitCommaExpression(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitCommaExpression(emitter, Expressions);
    }

    public static class CommaExpressionExtensions
    {
        public static ITsCommaExpression WithExpressions(this ITsCommaExpression node, ImmutableArray<ITsExpression> value) =>
            node.Expressions == value ? node : new TsCommaExpression(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// Statement
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all statements.
    /// </summary>
    public interface ITsStatement : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// Declaration
    //// ===============================================================================================================

    /// <summary>
    /// Base interface for all declarations.
    /// </summary>
    public interface ITsDeclaration : ITsStatementListItem, ITsNamespaceElement, ITsImplementationElement
    {
    }

    //// ===============================================================================================================
    //// BlockStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a block statement of the form '{ statements }'.
    /// </summary>
    public interface ITsBlockStatement : ITsStatement
    {
        ImmutableArray<ITsStatementListItem> Statements { get; }
    }

    /// <summary>
    /// Represents a block statement of the form '{ statements }'.
    /// </summary>
    internal partial class TsBlockStatement : TsAstNode, ITsBlockStatement
    {
        public TsBlockStatement(
            ImmutableArray<ITsStatementListItem> statements,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(statements);
            Statements = statements;
        }

        public ImmutableArray<ITsStatementListItem> Statements { get; }

        partial void VerifyInputs(ImmutableArray<ITsStatementListItem> statements);
        public override void Accept(TsVisitor visitor) => visitor.VisitBlockStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitBlockStatement(emitter, Statements);
    }

    public static class BlockStatementExtensions
    {
        public static ITsBlockStatement WithStatements(this ITsBlockStatement node, ImmutableArray<ITsStatementListItem> value) =>
            node.Statements == value ? node : new TsBlockStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// StatementListItem
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for items that can be part of a statement list.
    /// </summary>
    public interface ITsStatementListItem : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// LexicalDeclaration
    //// ===============================================================================================================

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    public interface ITsLexicalDeclaration : ITsDeclaration
    {
        bool IsConst { get; }
        ImmutableArray<ITsLexicalBinding> Declarations { get; }
    }

    /// <summary>
    /// Represents a lexical declaration of the form 'const|let x: type, y: type = z;'.
    /// </summary>
    internal partial class TsLexicalDeclaration : TsAstNode, ITsLexicalDeclaration
    {
        public TsLexicalDeclaration(
            bool isConst,
            ImmutableArray<ITsLexicalBinding> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(isConst, declarations);
            IsConst = isConst;
            Declarations = declarations;
        }

        public bool IsConst { get; }
        public ImmutableArray<ITsLexicalBinding> Declarations { get; }

        partial void VerifyInputs(bool isConst, ImmutableArray<ITsLexicalBinding> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitLexicalDeclaration(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitLexicalDeclaration(emitter, IsConst, Declarations);
    }

    public static class LexicalDeclarationExtensions
    {
        public static ITsLexicalDeclaration WithIsConst(this ITsLexicalDeclaration node, bool value) =>
            node.IsConst == value ? node : new TsLexicalDeclaration(value, node.Declarations, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsLexicalDeclaration WithDeclarations(this ITsLexicalDeclaration node, ImmutableArray<ITsLexicalBinding> value) =>
            node.Declarations == value ? node : new TsLexicalDeclaration(node.IsConst, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// VariableStatement
    //// ===============================================================================================================

    /// <summary>
    /// Represents a variable declaration statement of the form 'var x = y;'.
    /// </summary>
    public interface ITsVariableStatement : ITsStatement
    {
        ImmutableArray<ITsVariableDeclaration> Declarations { get; }
    }

    /// <summary>
    /// Represents a variable declaration statement of the form 'var x = y;'.
    /// </summary>
    internal partial class TsVariableStatement : TsAstNode, ITsVariableStatement
    {
        public TsVariableStatement(
            ImmutableArray<ITsVariableDeclaration> declarations,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(declarations);
            Declarations = declarations;
        }

        public ImmutableArray<ITsVariableDeclaration> Declarations { get; }

        partial void VerifyInputs(ImmutableArray<ITsVariableDeclaration> declarations);
        public override void Accept(TsVisitor visitor) => visitor.VisitVariableStatement(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitVariableStatement(emitter, Declarations);
    }

    public static class VariableStatementExtensions
    {
        public static ITsVariableStatement WithDeclarations(this ITsVariableStatement node, ImmutableArray<ITsVariableDeclaration> value) =>
            node.Declarations == value ? node : new TsVariableStatement(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for a binding pattern.
    /// </summary>
    public interface ITsBindingPattern : ITsBindingIdentifierOrPattern
    {
    }

    //// ===============================================================================================================
    //// ObjectBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    public interface ITsObjectBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingProperty> Properties { get; }
    }

    /// <summary>
    /// Represents an object binding pattern of the form '{propName = defaultValue, propName: otherPropName}'.
    /// </summary>
    internal partial class TsObjectBindingPattern : TsAstNode, ITsObjectBindingPattern
    {
        public TsObjectBindingPattern(
            ImmutableArray<ITsBindingProperty> properties,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(properties);
            Properties = properties;
        }

        public ImmutableArray<ITsBindingProperty> Properties { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingProperty> properties);
        public override void Accept(TsVisitor visitor) => visitor.VisitObjectBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitObjectBindingPattern(emitter, Properties);
    }

    public static class ObjectBindingPatternExtensions
    {
        public static ITsObjectBindingPattern WithProperties(this ITsObjectBindingPattern node, ImmutableArray<ITsBindingProperty> value) =>
            node.Properties == value ? node : new TsObjectBindingPattern(value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// ArrayBindingPattern
    //// ===============================================================================================================

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    public interface ITsArrayBindingPattern : ITsBindingPattern
    {
        ImmutableArray<ITsBindingElement?> Elements { get; }
        ITsIdentifier? RestElement { get; }
    }

    /// <summary>
    /// Represents an array binding pattern of the form '[x = y, z]' or '[x = y, z, ...p]'.
    /// </summary>
    internal partial class TsArrayBindingPattern : TsAstNode, ITsArrayBindingPattern
    {
        public TsArrayBindingPattern(
            ImmutableArray<ITsBindingElement?> elements,
            ITsIdentifier? restElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(elements, restElement);
            Elements = elements;
            RestElement = restElement;
        }

        public ImmutableArray<ITsBindingElement?> Elements { get; }
        public ITsIdentifier? RestElement { get; }

        partial void VerifyInputs(ImmutableArray<ITsBindingElement?> elements, ITsIdentifier? restElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitArrayBindingPattern(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitArrayBindingPattern(emitter, Elements, RestElement);
    }

    public static class ArrayBindingPatternExtensions
    {
        public static ITsArrayBindingPattern WithElements(this ITsArrayBindingPattern node, ImmutableArray<ITsBindingElement?> value) =>
            node.Elements == value ? node : new TsArrayBindingPattern(value, node.RestElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsArrayBindingPattern WithRestElement(this ITsArrayBindingPattern node, ITsIdentifier? value) =>
            node.RestElement == value ? node : new TsArrayBindingPattern(node.Elements, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingProperty
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for properties that are bound in array or object initializers.
    /// </summary>
    public interface ITsBindingProperty : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// SingleNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    public interface ITsSingleNameBinding : ITsBindingProperty, ITsBindingElement
    {
        ITsIdentifier Name { get; }
        ITsExpression? DefaultValue { get; }
    }

    /// <summary>
    /// Represents a single name binding pattern used in object and array bindings, of the form 'name = expression'.
    /// </summary>
    internal partial class TsSingleNameBinding : TsAstNode, ITsSingleNameBinding
    {
        public TsSingleNameBinding(
            ITsIdentifier name,
            ITsExpression? defaultValue,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(name, defaultValue);
            Name = name;
            DefaultValue = defaultValue;
        }

        public ITsIdentifier Name { get; }
        public ITsExpression? DefaultValue { get; }

        partial void VerifyInputs(ITsIdentifier name, ITsExpression? defaultValue);
        public override void Accept(TsVisitor visitor) => visitor.VisitSingleNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitSingleNameBinding(emitter, Name, DefaultValue);
    }

    public static class SingleNameBindingExtensions
    {
        public static ITsSingleNameBinding WithName(this ITsSingleNameBinding node, ITsIdentifier value) =>
            node.Name == value ? node : new TsSingleNameBinding(value, node.DefaultValue, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsSingleNameBinding WithDefaultValue(this ITsSingleNameBinding node, ITsExpression? value) =>
            node.DefaultValue == value ? node : new TsSingleNameBinding(node.Name, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// PropertyNameBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    public interface ITsPropertyNameBinding : ITsBindingProperty
    {
        ITsPropertyName PropertyName { get; }
        ITsBindingElement BindingElement { get; }
    }

    /// <summary>
    /// Represents a property name binding pattern used in object and array bindings, of the form 'propertyName = expression'.
    /// </summary>
    internal partial class TsPropertyNameBinding : TsAstNode, ITsPropertyNameBinding
    {
        public TsPropertyNameBinding(
            ITsPropertyName propertyName,
            ITsBindingElement bindingElement,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(propertyName, bindingElement);
            PropertyName = propertyName;
            BindingElement = bindingElement;
        }

        public ITsPropertyName PropertyName { get; }
        public ITsBindingElement BindingElement { get; }

        partial void VerifyInputs(ITsPropertyName propertyName, ITsBindingElement bindingElement);
        public override void Accept(TsVisitor visitor) => visitor.VisitPropertyNameBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPropertyNameBinding(emitter, PropertyName, BindingElement);
    }

    public static class PropertyNameBindingExtensions
    {
        public static ITsPropertyNameBinding WithPropertyName(this ITsPropertyNameBinding node, ITsPropertyName value) =>
            node.PropertyName == value ? node : new TsPropertyNameBinding(value, node.BindingElement, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPropertyNameBinding WithBindingElement(this ITsPropertyNameBinding node, ITsBindingElement value) =>
            node.BindingElement == value ? node : new TsPropertyNameBinding(node.PropertyName, value, node.LeadingTrivia, node.TrailingTrivia);
    }

    //// ===============================================================================================================
    //// BindingElement
    //// ===============================================================================================================

    /// <summary>
    /// Marker interface for binding elements in object and array bindings.
    /// </summary>
    public interface ITsBindingElement : ITsAstNode
    {
    }

    //// ===============================================================================================================
    //// PatternBinding
    //// ===============================================================================================================

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    public interface ITsPatternBinding : ITsBindingElement
    {
        ITsBindingPattern BindingPattern { get; }
        ITsExpression? Initializer { get; }
    }

    /// <summary>
    /// Represents a recursive pattern binding in an object or array binding.
    /// </summary>
    internal partial class TsPatternBinding : TsAstNode, ITsPatternBinding
    {
        public TsPatternBinding(
            ITsBindingPattern bindingPattern,
            ITsExpression? initializer,
            ImmutableArray<ITsAstTriviaNode>? leadingTrivia = null,
            ImmutableArray<ITsAstTriviaNode>? trailingTrivia = null)
            : base(leadingTrivia, trailingTrivia)
        {
            VerifyInputs(bindingPattern, initializer);
            BindingPattern = bindingPattern;
            Initializer = initializer;
        }

        public ITsBindingPattern BindingPattern { get; }
        public ITsExpression? Initializer { get; }

        partial void VerifyInputs(ITsBindingPattern bindingPattern, ITsExpression? initializer);
        public override void Accept(TsVisitor visitor) => visitor.VisitPatternBinding(this);
        protected override void EmitContent(Emitter emitter) => TsAstEmitter.EmitPatternBinding(emitter, BindingPattern, Initializer);
    }

    public static class PatternBindingExtensions
    {
        public static ITsPatternBinding WithBindingPattern(this ITsPatternBinding node, ITsBindingPattern value) =>
            node.BindingPattern == value ? node : new TsPatternBinding(value, node.Initializer, node.LeadingTrivia, node.TrailingTrivia);

        public static ITsPatternBinding WithInitializer(this ITsPatternBinding node, ITsExpression? value) =>
            node.Initializer == value ? node : new TsPatternBinding(node.BindingPattern, value, node.LeadingTrivia, node.TrailingTrivia);
    }
}
